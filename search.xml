<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mock与单元测试</title>
    <url>/posts/a667b194/</url>
    <content><![CDATA[<p>本文讲述的是 Python 中 Mock 的使用。</p>
<h3 id="如何执行单元测试而不用考验你的耐心"><a href="#如何执行单元测试而不用考验你的耐心" class="headerlink" title="如何执行单元测试而不用考验你的耐心"></a><a href="#如何执行单元测试而不用考验你的耐心"></a>如何执行单元测试而不用考验你的耐心</h3><p>很多时候，我们编写的软件会直接与那些被标记为 “垃圾” 的服务交互。用外行人的话说：服务对我们的应用程序很重要，但是我们想要的是交互，而不是那些不想要的副作用，这里的 “不想要” 是在自动化测试运行的语境中说的。例如：我们正在写一个社交 app，并且想要测试一下 “发布到 Facebook” 的新功能，但是不想每次运行测试集的时候真的发布到 Facebook。</p>
<a id="more"></a>
<p>Python 的 <code>unittest</code> 库包含了一个名为 <code>unittest.mock</code> 或者可以称之为依赖的子包，简称为 <code>mock</code> —— 其提供了极其强大和有用的方法，通过它们可以模拟（mock）并去除那些我们不希望的副作用。</p>
<p><a href="https://camo.githubusercontent.com/facb31f7bfe115c5e687d6c27e996ac0a9ff19b9/68747470733a2f2f6173736574732e746f7074616c2e696f2f75706c6f6164732f626c6f672f696d6167652f3235322f746f7074616c2d626c6f672d696d6167652d313338393039303334363431352e706e67" target="_blank" rel="external nofollow noopener noreferrer"><img alt data-src="https://p0.ssl.qhimg.com/t01a8f8f4eb02c51190.png"></a></p>
<p><em>注意：<code>mock</code> <a href="http://www.python.org/dev/peps/pep-0417/" target="_blank" rel="external nofollow noopener noreferrer">最近被收录</a>到了 Python 3.3 的标准库中；先前发布的版本必须通过 <a href="https://pypi.python.org/pypi/mock" target="_blank" rel="external nofollow noopener noreferrer">PyPI</a> 下载 Mock 库。</em></p>
<h3 id="恐惧系统调用"><a href="#恐惧系统调用" class="headerlink" title="恐惧系统调用"></a><a href="#恐惧系统调用"></a>恐惧系统调用</h3><p>再举另一个例子，我们在接下来的部分都会用到它，这是就是<strong>系统调用</strong>。不难发现，这些系统调用都是主要的模拟对象：无论你是正在写一个可以弹出 CD 驱动器的脚本，还是一个用来删除 /tmp 下过期的缓存文件的 Web 服务，或者一个绑定到 TCP 端口的 socket 服务器，这些调用都是在你的单元测试上下文中不希望产生的副作用。</p>
<p>作为一个开发者，你需要更关心你的库是否成功地调用了一个可以弹出 CD 的系统函数（使用了正确的参数等等），而不是切身经历 CD 托盘每次在测试执行的时候都打开了。（或者更糟糕的是，弹出了很多次，在一个单元测试运行期间多个测试都引用了弹出代码！）</p>
<p>同样，保持单元测试的效率和性能意味着需要让如此多的 “缓慢代码” 远离自动测试，比如文件系统和网络访问。</p>
<p>对于第一个例子来说，我们要从原始形式换成使用 <code>mock</code> 重构一个标准 Python 测试用例。我们会演示如何使用 mock 写一个测试用例，使我们的测试更加智能、快速，并展示更多关于我们软件的工作原理。</p>
<h3 id="一个简单的删除函数"><a href="#一个简单的删除函数" class="headerlink" title="一个简单的删除函数"></a><a href="#一个简单的删除函数"></a>一个简单的删除函数</h3><p>我们都有过需要从文件系统中一遍又一遍的删除文件的时候，因此，让我们在 Python 中写一个可以使我们的脚本更加轻易完成此功能的函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def rm(filename):</span><br><span class="line">    os.remove(filename)</span><br></pre></td></tr></table></figure>

<p>很明显，我们的 <code>rm</code> 方法此时无法提供比 <code>os.remove</code> 方法更多的相关功能，但我们可以在这里添加更多的功能，使我们的基础代码逐步改善。</p>
<p>让我们写一个传统的测试用例，即，没有使用 <code>mock</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import rm</span><br><span class="line"></span><br><span class="line">import os.path</span><br><span class="line">import tempfile</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RmTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    tmpfilepath &#x3D; os.path.join(tempfile.gettempdir(), &quot;tmp-testfile&quot;)</span><br><span class="line"></span><br><span class="line">    def setUp(self):</span><br><span class="line">        with open(self.tmpfilepath, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(&quot;Delete me!&quot;)</span><br><span class="line"></span><br><span class="line">    def test_rm(self):</span><br><span class="line">        </span><br><span class="line">        rm(self.tmpfilepath)</span><br><span class="line">        </span><br><span class="line">        self.assertFalse(os.path.isfile(self.tmpfilepath), &quot;Failed to remove the file.&quot;)</span><br></pre></td></tr></table></figure>

<p>我们的测试用例相当简单，但是在它每次运行的时候，它都会创建一个临时文件并且随后删除。此外，我们没有办法测试我们的 <code>rm</code> 方法是否正确地将我们的参数向下传递给 <code>os.remove</code> 调用。我们可以基于以上的测试_认为_它做到了，但还有很多需要改进的地方。</p>
<h4 id="使用-Mock-重构"><a href="#使用-Mock-重构" class="headerlink" title="使用 Mock 重构"></a><a href="#使用-mock-重构"></a>使用 Mock 重构</h4><p>让我们使用 mock 重构我们的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import rm</span><br><span class="line"></span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RmTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">    def test_rm(self, mock_os):</span><br><span class="line">        rm(&quot;any path&quot;)</span><br><span class="line">        </span><br><span class="line">        mock_os.remove.assert_called_with(&quot;any path&quot;)</span><br></pre></td></tr></table></figure>

<p>使用这些重构，我们从根本上改变了测试用例的操作方式。现在，我们有一个可以用于验证其他功能的内部对象。</p>
<h5 id="潜在陷阱"><a href="#潜在陷阱" class="headerlink" title="潜在陷阱"></a><a href="#潜在陷阱"></a>潜在陷阱</h5><p>第一件需要注意的事情就是，我们使用了 <code>mock.patch</code> 方法装饰器，用于模拟位于 <code>mymodule.os</code> 的对象，并且将 mock 注入到我们的测试用例方法。那么只是模拟 <code>os</code> 本身，而不是 <code>mymodule.os</code> 下 <code>os</code> 的引用（LCTT 译注：注意 [<code>@mock.patch](mailto:%60@mock.patch)(&#39;mymodule.os&#39;)</code>便是模拟<code>mymodule.os</code>下的<code>os</code>），会不会更有意义呢？</p>
<p>当然，当涉及到导入和管理模块，Python 的用法就像蛇一样灵活。在运行时，<code>mymodule</code> 模块有它自己的被导入到本模块局部作用域的 <code>os</code>。因此，如果我们模拟 <code>os</code>，我们是看不到 mock 在 <code>mymodule</code> 模块中的模仿作用的。</p>
<p>这句话需要深刻地记住：</p>
<blockquote>
<p>模拟一个东西要看它用在何处，而不是来自哪里。</p>
</blockquote>
<p>如果你需要为 <code>myproject.app.MyElaborateClass</code> 模拟 <code>tempfile</code> 模块，你可能需要将 mock 用于 <code>myproject.app.tempfile</code>，而其他模块保持自己的导入。</p>
<p>先将那个陷阱放一边，让我们继续模拟。</p>
<h4 id="向-‘rm’-中加入验证"><a href="#向-‘rm’-中加入验证" class="headerlink" title="向 ‘rm’ 中加入验证"></a><a href="#向-rm-中加入验证"></a>向 ‘rm’ 中加入验证</h4><p>之前定义的 rm 方法相当的简单。在盲目地删除之前，我们倾向于验证一个路径是否存在，并验证其是否是一个文件。让我们重构 rm 使其变得更加智能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line">def rm(filename):</span><br><span class="line">    if os.path.isfile(filename):</span><br><span class="line">        os.remove(filename)</span><br></pre></td></tr></table></figure>

<p>很好。现在，让我们调整测试用例来保持测试的覆盖率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import rm</span><br><span class="line"></span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RmTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch(&#39;mymodule.os.path&#39;)</span><br><span class="line">    @mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">    def test_rm(self, mock_os, mock_path):</span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; False</span><br><span class="line"></span><br><span class="line">        rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.assertFalse(mock_os.remove.called, &quot;Failed to not remove the file if not present.&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; True</span><br><span class="line"></span><br><span class="line">        rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        mock_os.remove.assert_called_with(&quot;any path&quot;)</span><br></pre></td></tr></table></figure>

<p>我们的测试用例完全改变了。现在我们可以在没有任何副作用的情况下核实并验证方法的内部功能。</p>
<h4 id="将文件删除作为服务"><a href="#将文件删除作为服务" class="headerlink" title="将文件删除作为服务"></a><a href="#将文件删除作为服务"></a>将文件删除作为服务</h4><p>到目前为止，我们只是将 mock 应用在函数上，并没应用在需要传递参数的对象和实例的方法上。我们现在开始涵盖对象的方法。</p>
<p>首先，我们将 <code>rm</code> 方法重构成一个服务类。实际上将这样一个简单的函数转换成一个对象，在本质上这不是一个合理的需求，但它能够帮助我们了解 <code>mock</code> 的关键概念。让我们开始重构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line">class RemovalService(object):</span><br><span class="line">    &quot;&quot;&quot;A service for removing objects from the filesystem.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def rm(filename):</span><br><span class="line">        if os.path.isfile(filename):</span><br><span class="line">            os.remove(filename)</span><br></pre></td></tr></table></figure>

<p>你会注意到我们的测试用例没有太大变化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import RemovalService</span><br><span class="line"></span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RemovalServiceTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch(&#39;mymodule.os.path&#39;)</span><br><span class="line">    @mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">    def test_rm(self, mock_os, mock_path):</span><br><span class="line">        </span><br><span class="line">        reference &#x3D; RemovalService()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; False</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.assertFalse(mock_os.remove.called, &quot;Failed to not remove the file if not present.&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; True</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        mock_os.remove.assert_called_with(&quot;any path&quot;)</span><br></pre></td></tr></table></figure>

<p>很好，我们知道 <code>RemovalService</code> 会如预期般的工作。接下来让我们创建另一个服务，将 <code>RemovalService</code> 声明为它的一个依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line">class RemovalService(object):</span><br><span class="line">    &quot;&quot;&quot;A service for removing objects from the filesystem.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def rm(self, filename):</span><br><span class="line">        if os.path.isfile(filename):</span><br><span class="line">            os.remove(filename)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UploadService(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, removal_service):</span><br><span class="line">        self.removal_service &#x3D; removal_service</span><br><span class="line"></span><br><span class="line">    def upload_complete(self, filename):</span><br><span class="line">        self.removal_service.rm(filename)</span><br></pre></td></tr></table></figure>

<p>因为我们的测试覆盖了 <code>RemovalService</code>，因此我们不会对我们测试用例中 <code>UploadService</code> 的内部函数 <code>rm</code> 进行验证。相反，我们将调用 <code>UploadService</code> 的 <code>RemovalService.rm</code> 方法来进行简单测试（当然没有其他副作用），我们通过之前的测试用例便能知道它可以正确地工作。</p>
<p>这里有两种方法来实现测试：</p>
<ol>
<li>模拟 RemovalService.rm 方法本身。</li>
<li>在 UploadService 的构造函数中提供一个模拟实例。</li>
</ol>
<p>因为这两种方法都是单元测试中非常重要的方法，所以我们将同时对这两种方法进行回顾。</p>
<h5 id="方法-1：模拟实例的方法"><a href="#方法-1：模拟实例的方法" class="headerlink" title="方法 1：模拟实例的方法"></a><a href="#方法-1模拟实例的方法"></a>方法 1：模拟实例的方法</h5><p><code>mock</code> 库有一个特殊的方法装饰器，可以模拟对象实例的方法和属性，即 [<code>@mock.patch.object](mailto:%60@mock.patch.object) decorator</code> 装饰器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import RemovalService, UploadService</span><br><span class="line"></span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RemovalServiceTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch(&#39;mymodule.os.path&#39;)</span><br><span class="line">    @mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">    def test_rm(self, mock_os, mock_path):</span><br><span class="line">        </span><br><span class="line">        reference &#x3D; RemovalService()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; False</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.assertFalse(mock_os.remove.called, &quot;Failed to not remove the file if not present.&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; True</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        mock_os.remove.assert_called_with(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UploadServiceTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch.object(RemovalService, &#39;rm&#39;)</span><br><span class="line">    def test_upload_complete(self, mock_rm):</span><br><span class="line">        </span><br><span class="line">        removal_service &#x3D; RemovalService()</span><br><span class="line">        reference &#x3D; UploadService(removal_service)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        reference.upload_complete(&quot;my uploaded file&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_rm.assert_called_with(&quot;my uploaded file&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        removal_service.rm.assert_called_with(&quot;my uploaded file&quot;)</span><br></pre></td></tr></table></figure>

<p>非常棒！我们验证了 <code>UploadService</code> 成功调用了我们实例的 <code>rm</code> 方法。你是否注意到一些有趣的地方？这种修补机制（patching mechanism）实际上替换了我们测试用例中的所有 <code>RemovalService</code> 实例的 <code>rm</code> 方法。这意味着我们可以检查实例本身。如果你想要了解更多，可以试着在你模拟的代码下断点，以对这种修补机制的原理获得更好的认识。</p>
<h5 id="陷阱：装饰顺序"><a href="#陷阱：装饰顺序" class="headerlink" title="陷阱：装饰顺序"></a><a href="#陷阱装饰顺序"></a>陷阱：装饰顺序</h5><p>当我们在测试方法中使用多个装饰器，其顺序是很重要的，并且很容易混乱。基本上，当装饰器被映射到方法参数时，<a href="http://www.voidspace.org.uk/python/mock/patch.html#nesting-patch-decorators" target="_blank" rel="external nofollow noopener noreferrer">装饰器的工作顺序是反向的</a>。思考这个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@mock.patch(&#39;mymodule.sys&#39;)</span><br><span class="line">@mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">@mock.patch(&#39;mymodule.os.path&#39;)</span><br><span class="line">def test_something(self, mock_os_path, mock_os, mock_sys):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>注意到我们的参数和装饰器的顺序是反向匹配了吗？这部分是由 <a href="http://docs.python.org/2/reference/compound_stmts.html#function-definitions" target="_blank" rel="external nofollow noopener noreferrer">Python 的工作方式</a>所导致的。这里是使用多个装饰器的情况下它们执行顺序的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch_sys(patch_os(patch_os_path(test_something)))</span><br></pre></td></tr></table></figure>

<p>因为 <code>sys</code> 补丁位于最外层，所以它最晚执行，使得它成为实际测试方法参数的最后一个参数。请特别注意这一点，并且在运行你的测试用例时，使用调试器来保证正确的参数以正确的顺序注入。</p>
<h5 id="方法-2：创建-Mock-实例"><a href="#方法-2：创建-Mock-实例" class="headerlink" title="方法 2：创建 Mock 实例"></a><a href="#方法-2创建-mock-实例"></a>方法 2：创建 Mock 实例</h5><p>我们可以使用构造函数为 <code>UploadService</code> 提供一个 Mock 实例，而不是模拟特定的实例方法。我更推荐方法 1，因为它更加精确，但在多数情况，方法 2 或许更加有效和必要。让我们再次重构测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from mymodule import RemovalService, UploadService</span><br><span class="line"></span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class RemovalServiceTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch(&#39;mymodule.os.path&#39;)</span><br><span class="line">    @mock.patch(&#39;mymodule.os&#39;)</span><br><span class="line">    def test_rm(self, mock_os, mock_path):</span><br><span class="line">        </span><br><span class="line">        reference &#x3D; RemovalService()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; False</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.assertFalse(mock_os.remove.called, &quot;Failed to not remove the file if not present.&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_path.isfile.return_value &#x3D; True</span><br><span class="line"></span><br><span class="line">        reference.rm(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line">        mock_os.remove.assert_called_with(&quot;any path&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UploadServiceTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_upload_complete(self, mock_rm):</span><br><span class="line">        </span><br><span class="line">        mock_removal_service &#x3D; mock.create_autospec(RemovalService)</span><br><span class="line">        reference &#x3D; UploadService(mock_removal_service)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        reference.upload_complete(&quot;my uploaded file&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_removal_service.rm.assert_called_with(&quot;my uploaded file&quot;)</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们甚至不需要修补任何功能，只需为 <code>RemovalService</code> 类创建一个 auto-spec，然后将实例注入到我们的 <code>UploadService</code> 以验证功能。</p>
<p><code>mock.create_autospec</code> 方法为类提供了一个同等功能实例。实际上来说，这意味着在使用返回的实例进行交互的时候，如果使用了非法的方式将会引发异常。更具体地说，如果一个方法被调用时的参数数目不正确，将引发一个异常。这对于重构来说是非常重要。当一个库发生变化的时候，中断测试正是所期望的。如果不使用 auto-spec，尽管底层的实现已经被破坏，我们的测试仍然会通过。</p>
<h5 id="陷阱：mock-Mock-和-mock-MagicMock-类"><a href="#陷阱：mock-Mock-和-mock-MagicMock-类" class="headerlink" title="陷阱：mock.Mock 和 mock.MagicMock 类"></a><a href="#陷阱mockmock-和-mockmagicmock-类"></a>陷阱：mock.Mock 和 mock.MagicMock 类</h5><p><code>mock</code> 库包含了两个重要的类 <a href="http://www.voidspace.org.uk/python/mock/mock.html" target="_blank" rel="external nofollow noopener noreferrer">mock.Mock</a> 和 <a href="http://www.voidspace.org.uk/python/mock/magicmock.html#magic-mock" target="_blank" rel="external nofollow noopener noreferrer">mock.MagicMock</a>，大多数内部函数都是建立在这两个类之上的。当在选择使用 <code>mock.Mock</code> 实例、<code>mock.MagicMock</code> 实例还是 auto-spec 的时候，通常倾向于选择使用 auto-spec，因为对于未来的变化，它更能保持测试的健全。这是因为 <code>mock.Mock</code> 和 <code>mock.MagicMock</code> 会无视底层的 API，接受所有的方法调用和属性赋值。比如下面这个用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Target(object):</span><br><span class="line">    def apply(value):</span><br><span class="line">        return value</span><br><span class="line"></span><br><span class="line">def method(target, value):</span><br><span class="line">    return target.apply(value)</span><br></pre></td></tr></table></figure>

<p>我们可以像下面这样使用 mock.Mock 实例进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MethodTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    def test_method(self):</span><br><span class="line">        target &#x3D; mock.Mock()</span><br><span class="line"></span><br><span class="line">        method(target, &quot;value&quot;)</span><br><span class="line"></span><br><span class="line">        target.apply.assert_called_with(&quot;value&quot;)</span><br></pre></td></tr></table></figure>

<p>这个逻辑看似合理，但如果我们修改 <code>Target.apply</code> 方法接受更多参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Target(object):</span><br><span class="line">    def apply(value, are_you_sure):</span><br><span class="line">        if are_you_sure:</span><br><span class="line">            return value</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br></pre></td></tr></table></figure>

<p>重新运行你的测试，你会发现它仍能通过。这是因为它不是针对你的 API 创建的。这就是为什么你总是应该使用 <code>create_autospec</code> 方法，并且在使用 <code>@patch</code>和 [<code>@patch.object](mailto:%60@patch.object)</code>装饰方法时使用<code>autospec</code> 参数。</p>
<h3 id="现实例子：模拟-Facebook-API-调用"><a href="#现实例子：模拟-Facebook-API-调用" class="headerlink" title="现实例子：模拟 Facebook API 调用"></a><a href="#现实例子模拟-facebook-api-调用"></a>现实例子：模拟 Facebook API 调用</h3><p>作为这篇文章的结束，我们写一个更加适用的现实例子，一个在介绍中提及的功能：发布消息到 Facebook。我将写一个不错的包装类及其对应的测试用例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import facebook</span><br><span class="line"></span><br><span class="line">class SimpleFacebook(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, oauth_token):</span><br><span class="line">        self.graph &#x3D; facebook.GraphAPI(oauth_token)</span><br><span class="line"></span><br><span class="line">    def post_message(self, message):</span><br><span class="line">        &quot;&quot;&quot;Posts a message to the Facebook wall.&quot;&quot;&quot;</span><br><span class="line">        self.graph.put_object(&quot;me&quot;, &quot;feed&quot;, message&#x3D;message)</span><br></pre></td></tr></table></figure>

<p>这是我们的测试用例，它可以检查我们发布的消息, 而不是真正地发布消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import facebook</span><br><span class="line">import simple_facebook</span><br><span class="line">import mock</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">class SimpleFacebookTestCase(unittest.TestCase):</span><br><span class="line"></span><br><span class="line">    @mock.patch.object(facebook.GraphAPI, &#39;put_object&#39;, autospec&#x3D;True)</span><br><span class="line">    def test_post_message(self, mock_put_object):</span><br><span class="line">        sf &#x3D; simple_facebook.SimpleFacebook(&quot;fake oauth token&quot;)</span><br><span class="line">        sf.post_message(&quot;Hello World!&quot;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        mock_put_object.assert_called_with(message&#x3D;&quot;Hello World!&quot;)</span><br></pre></td></tr></table></figure>

<p>正如我们所看到的，在 Python 中，通过 mock，我们可以非常容易地动手写一个更加智能的测试用例。</p>
<h3 id="Python-Mock-总结"><a href="#Python-Mock-总结" class="headerlink" title="Python Mock 总结"></a><a href="#python-mock-总结"></a>Python Mock 总结</h3><p>即使对它的使用还有点不太熟悉，对<a href="http://www.toptal.com/qa/how-to-write-testable-code-and-why-it-matters" target="_blank" rel="external nofollow noopener noreferrer">单元测试</a>来说，Python 的 <code>mock</code> 库可以说是一个规则改变者。我们已经演示了常见的用例来了解了 <code>mock</code> 在单元测试中的使用，希望这篇文章能够帮助 <a href="http://www.toptal.com/python" target="_blank" rel="external nofollow noopener noreferrer">Python 开发者</a>克服初期的障碍，写出优秀、经受过考验的代码。</p>
<p>via: <a href="https://www.toptal.com/python/an-introduction-to-mocking-in-python" target="_blank" rel="external nofollow noopener noreferrer">https://www.toptal.com/python/an-introduction-to-mocking-in-python</a></p>
<p>作者：<a href="http://www.slviki.com/" target="_blank" rel="external nofollow noopener noreferrer">NAFTULI TZVI KAY</a> 译者：<a href="https://github.com/cposture" target="_blank" rel="external nofollow noopener noreferrer">cposture</a> 校对：<a href="https://github.com/wxy" target="_blank" rel="external nofollow noopener noreferrer">wxy</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="external nofollow noopener noreferrer">LCTT</a> 原创翻译，<a href="https://linux.cn/" target="_blank" rel="external nofollow noopener noreferrer">Linux 中国</a> 荣誉推出</p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>google和github的搜索技巧</title>
    <url>/posts/ce9335e0/</url>
    <content><![CDATA[<blockquote>
<p>比较简单且直接的搜索方式就是敲上几个关键词，然后回车，等待搜索引擎的反馈</p>
<p>但是这样的搜索是比较低效且浪费搜索引擎的强大功能的，为了不辜负google和github的好意，</p>
<p>我们需要了解并使用高阶点的搜索技巧。</p>
</blockquote>
<a id="more"></a>
<h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p>google的搜索技巧不太复杂，可能是因为本来结果就已经足够的好，但是有时候我们需要更<code>精确</code>或者<code>特殊</code>的结果，所以来看看吧</p>
<blockquote>
<p>baidu的搜索技巧基本和google一样，个人觉得没什么不好，起码可以节省学习成本(手动滑稽)</p>
</blockquote>
<blockquote>
<p>运算符后不要带空格</p>
</blockquote>
<ol>
<li><p>善用标签栏，比如切换到图片，只看最近一个月的结果等</p>
</li>
<li><p>其实我们可以使用google搜索来代替自建站内搜索，只需要使用<code>site:vissssa.club  xxx</code>即可，他只会显示该网站的结果，比较适用于搜索github或者stackoverflow等网站</p>
</li>
<li><p>精确匹配，使用<code>&quot;flask python&quot;</code>，可以确保flask出现在python之前，去掉空格则会只展示<code>flaskpython</code>的结果</p>
</li>
<li><p>数字区间<code>20..30</code>之间的所有数字</p>
</li>
<li><p>相关网站<code>related:v2ex.com</code></p>
</li>
<li><p><strong>重要且强大的功能</strong>，google会自带缓存，使用<code>cache:{url}</code>可以查看该页面的缓存，当遇到搜索结果404的时候，可以使用该<code>终结技</code>来试试，有可能能有意外收获</p>
</li>
<li><p>合理利用<code>与/或</code>，默认是使用的<code>与</code>，但当我们需要<code>或</code>时，只需要在关键词中间加上<code>张宇 OR 张学友</code>(大写)即可</p>
</li>
<li><p><code>+ - ~</code>有的时候，google会选择性的忽略一些单词，比如“and”、“the，”、“where”、“how”、“what”、“or”等，这时候我们可以使用<code>+how</code>来强调这个单词是我需要的，有时候，我们需要忽略某个结果，使用<code>apple -mobile</code>来过滤掉苹果手机，还有时候，我们需要获取某个单词的近义词<code>~elderly</code>，所得到的页面就会不仅是包括“elderly”这个词，还会有包括“senior”、“older”、“aged”等等词的页面，对了可以使用组合技<code>~elderly -elderly</code>来排除掉你已经知道的结果，只获取近义词</p>
</li>
<li><p>一个运算符列表（<strong>注意</strong>：把all去掉，即<code>allinanchor</code> –&gt; <code>inanchor</code>就是单关键词搜索）</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left"><strong>用途</strong></th>
<th align="left"><strong>用法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">allinanchor</td>
<td align="left">限制搜索的词语是网页中链接内包含的关键词（可使用多个关键词）</td>
<td align="left">allinanchor:keyword1 keyword2</td>
</tr>
<tr>
<td align="left">allintext</td>
<td align="left">限制搜索的词语是网页内文包含的关键词（可使用多个关键词）</td>
<td align="left">allintext:keyword1 keyword2</td>
</tr>
<tr>
<td align="left">allintitle</td>
<td align="left">限制搜索的词语是网页标题中包含的关键词（可使用多个关键词）</td>
<td align="left">allintitle:keyword1 keyword2</td>
</tr>
<tr>
<td align="left">allinurl</td>
<td align="left">限制搜索的词语是网页网址中包含的关键词（可使用多个关键词）</td>
<td align="left">allinurl:keyword1 keyword2</td>
</tr>
<tr>
<td align="left">filetype</td>
<td align="left">限制所搜索的文件一个特定的格式</td>
<td align="left">filetype:pdf</td>
</tr>
<tr>
<td align="left">site</td>
<td align="left">限制所进行的搜索在指定的域名或网站内</td>
<td align="left">site:domain</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><blockquote>
<p>github的搜索相对比较复杂，因为涉及到一些运算对象的变化，比如几大范围(title, description, readme等)，和一些stars、趋势的指标，但是能更方便筛选出你需要的repo</p>
</blockquote>
<blockquote>
<p>官方文档在<a href="https://help.github.com/cn/github/searching-for-information-on-github" target="_blank" rel="external nofollow noopener noreferrer">https://help.github.com/cn/github/searching-for-information-on-github</a></p>
<p>这里我主要记录一些比较常用的方法</p>
</blockquote>
<ol>
<li><p><strong>关键词搜索</strong>， 通过repo_name、description、readme来精确筛选，比如在description中搜索微服务回避其他的更好，语法为<code>in:description</code></p>
</li>
<li><p>搜索repo的一些限定符，用法均为<code>user:vissssa</code></p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>user:USERNAME</td>
<td><a href="https://github.com/search?q=user%3Adefunkt+forks%3A>%3D100&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>user:defunkt forks:&gt;100</strong></a> 匹配来自 @defunkt、拥有超过 100 复刻的仓库。</td>
</tr>
<tr>
<td>org:ORGNAME</td>
<td><a href="https://github.com/search?utf8=✓&q=org%3Agithub&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>org:github</strong></a> 匹配来自 GitHub 的仓库。</td>
</tr>
<tr>
<td>followers:<em>n</em></td>
<td><a href="https://github.com/search?q=node+followers%3A>%3D10000" target="_blank" rel="external nofollow noopener noreferrer"><strong>node followers:&gt;=10000</strong></a> 匹配拥有 10,000 或更多关注者并且提及 “node” 一词的仓库。<br><a href="https://github.com/search?q=styleguide+linter+followers%3A1..10&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>styleguide linter followers:1..10</strong></a> 匹配拥有 1 到 10 个关注者并且提及 “styleguide linter” 一词的的仓库。</td>
</tr>
<tr>
<td>forks:<em>n</em></td>
<td><a href="https://github.com/search?q=forks%3A>%3D205&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>forks:&gt;=205</strong></a> 匹配具有至少 205 个fork的仓库。</td>
</tr>
<tr>
<td>stars:<em>n</em></td>
<td><a href="https://github.com/search?q=stars%3A10..20+size%3A<1000&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>stars:10..20</strong></a> 匹配具有 10 到 20 个星号 的仓库。</td>
</tr>
<tr>
<td>created:<em>YYYY-MM-DD</em></td>
<td><a href="https://github.com/search?q=webos+created%3A<2011-01-01&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>webos created:&lt;2011-01-01</strong></a> 匹配具有 “webos” 字样、在 2011 年之前创建的仓库。</td>
</tr>
<tr>
<td>pushed:<em>YYYY-MM-DD</em></td>
<td><a href="https://github.com/search?utf8=✓&q=css+pushed%3A>2013-02-01&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>css pushed:&gt;2013-02-01</strong></a> 匹配具有 “css” 字样、在 2013 年 1 月之后收到推送的仓库。</td>
</tr>
<tr>
<td>language:<em>LANGUAGE</em></td>
<td><a href="https://github.com/search?q=rails+language%3Ajavascript&type=Repositories" target="_blank" rel="external nofollow noopener noreferrer"><strong>rails language:javascript</strong></a> 匹配具有 “rails” 字样、以 JavaScript 编写的仓库。</td>
</tr>
</tbody></table>
</li>
<li><p>还可以根据issue、pr、commit和主题(topic)来搜索，但是比较少见，就不提了</p>
</li>
<li><p>在代码中搜索</p>
<table>
<thead>
<tr>
<th>限定符</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>in:file</td>
<td><a href="https://github.com/search?q=octocat+in%3Afile&type=Code" target="_blank" rel="external nofollow noopener noreferrer"><strong>octocat in:file</strong></a> 匹配文件内容中出现 “octocat” 的代码。</td>
</tr>
<tr>
<td>in:path</td>
<td><a href="https://github.com/search?q=octocat+in%3Apath&type=Code" target="_blank" rel="external nofollow noopener noreferrer"><strong>octocat in:path</strong></a> 匹配文件路径中出现 “octocat” 的代码。<br><a href="https://github.com/search?q=octocat+in%3Afile%2Cpath&type=Code" target="_blank" rel="external nofollow noopener noreferrer"><strong>octocat in:file,path</strong></a> 匹配文件内容或文件路径中出现 “octocat” 的代码。</td>
</tr>
<tr>
<td>path:<em>PATH/TO/DIRECTORY</em></td>
<td><a href="https://github.com/search?q=console+path%3A" target="_blank" rel="external nofollow noopener noreferrer" app%2fpublic"+language%3ajavascript&type="Code" "><strong>console path:app/public</strong></a>匹配目录中的代码</td>
</tr>
<tr>
<td>language:<em>LANGUAGE</em></td>
<td><a href="https://github.com/search?q=display+language%3Ascss&type=Code" target="_blank" rel="external nofollow noopener noreferrer"><strong>display language:scss</strong></a> 匹配标记为 SCSS 且含有 “display” 字样的代码。</td>
</tr>
<tr>
<td>filename:<em>FILENAME</em></td>
<td><a href="https://github.com/search?utf8=✓&q=filename%3Alinguist&type=Code" target="_blank" rel="external nofollow noopener noreferrer"><strong>filename:linguist</strong></a> 匹配名为 “linguist” 的文件。</td>
</tr>
<tr>
<td>extension:<em>EXTENSION</em></td>
<td>extension:txt匹配文件扩展名</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>搜索技巧</category>
      </categories>
      <tags>
        <tag>deep</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask浅析-信号和Hook</title>
    <url>/posts/a287ede/</url>
    <content><![CDATA[<h5 id="Flask浅析系列"><a href="#Flask浅析系列" class="headerlink" title="Flask浅析系列"></a>Flask浅析系列</h5><a href="/posts/2662e6b2/" title="Flask浅析-request上下文">Flask浅析-request上下文</a><br>
<a href="/posts/a287ede/" title="Flask浅析-信号和Hook">Flask浅析-信号和Hook</a><br>
<hr>
<p>由于翻看源码时看到flask根目录下有个<code>signals.py</code>文件，且部分代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> blinker <span class="keyword">import</span> Namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># The namespace for code signals.  If you are not Flask code, do</span></span><br><span class="line"><span class="comment"># not put signals in here.  Create your own namespace instead.</span></span><br><span class="line">_signals = Namespace()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Core signals.  For usage examples grep the source code or consult</span></span><br><span class="line"><span class="comment"># the API documentation in docs/api.rst as well as docs/signals.rst</span></span><br><span class="line">request_started = _signals.signal(<span class="string">"request-started"</span>)</span><br><span class="line">request_finished = _signals.signal(<span class="string">"request-finished"</span>)</span><br><span class="line">request_tearing_down = _signals.signal(<span class="string">"request-tearing-down"</span>)</span><br></pre></td></tr></table></figure>

<p>故而自然而然的以为我们常用的<code>@app.before_request</code>就是通过信号(signal)来触发的，但是顺手全局搜索了<code>request_started.connect()</code>，却没有发现代码，所以只能点开<code>@app.before_request</code>一探究竟</p>
<p><code>app</code>是<code>Flask</code>的实例，所以<code>before_request</code>是这个类的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flask</span>:</span></span><br><span class="line">    self.before_request_funcs = &#123;&#125;</span><br><span class="line"><span class="meta">    @setupmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">before_request</span><span class="params">(self, f)</span>:</span></span><br><span class="line">        <span class="string">"""Registers a function to run before each request.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        For example, this can be used to open a database connection, or to load</span></span><br><span class="line"><span class="string">        the logged in user from the session.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The function will be called without any arguments. If it returns a</span></span><br><span class="line"><span class="string">        non-None value, the value is handled as if it was the return value from</span></span><br><span class="line"><span class="string">        the view, and further request handling is stopped.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.before_request_funcs.setdefault(<span class="literal">None</span>, []).append(f)</span><br><span class="line">        <span class="keyword">return</span> f</span><br></pre></td></tr></table></figure>

<p>这里的<code>@setupmethod</code>起到了监测debug模式下会重复启动两次会出现的一些错误，按下不表。</p>
<p>这个函数主要是把被装饰的函数放到一个函数字典中，key是None，value是一组被装饰的函数</p>
<p>例如我的项目中，启动的时候会调用<code>create_app</code>函数，中间有个<code>middleware</code>文件，中间就写了一批被装饰的函数，这样就全放到了这个字典中。</p>
<p>此时项目启动时就已经把需要运行的函数注册进来了，正式进入一个http请求流程，<code>werkzeug</code>作为<code>flask</code>的基础web服务组件，接收到一个请求时，会调用<code>app(environ, start_response)</code>来掉起flask中的 <code>wsgi_app</code> (使用的是Flask类的<code>__call__</code>魔术方法)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wsgi_app</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    ctx = self.request_context(environ)</span><br><span class="line">    error = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ctx.push()</span><br><span class="line">            response = self.full_dispatch_request()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            error = e</span><br><span class="line">            response = self.handle_exception(e)</span><br><span class="line">        <span class="keyword">except</span>:  <span class="comment"># noqa: B001</span></span><br><span class="line">            error = sys.exc_info()[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        <span class="keyword">return</span> response(environ, start_response)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> self.should_ignore_error(error):</span><br><span class="line">            error = <span class="literal">None</span></span><br><span class="line">        ctx.auto_pop(error)</span><br></pre></td></tr></table></figure>

<p>这里主要是关于上下文堆栈出栈和错误处理的代码，主要在<code>full_dispatch_request</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">full_dispatch_request</span><span class="params">(self)</span>:</span></span><br><span class="line">     self.try_trigger_before_first_request_functions()</span><br><span class="line">     <span class="keyword">try</span>:</span><br><span class="line">         request_started.send(self)</span><br><span class="line">         rv = self.preprocess_request()</span><br><span class="line">         <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">             rv = self.dispatch_request()</span><br><span class="line">     <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">         rv = self.handle_user_exception(e)</span><br><span class="line">     <span class="keyword">return</span> self.finalize_request(rv)</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preprocess_request</span><span class="params">(self)</span>:</span></span><br><span class="line">     bp = _request_ctx_stack.top.request.blueprint</span><br><span class="line"></span><br><span class="line">     funcs = self.url_value_preprocessors.get(<span class="literal">None</span>, ())</span><br><span class="line">     <span class="keyword">if</span> bp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> bp <span class="keyword">in</span> self.url_value_preprocessors:</span><br><span class="line">         funcs = chain(funcs, self.url_value_preprocessors[bp])</span><br><span class="line">     <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">         func(request.endpoint, request.view_args)</span><br><span class="line"></span><br><span class="line">     funcs = self.before_request_funcs.get(<span class="literal">None</span>, ())</span><br><span class="line">     <span class="keyword">if</span> bp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> bp <span class="keyword">in</span> self.before_request_funcs:</span><br><span class="line">         funcs = chain(funcs, self.before_request_funcs[bp])</span><br><span class="line">     <span class="keyword">for</span> func <span class="keyword">in</span> funcs:</span><br><span class="line">         rv = func()</span><br><span class="line">         <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">             <span class="keyword">return</span> rv</span><br></pre></td></tr></table></figure>

<p>从这能看到先执行的信号，再执行被装饰的hook函数，所以如果需要某些先于hook触发的函数，不妨使用signals来注册。</p>
<p>最后有flask的特性，当hook函数中有返回值时，直接返回该返回值，不去触发接下来的所有函数，包括之后的路由寻址。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finalize_request</span><span class="params">(self, rv, from_error_handler=False)</span>:</span></span><br><span class="line">    response = self.make_response(rv)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = self.process_response(response)</span><br><span class="line">        request_finished.send(self, response=response)</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> from_error_handler:</span><br><span class="line">            <span class="keyword">raise</span></span><br><span class="line">        self.logger.exception(</span><br><span class="line">            <span class="string">"Request finalizing failed with an error while handling an error"</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>与之前相反，response的信号顺序则慢于hook触发，颇有些类似django的middleware的触发顺序</p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>deep</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>python复习笔记</title>
    <url>/posts/b8ccf74b/</url>
    <content><![CDATA[<h3 id="函数的参数传递"><a href="#函数的参数传递" class="headerlink" title="函数的参数传递"></a>函数的参数传递</h3><p>是值传递，只不过(string,tuples,num)不可变，所以函数产生一个新的副本，(dict,list,set)可变，所以会被直接修改</p>
<h3 id="cls-vs-self"><a href="#cls-vs-self" class="headerlink" title="cls vs self"></a>cls vs self</h3><p><code>cls</code>是类方法的关键字,<code>self</code>是实例方法的关键字，顾名思义，self用在每个建立的实例中，cls可用在所有该类中(包括实例)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    public = <span class="string">'123'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.private = <span class="string">'321'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cls_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.public</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self_foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.private</span><br></pre></td></tr></table></figure>

<h3 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h3><p>简单来说就是元类创建类，类创建实例，不常用到，但是oop(面向对象程序设计)中会用到，一个常见的例子就是ORM</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> library.api.db <span class="keyword">import</span> EntityModel, db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span><span class="params">(EntityModel)</span>:</span></span><br><span class="line">    module = db.Column(db.String(<span class="number">100</span>))  <span class="comment"># 模块</span></span><br><span class="line">    module_type = db.Column(db.Integer)  <span class="comment"># 模块的类型</span></span><br><span class="line">    content = db.Column(db.Text)  <span class="comment"># 内容</span></span><br><span class="line">    description = db.Column(db.Text)  <span class="comment"># 描述</span></span><br><span class="line">    projectid = db.Column(db.Integer)  <span class="comment"># 项目id</span></span><br></pre></td></tr></table></figure>

<p>这里的Config类本身没有任何函数，但是我们可以使用它来CRUD</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c = Config(module=<span class="string">'test'</span>, content=<span class="string">'test'</span>)</span><br><span class="line">c.save()</span><br></pre></td></tr></table></figure>

<h3 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h3><p>迭代器就是<code>iterable</code>可迭代，生成器是<code>generator</code>关键词是<code>yield</code>，处理大量数据用生成器，需要下标的使用迭代器。</p>
<p><code>itertools</code>这个库很有用</p>
<h3 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h3><p>python一个利器，比如file-like，那么stringio,file,socket都当成文件一样来使用，list.extend()后面跟的参数只要是可迭代的即可，无论是string还是list，甚至是dict都可以</p>
<p>所以python没有很多设计模式。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载是为了解决两个问题：</p>
<ol>
<li>可变参数类型</li>
<li>可变参数个数</li>
</ol>
<p>在python中并不存在这两个问题，所以不需要函数重载</p>
<h3 id="新式类和经典类"><a href="#新式类和经典类" class="headerlink" title="新式类和经典类"></a>新式类和经典类</h3><p>python3中只有新式类，简要来说区别是经典类继承是从左到右深度优先，查到底的那种，新式类则是C3算法，广度优先</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p><a href="http://wbice.cn/article/coroutine.html#gevent" target="_blank" rel="external nofollow noopener noreferrer">http://wbice.cn/article/coroutine.html#gevent</a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>什么叫做闭包：</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数<br>常用作装饰器，比较类似于一个类，有一个自由变量</li>
</ol>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>《SQL必知必会》笔记</title>
    <url>/posts/8212f7ec/</url>
    <content><![CDATA[<h3 id="SQL功能"><a href="#SQL功能" class="headerlink" title="SQL功能"></a>SQL功能</h3><ul>
<li>DDL，Data Definition Language，数据定义语言，创建、删除和修改数据库和表</li>
<li>DML，Data Manipulation Language，数据操作语言，增加、删除和修改表中数据</li>
<li>DCL，Data Control Language，数据控制语言，定义访问权限和安全级别</li>
<li>DQL，Data Query Language，数据查询语言，顾名思义</li>
</ul>
<h3 id="SQL执行过程"><a href="#SQL执行过程" class="headerlink" title="SQL执行过程"></a>SQL执行过程</h3><h4 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h4><p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/oracle01.png"></p>
<p>语法就是SQL的拼写，语义则是分析操作对象是否存在</p>
<p><strong>共享池检查</strong>就是维护一个内存池，缓存SQL语句和执行计划，每次通过计算SQL语句的Hash值去缓存池查询，若有则<code>软解析</code>，若无则<code>硬解析</code></p>
<p>硬解析就是重新建立解析树和执行计划，软解析就是使用已有的解析树和执行计划，所以效率方面不可同日而语</p>
<p><strong>ps</strong>: 上述缓存的内容被称为库缓存，可以决定是硬解析和软解析，它还存在一个数据字典缓冲区，存储对象定义，如表、视图、索引，当解析SQL语句时会从中提取数据。</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/mysql01.jpg"></p>
<p>基本与Oracle相同，除了没有共享池，多了个缓存查询(8.0版本后去除了)。</p>
<p>非常不同的是MySQL使用的是C/S架构，分层设计</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/mysql02.png"></p>
<p>上述流程属于SQL层，存储层可以以插件的形式选择引擎，常用的是<code>InnoDB</code>和<code>MyISAM</code>，区别就是前者支持事务、行级锁、外键等，后者查询快、功能少，所以一般后者用来查询，前者用来操作。</p>
<h3 id="MySQL调试"><a href="#MySQL调试" class="headerlink" title="MySQL调试"></a>MySQL调试</h3><p>通过开启<code>profiling</code>收集信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询是否开启，为1则开启，为0则关闭</span><br><span class="line">SELECT @@profiling;</span><br><span class="line"></span><br><span class="line"># 开启</span><br><span class="line">SET profiling;</span><br><span class="line"></span><br><span class="line">SELECT * FROM user;</span><br><span class="line"></span><br><span class="line"># 展示所有profiles</span><br><span class="line">SHOW profiles;</span><br><span class="line"># 展示上一条</span><br><span class="line">SHOW profile;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>deep</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>内网穿透</title>
    <url>/posts/bd50b816/</url>
    <content><![CDATA[<p>由于开源软件 <a href="https://github.com/fatedier/frp" target="_blank" rel="external nofollow noopener noreferrer">frp</a>的存在，内网穿透变得如此简单，在此由衷感谢<del>.</del></p>
<p>我使用的需求在于我的vps配置很差，希望把家里的电脑开一个虚拟机，用来当做开发机器，给frps和frpc加上token就开始了我们开心的白嫖高配置之旅</p>
<p>首先在github上下载最新软件，对应各个系统，在vps上部署frps</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line">token = ****</span><br><span class="line">./frps -c ./frps.ini</span><br></pre></td></tr></table></figure>

<p>再在我的虚拟机上修改frpc.ini</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># frpc.ini</span></span><br><span class="line">[common]</span><br><span class="line">server_addr = x.x.x.x</span><br><span class="line">server_port = 7000</span><br><span class="line">token = ****</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">./frpc -c ./frpc.ini</span><br></pre></td></tr></table></figure>

<p>当看到输出正常的内容即可</p>
<p>连接内网机器使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -oPort=6000 &lt;内网用户名&gt;@&lt;vps.ip&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>deep</tag>
      </tags>
  </entry>
  <entry>
    <title>知识片段收录</title>
    <url>/posts/5c16325f/</url>
    <content><![CDATA[<h3 id="1、redis能否代替etcd或者zookeeper"><a href="#1、redis能否代替etcd或者zookeeper" class="headerlink" title="1、redis能否代替etcd或者zookeeper"></a>1、redis能否代替etcd或者zookeeper</h3><blockquote>
<p>源自<a href="https://www.v2ex.com/t/520367" target="_blank" rel="external nofollow noopener noreferrer">https://www.v2ex.com/t/520367</a> #3 @xkeyideal</p>
</blockquote>
<p>简单从以下几个方面说一下redis为啥在微服务中不能取代 etcd：</p>
<ol>
<li>redis 没有版本的概念，历史版本数据在大规模微服务中非常有必要，对于状态回滚和故障排查，甚至定锅都很重要</li>
<li>redis 的注册和发现目前只能通过 pub 和 sub 来实现，这两个命令完全不能满足生产环境的要求，具体原因可以 gg 或看源码实现</li>
<li>etcd 在 2.+版本时，watch 到数据官方文档均建议再 get 一次，因为会存在数据延迟，3.+版本不再需要，可想 redis 的 pub 和 sub 能否达到此种低延迟的要求</li>
<li>楼主看到的微服务架构应该都是将 etcd 直接暴露给 client 和 server 的，etcd 的性能摆在那，能够承受多少的 c/s 直连呢，更好的做法应该是对 etcd 做一层保护，当然这种做法会损失一些功能</li>
<li>redis 和 etcd 的集群实现方案是不一致的，etcd 采用的是 raft 协议，一主多从，只能写主，底层采用 boltdb 作为 k/v 存储，直接落盘</li>
<li>redis 的持久化方案有 aof 和 rdb，这两种方案在宕机的时候都或多或少的会丢失数据</li>
</ol>
<p>总结，redis从来没有想过抢 etcd 在服务注册和发现的饭碗，目前的架构来说也抢不动，在缓存方面目前在性能和功能也无出其右； etcd 只关注在服务注册与发现方面，非要当做 k/v 存储来用（丢弃 watch 特性而言）也可以用，性能也不错，但只能说你选错对象了</p>
<p>微服务架构中选择哪种技术，取决于技术决定人的规划理想，非要说 redis 不行当然也是错的，不考虑服务规模和性能需求，用 mongodb 也能搞，mongodb 3.6+版本也有个 oplog watch 的功能</p>
<h3 id="2、redis的使用场景"><a href="#2、redis的使用场景" class="headerlink" title="2、redis的使用场景"></a>2、redis的使用场景</h3><blockquote>
<p>摘自<a href="https://github.com/CyC2018/CS-Notes.git" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/CyC2018/CS-Notes.git</a> redis一栏</p>
</blockquote>
<ol>
<li>计数器：int自增自建</li>
<li>缓存：设置内存最大使用量和淘汰策略</li>
<li>查找表：DNS记录</li>
<li>消息队列：最好还是使用RabbitMQ或者Kafka</li>
<li>会话缓存：分布式session</li>
<li>分布式锁实现：SETNX或者RedLock</li>
<li>其它：set的交集并集操作实现共同好友，排行榜</li>
</ol>
<h3 id="3、redis的持久化"><a href="#3、redis的持久化" class="headerlink" title="3、redis的持久化"></a>3、redis的持久化</h3><p>redis是具有持久化功能的，但是并不完全可靠，两种持久化方法：<code>RDB</code>和<code>AOF</code></p>
<ol>
<li><p>RDB持久化：</p>
<p>将某个时间点的所有数据放到硬盘上，若数据大，时间很长，所以必须关闭该redis服务器，否则部分同步开始后的数据不会备份</p>
</li>
<li><p>AOF持久化：</p>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th align="center">选项</th>
<th align="center">同步频率</th>
</tr>
</thead>
<tbody><tr>
<td align="center">always</td>
<td align="center">每个写命令都同步</td>
</tr>
<tr>
<td align="center">everysec</td>
<td align="center">每秒同步一次</td>
</tr>
<tr>
<td align="center">no</td>
<td align="center">让操作系统来决定何时同步</td>
</tr>
</tbody></table>
<ul>
<li><p>always 选项会<strong>严重减低</strong>服务器的性能；</p>
</li>
<li><p>everysec 选项比较合适，可以保证系统崩溃时只会<strong>丢失</strong>一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</p>
</li>
<li><p>no 选项<strong>并不能</strong>给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p>
</li>
</ul>
</li>
</ol>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h3 id="4、redis的淘汰策略"><a href="#4、redis的淘汰策略" class="headerlink" title="4、redis的淘汰策略"></a>4、redis的淘汰策略</h3><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Reids 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th align="center">策略</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">volatile-lru</td>
<td align="center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-ttl</td>
<td align="center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td align="center">volatile-random</td>
<td align="center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-lru</td>
<td align="center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td align="center">allkeys-random</td>
<td align="center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td align="center">noeviction</td>
<td align="center">禁止驱逐数据</td>
</tr>
</tbody></table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h3 id="5、ipv4和ipv6"><a href="#5、ipv4和ipv6" class="headerlink" title="5、ipv4和ipv6"></a>5、ipv4和ipv6</h3><p>ipv6的好处：</p>
<ol>
<li>一个设备一个公网 IP，不需要穿透，同城毫秒级响应，PT 使用范围 /速度增加</li>
<li>可以接入教育网</li>
</ol>
<p>坏处：</p>
<ol>
<li>一个设备一个公网 IP（喝茶）</li>
<li>目前很多网站 ipv6 是单通，而且默认情况下 ipv6 优先级高，所以目前很多情况下启用 ipv6 对网络体验是负优化</li>
<li>ipv6 路由震荡得厉害，尤其出国，今天美国绕日本，明天日本绕德国，对网络体验还是负优化</li>
</ol>
<h3 id="6、软链接和硬链接"><a href="#6、软链接和硬链接" class="headerlink" title="6、软链接和硬链接"></a>6、软链接和硬链接</h3><blockquote>
<p>主要是inode的一些特点和区别，inode会记录除了文件名以外所有的文件信息，包括引用数、权限、组、用户、大小等</p>
</blockquote>
<p>1、软链接：<code>ln -s source_file des_file</code>；硬链接：<code>ln source_file des_file</code><br>2、两者不管修改什么文件，都是全部修改，但是软/硬链接删除目标文件不影响源文件，删除源文件的话，软的会无效<br>3、inode中的引用数：硬链接两个文件都会+1，软链接不会；或者说硬链接两个维护一个inode，软链接维护两个inode<br>4、硬链接不能面向目录<br>5、硬链接不能分区，软链接可以，使用案例为将日志或者别的大文件软链接到别的硬盘上</p>
<h3 id="7、mysql-为什么不推荐三张表以上的关联？"><a href="#7、mysql-为什么不推荐三张表以上的关联？" class="headerlink" title="7、mysql 为什么不推荐三张表以上的关联？"></a>7、mysql 为什么不推荐三张表以上的关联？</h3><p>好处：减少网络io</p>
<p>坏处：</p>
<p>1、不论是几个表，什么 sql，先 show index 看看索引怎么建的，再 explain 分析一波索引命中情况怎样</p>
<p>2、如果条件限制宽泛的话，三张表关联产生的笛卡儿积非常庞大，缓存机制什么的可能扛不住啊，得用 explain 来分析一下了</p>
<p>3、耦合高</p>
<p>4、数据一多，服务器直接GG</p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>ipv4/ipv6</tag>
        <tag>snippets</tag>
      </tags>
  </entry>
  <entry>
    <title>python面试</title>
    <url>/posts/e11f968c/</url>
    <content><![CDATA[<h2 id="python面试题及答案"><a href="#python面试题及答案" class="headerlink" title="python面试题及答案"></a>python面试题及答案</h2><h3 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h3><h4 id="1-Python的函数参数传递"><a href="#1-Python的函数参数传递" class="headerlink" title="1 Python的函数参数传递"></a>1 Python的函数参数传递</h4><p>看两个如下例子，分析运行结果:<br>代码一：</p>
<p>a = 1<br>def fun(a):<br>a = 2<br>fun(a)<br>print(a)  # 1</p>
<p>代码二：</p>
<p>a = []<br>def fun(a):<br>a.append(1)<br>fun(a)<br>print(a)  # [1]</p>
<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。<br>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)<br>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p>
<h4 id="2-Python中的元类-metaclass"><a href="#2-Python中的元类-metaclass" class="headerlink" title="2 Python中的元类(metaclass)"></a>2 Python中的元类(metaclass)</h4><p>元类就是用来创建类的“东西”。你创建类就是为了创建类的实例对象，但是我们已经学习到了Python中的类也是对象。好吧，元类就是用来创建这些类（对象）的，元类就是类的类<br>这个非常的不常用,详情请看：《深刻理解Python中的元类(metaclass)》</p>
<h4 id="3-staticmethod和-classmethod"><a href="#3-staticmethod和-classmethod" class="headerlink" title="3 @staticmethod和@classmethod"></a>3 @staticmethod和@classmethod</h4><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>
<p>class A(object):<br>def foo(self,x):<br>print “executing foo(%s,%s)”%(self,x)</p>
<p>@classmethod<br>def class_foo(cls,x):<br>print( “executing class_foo(%s,%s)”%(cls,x))</p>
<p>@staticmethod<br>def static_foo(x):<br>print (“executing static_foo(%s)”%x)</p>
<p>a=A()<br>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.<br>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用.<br>\    实例方法    类方法    静态方法<br>a = A()    a.foo(x)    a.class_foo(x)    a.static_foo(x)<br>A    不可用    A.class_foo(x)    A.static_foo(x)</p>
<h4 id="4-类变量和实例变量"><a href="#4-类变量和实例变量" class="headerlink" title="4 类变量和实例变量"></a>4 类变量和实例变量</h4><p>class Person:<br>name=”aaa”</p>
<p>p1=Person()<br>p2=Person()<br>p1.name=”bbb”<br>print(p1.name)  # bbb<br>print(p2.name)  # aaa<br>print(Person.name)  # aaa<br>类变量就是供类使用的变量,实例变量就是供实例使用的.<br>这里p1.name=”bbb”是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类变量name=”aaa”,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.<br>可以看看下面的例子:</p>
<p>class Person:<br>name=[]</p>
<p>p1=Person()<br>p2=Person()<br>p1.name.append(1)<br>print(p1.name)  # [1]<br>print(p2.name)  # [1]<br>print(Person.name)  # [1]</p>
<h4 id="5-Python自省"><a href="#5-Python自省" class="headerlink" title="5 Python自省"></a>5 Python自省</h4><p>这个也是python彪悍的特性.<br>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>
<h4 id="6-字典推导式"><a href="#6-字典推导式" class="headerlink" title="6 字典推导式"></a>6 字典推导式</h4><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:<br>d = {key: value for (key, value) in iterable}</p>
<h4 id="7-Python中单下划线和双下划线"><a href="#7-Python中单下划线和双下划线" class="headerlink" title="7 Python中单下划线和双下划线"></a>7 Python中单下划线和双下划线</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	&gt;&gt;&gt; class MyClass():</span><br><span class="line">2 ...     def __init__(self):</span><br><span class="line">3 ...             self.__superprivate &#x3D; &quot;Hello&quot;</span><br><span class="line">4 ...             self._semiprivate &#x3D; &quot;, world!&quot;</span><br><span class="line">5 ...</span><br><span class="line">6 &gt;&gt;&gt; mc &#x3D; MyClass()</span><br><span class="line">7 &gt;&gt;&gt; print(mc.__superprivate)</span><br><span class="line">8 Traceback (most recent call last):</span><br><span class="line">9  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">10 AttributeError: myClass instance has no attribute &#39;__superprivate&#39;</span><br><span class="line">11 &gt;&gt;&gt; print(mc._semiprivate)</span><br><span class="line">12 , world!</span><br><span class="line">13 &gt;&gt;&gt; print mc.__dict__</span><br><span class="line">14 &#123;&#39;_MyClass__superprivate&#39;: &#39;Hello&#39;, &#39;_semiprivate&#39;: &#39;, world!&#39;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>foo</strong>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.<br>-foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.<br>-foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名.<br>详情见:<br><a href="http://www.zhihu.com/question/19754941" target="_blank" rel="external nofollow noopener noreferrer">http://www.zhihu.com/question/19754941</a></p>
<h4 id="8-字符串格式化-和-format"><a href="#8-字符串格式化-和-format" class="headerlink" title="8 字符串格式化:%和.format"></a>8 字符串格式化:%和.format</h4><p>.format在许多方面看起来更便利.对于%最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:<br>Python:<br>“hi there %s” % name<br>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:<br>“hi there %s” % (name,)   # 提供一个单元素的数组而不是一个参数</p>
<h4 id="9-迭代器和生成器"><a href="#9-迭代器和生成器" class="headerlink" title="9 迭代器和生成器"></a>9 迭代器和生成器</h4><p>在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。</p>
<p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external nofollow noopener noreferrer">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p>
<h4 id="10-args-and-kwargs"><a href="#10-args-and-kwargs" class="headerlink" title="10 * args and ** kwargs"></a>10 * args and ** kwargs</h4><p>用<em>args和*</em>kwargs只是为了方便并没有强制使用它们.<br>当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	&gt;&gt;&gt; def print_everything(*args):</span><br><span class="line">2     for count, thing in enumerate(args):</span><br><span class="line">3 ...       print &#39;&#123;0&#125;. &#123;1&#125;&#39;.format(count, thing)</span><br><span class="line">4 ..</span><br><span class="line">5 &gt;&gt;&gt; print_everything(&#39;apple&#39;, &#39;banana&#39;, &#39;cabbage&#39;)</span><br><span class="line">6 0. apple</span><br><span class="line">7 1. banana</span><br><span class="line">8 2. cabbage</span><br></pre></td></tr></table></figure>
<p>相似的 ** kwargs允许你使用没有事先定义的参数名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	&gt;&gt;&gt; def table_things(**kwargs):</span><br><span class="line">2 ...     for name, value in kwargs.items():</span><br><span class="line">3 ...         print &#39;&#123;0&#125; &#x3D; &#123;1&#125;&#39;.format(name, value)</span><br><span class="line">4 ...</span><br><span class="line">5 &gt;&gt;&gt; table_things(apple &#x3D; &#39;fruit&#39;, cabbage &#x3D; &#39;vegetable&#39;)</span><br><span class="line">6 cabbage &#x3D; vegetable</span><br><span class="line">7 apple &#x3D; fruit</span><br></pre></td></tr></table></figure>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<em>args和*</em>kwargs.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	def table_things(titlestring, ** kwargs)</span><br></pre></td></tr></table></figure>
<ul>
<li>args和** kwargs可以同时在函数的定义中,但是<em>args必须在*</em>kwargs前面.<br>当调用函数时你也可以用<em>和*</em>语法.例如:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	&gt;&gt;&gt; def print_three_things(a, b, c):</span><br><span class="line">2 ...     print &#39;a &#x3D; &#123;0&#125;, b &#x3D; &#123;1&#125;, c &#x3D; &#123;2&#125;&#39;.format(a,b,c)</span><br><span class="line">3 ...</span><br><span class="line">4 &gt;&gt;&gt; mylist &#x3D; [&#39;aardvark&#39;, &#39;baboon&#39;, &#39;cat&#39;]</span><br><span class="line">5 &gt;&gt;&gt; print_three_things(*mylist)</span><br><span class="line">6</span><br><span class="line">7 a &#x3D; aardvark, b &#x3D; baboon, c &#x3D; cat</span><br></pre></td></tr></table></figure>
就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.<br><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="external nofollow noopener noreferrer">http://stackoverflow.com/questions/3394835/args-and-kwargs</a><h4 id="11-面向切面编程AOP和装饰器"><a href="#11-面向切面编程AOP和装饰器" class="headerlink" title="11 面向切面编程AOP和装饰器"></a>11 面向切面编程AOP和装饰器</h4>这个AOP一听起来有点懵,同学面试的时候就被问懵了…<br>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。<br>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="external nofollow noopener noreferrer">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a><br>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="external nofollow noopener noreferrer">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a><h4 id="12-鸭子类型"><a href="#12-鸭子类型" class="headerlink" title="12 鸭子类型"></a>12 鸭子类型</h4>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”<br>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。<br>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。<br>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.<br>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。<h4 id="13-Python中重载"><a href="#13-Python中重载" class="headerlink" title="13 Python中重载"></a>13 Python中重载</h4>引自知乎:<a href="http://www.zhihu.com/question/20053359" target="_blank" rel="external nofollow noopener noreferrer">http://www.zhihu.com/question/20053359</a><br>函数重载主要是为了解决两个问题。</li>
</ul>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。<br>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。<br>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。<br>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。<br>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。<h4 id="14-新式类和旧式类"><a href="#14-新式类和旧式类" class="headerlink" title="14 新式类和旧式类"></a>14 新式类和旧式类</h4>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.<br>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a><br>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多.<h4 id="15-new和init的区别"><a href="#15-new和init的区别" class="headerlink" title="15 new和init的区别;"></a>15 <strong>new</strong>和<strong>init</strong>的区别;</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个__new__确实很少见到,先做了解吧.</span><br><span class="line">1.	__new__是一个静态方法,而__init__是一个实例方法.</span><br><span class="line">2.	__new__方法会返回一个创建的实例,而__init__什么都不返回.</span><br><span class="line">3.	只有在__new__返回一个cls的实例时后面的__init__才能被调用.</span><br><span class="line">4.	当创建一个新实例时调用__new__,初始化一个实例时用__init__.</span><br><span class="line">ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</span><br></pre></td></tr></table></figure>
<h4 id="16-单例模式"><a href="#16-单例模式" class="headerlink" title="16 单例模式"></a>16 单例模式</h4>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.<h5 id="1-使用new方法"><a href="#1-使用new方法" class="headerlink" title="1 使用new方法"></a>1 使用<strong>new</strong>方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">def __new__(cls, *args, **kw):</span><br><span class="line">if not hasattr(cls, &#39;_instance&#39;):</span><br><span class="line">orig &#x3D; super(Singleton, cls)</span><br><span class="line">cls._instance &#x3D; orig.__new__(cls, *args, **kw)</span><br><span class="line">return cls._instance</span><br><span class="line"></span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">a &#x3D; 1</span><br></pre></td></tr></table></figure>
<h5 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h5>创建实例时把所有实例的<strong>dict</strong>指向同一个字典,这样它们具有相同的属性和方法.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	class Borg(object):</span><br><span class="line">2    _state &#x3D; &#123;&#125;</span><br><span class="line">3    def __new__(cls, *args, **kw):</span><br><span class="line">4        ob &#x3D; super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">5        ob.__dict__ &#x3D; cls._state</span><br><span class="line">6      return ob</span><br><span class="line">7</span><br><span class="line">8 class MyClass2(Borg):</span><br><span class="line">9    a &#x3D; 1</span><br></pre></td></tr></table></figure>
<h5 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1	def singleton(cls, *args, **kw):</span><br><span class="line">2    instances &#x3D; &#123;&#125;</span><br><span class="line">3  def getinstance():</span><br><span class="line">4        if cls not in instances:</span><br><span class="line">5            instances[cls] &#x3D; cls(*args, **kw)</span><br><span class="line">6        return instances[cls]</span><br><span class="line">7    return getinstance</span><br><span class="line">8</span><br><span class="line">9 @singleton</span><br><span class="line">10 class MyClass:</span><br></pre></td></tr></table></figure>
<h5 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h5>作为python的模块是天然的单例模式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysingleton.py</span><br><span class="line">class My_Singleton(object):</span><br><span class="line">def foo(self):</span><br><span class="line">pass</span><br><span class="line"></span><br><span class="line">my_singleton &#x3D; My_Singleton()</span><br><span class="line"></span><br><span class="line"># to use</span><br><span class="line">from mysingleton import my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>
<h4 id="17-Python中的作用域"><a href="#17-Python中的作用域" class="headerlink" title="17 Python中的作用域"></a>17 Python中的作用域</h4>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。<br>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：<br>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）<h4 id="18-GIL线程全局锁"><a href="#18-GIL线程全局锁" class="headerlink" title="18 GIL线程全局锁"></a>18 GIL线程全局锁</h4>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.<br>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).<h4 id="19-协程"><a href="#19-协程" class="headerlink" title="19 协程"></a>19 协程</h4>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.<br>Python里最常见的yield就是协程的思想!可以查看第九个问题.<h4 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h4>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。<br>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</li>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数<br>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.<br>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.<br>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.<h4 id="21-lambda函数"><a href="#21-lambda函数" class="headerlink" title="21 lambda函数"></a>21 lambda函数</h4>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.<h4 id="22-Python函数式编程"><a href="#22-Python函数式编程" class="headerlink" title="22 Python函数式编程"></a>22 Python函数式编程</h4>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.<br>python中函数式编程支持:<br>filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a &#x3D; [1,2,3,4,5,6,7]</span><br><span class="line">&gt;&gt;&gt;b &#x3D; filter(lambda x: x &gt; 5, a)</span><br><span class="line">&gt;&gt;&gt;print b</span><br><span class="line">&gt;&gt;&gt;[6,7]</span><br><span class="line">map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; a &#x3D; map(lambda x:x*2,[1,2,3])</span><br><span class="line">&gt;&gt;&gt; list(a)</span><br><span class="line">[2, 4, 6]</span><br><span class="line">reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h4 id="23-Python里的拷贝"><a href="#23-Python里的拷贝" class="headerlink" title="23 Python里的拷贝"></a>23 Python里的拷贝</h4>引用和copy(),deepcopy()的区别<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="24-Python垃圾回收机制"><a href="#24-Python垃圾回收机制" class="headerlink" title="24 Python垃圾回收机制"></a>24 Python垃圾回收机制</h4>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。<h5 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h5>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。<br>优点:</li>
<li>简单</li>
<li>实时性<br>缺点:</li>
<li>维护引用计数消耗资源</li>
<li>循环引用<h5 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h5>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。<h5 id="3-分代技术"><a href="#3-分代技术" class="headerlink" title="3 分代技术"></a>3 分代技术</h5>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。<br>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。<br>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。<h4 id="25-Python里面如何实现tuple和list的转换？"><a href="#25-Python里面如何实现tuple和list的转换？" class="headerlink" title="25 Python里面如何实现tuple和list的转换？"></a>25 Python里面如何实现tuple和list的转换？</h4>答：tuple，可以说是不可变的list，访问方式还是通过索引下标的方式。<br>当你明确定义个tuple是，如果仅有一个元素，必须带有,例如：(1,)。<br>当然，在2.7以后的版，python里还增加了命名式的tuple！</li>
</ol>
<p>至于有什么用，首先第一点，楼主玩过python都知道，python的函数可以有多返回值的，而python里，多返回值，就是用tuple来表示，这是用的最广的了，</p>
<p>比如说，你需要定义一个常量的列表，但你又不想使用list，那也可以是要你管tuple，例如：<br>if a in (‘A’,’B’,’C’):pass</p>
<h4 id="26-Python的is"><a href="#26-Python的is" class="headerlink" title="26 Python的is"></a>26 Python的is</h4><p>is是对比地址,==是对比值</p>
<h4 id="27-read-readline和readlines"><a href="#27-read-readline和readlines" class="headerlink" title="27 read,readline和readlines"></a>27 read,readline和readlines</h4><p>•    read 读取整个文件<br>•    readline 读取下一行,使用生成器方法<br>•    readlines 读取整个文件到一个迭代器以供我们遍历</p>
<h4 id="28-Python2和3的区别"><a href="#28-Python2和3的区别" class="headerlink" title="28 Python2和3的区别"></a>28 Python2和3的区别</h4><p>大部分Python库都同时支持Python 2.7.x和3.x版本的，所以不论选择哪个版本都是可以的。但为了在使用Python时避开某些版本中一些常见的陷阱，或需要移植某个Python项目<br>使用<strong>future</strong>模块<br>print函数<br>整数除法<br>Unicode<br>xrange<br>触发异常<br>处理异常<br>next()函数和.next()方法<br>For循环变量与全局命名空间泄漏<br>比较无序类型<br>使用input()解析输入内容<br>返回可迭代对象，而不是列表</p>
<p>推荐：《Python 2.7.x 和 3.x 版本的重要区别》</p>
<h4 id="29-到底什么是Python？你可以在回答中与其他技术进行对比"><a href="#29-到底什么是Python？你可以在回答中与其他技术进行对比" class="headerlink" title="29 到底什么是Python？你可以在回答中与其他技术进行对比"></a>29 到底什么是Python？你可以在回答中与其他技术进行对比</h4><p>答案<br>下面是一些关键点：<br>•    Python是一种解释型语言。这就是说，与C语言和C的衍生语言不同，Python代码在运行之前不需要编译。其他解释型语言还包括PHP和Ruby。<br>•    Python是动态类型语言，指的是你在声明变量时，不需要说明变量的类型。你可以直接编写类似x=111和x=”I’m a string”这样的代码，程序不会报错。<br>•    Python非常适合面向对象的编程（OOP），因为它支持通过组合（composition）与继承（inheritance）的方式定义类（class）。Python中没有访问说明符（access specifier，类似C++中的public和private），这么设计的依据是“大家都是成年人了”。<br>•    在Python语言中，函数是第一类对象（first-class objects）。这指的是它们可以被指定给变量，函数既能返回函数类型，也可以接受函数作为输入。类（class）也是第一类对象。<br>•    Python代码编写快，但是运行速度比编译语言通常要慢。好在Python允许加入基于C语言编写的扩展，因此我们能够优化代码，消除瓶颈，这点通常是可以实现的。numpy就是一个很好地例子，它的运行速度真的非常快，因为很多算术运算其实并不是通过Python实现的。<br>•    Python用途非常广泛——网络应用，自动化，科学建模，大数据应用，等等。它也常被用作“胶水语言”，帮助其他语言和组件改善运行状况。<br>•    Python让困难的事情变得容易，因此程序员可以专注于算法和数据结构的设计，而不用处理底层的细节。<br>为什么提这个问题：<br>如果你应聘的是一个Python开发岗位，你就应该知道这是门什么样的语言，以及它为什么这么酷。以及它哪里不好。</p>
<h4 id="30-补充缺失的代码"><a href="#30-补充缺失的代码" class="headerlink" title="30 补充缺失的代码"></a>30 补充缺失的代码</h4><p>def print_directory_contents(sPath):<br>“””<br>这个函数接受文件夹的名称作为输入参数，<br>返回该文件夹中文件的路径，<br>以及其包含文件夹中文件的路径。<br>“””</p>
<h1 id="补充代码"><a href="#补充代码" class="headerlink" title="补充代码"></a>补充代码</h1><p>答案<br>def print_directory_contents(sPath):<br>import os<br>for sChild in os.listdir(sPath):<br>sChildPath = os.path.join(sPath,sChild)<br>if os.path.isdir(sChildPath):<br>print_directory_contents(sChildPath)<br>else:<br>print sChildPath<br>特别要注意以下几点：<br>•    命名规范要统一。如果样本代码中能够看出命名规范，遵循其已有的规范。<br>•    递归函数需要递归并终止。确保你明白其中的原理，否则你将面临无休无止的调用栈（callstack）。<br>•    我们使用os模块与操作系统进行交互，同时做到交互方式是可以跨平台的。你可以把代码写成sChildPath = sPath + ‘/‘ + sChild，但是这个在Windows系统上会出错。<br>•    熟悉基础模块是非常有价值的，但是别想破脑袋都背下来，记住Google是你工作中的良师益友。<br>•    如果你不明白代码的预期功能，就大胆提问。<br>•    坚持KISS原则！保持简单，不过脑子就能懂！<br>为什么提这个问题：<br>•    说明面试者对与操作系统交互的基础知识<br>•    递归真是太好用啦</p>
<h4 id="31-阅读下面的代码，写出A0，A1至An的最终值。"><a href="#31-阅读下面的代码，写出A0，A1至An的最终值。" class="headerlink" title="31 阅读下面的代码，写出A0，A1至An的最终值。"></a>31 阅读下面的代码，写出A0，A1至An的最终值。</h4><p>A0 = dict(zip((‘a’,’b’,’c’,’d’,’e’),(1,2,3,4,5)))<br>A1 = range(10)<br>A2 = [i for i in A1 if i in A0]<br>A3 = [A0[s] for s in A0]<br>A4 = [i for i in A1 if i in A3]<br>A5 = {i:i<em>i for i in A1}<br>A6 = [[i,i</em>i] for i in A1]<br>答案<br>A0 = {‘a’: 1, ‘c’: 3, ‘b’: 2, ‘e’: 5, ‘d’: 4}<br>A1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>A2 = []<br>A3 = [1, 3, 2, 5, 4]<br>A4 = [1, 2, 3, 4, 5]<br>A5 = {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}<br>A6 = [[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]<br>为什么提这个问题：<br>•    列表解析（list comprehension）十分节约时间，对很多人来说也是一个大的学习障碍。<br>•    如果你读懂了这些代码，就很可能可以写下正确地值。<br>•    其中部分代码故意写的怪怪的。因为你共事的人之中也会有怪人。</p>
<h4 id="32-下面代码会输出什么："><a href="#32-下面代码会输出什么：" class="headerlink" title="32 下面代码会输出什么："></a>32 下面代码会输出什么：</h4><p>def f(x,l=[]):<br>for i in range(x):<br>l.append(i*i)<br>print(l)</p>
<p>f(2)<br>f(3,[3,2,1])<br>f(3)<br>答案：<br>[0, 1]<br>[3, 2, 1, 0, 1, 4]<br>[0, 1, 0, 1, 4]<br>呃？<br>第一个函数调用十分明显，for循环先后将0和1添加至了空列表l中。l是变量的名字，指向内存中存储的一个列表。第二个函数调用在一块新的内存中创建了新的列表。l这时指向了新生成的列表。之后再往新列表中添加0、1和4。很棒吧。第三个函数调用的结果就有些奇怪了。它使用了之前内存地址中存储的旧列表。这就是为什么它的前两个元素是0和1了。</p>
<h4 id="33-你如何管理不同版本的代码？"><a href="#33-你如何管理不同版本的代码？" class="headerlink" title="33 你如何管理不同版本的代码？"></a>33 你如何管理不同版本的代码？</h4><p>答案：<br>版本管理！被问到这个问题的时候，你应该要表现得很兴奋，甚至告诉他们你是如何使用Git（或是其他你最喜欢的工具）追踪自己和奶奶的书信往来。我偏向于使用Git作为版本控制系统（VCS），但还有其他的选择，比如subversion（SVN）。<br>为什么提这个问题：<br>因为没有版本控制的代码，就像没有杯子的咖啡。有时候我们需要写一些一次性的、可以随手扔掉的脚本，这种情况下不作版本控制没关系。但是如果你面对的是大量的代码，使用版本控制系统是有利的。版本控制能够帮你追踪谁对代码库做了什么操作；发现新引入了什么bug；管理你的软件的不同版本和发行版；在团队成员中分享源代码；部署及其他自动化处理。它能让你回滚到出现问题之前的版本，单凭这点就特别棒了。还有其他的好功能。怎么一个棒字了得！</p>
<h4 id="34-“猴子补丁”（monkey-patching）指的是什么？这种做法好吗？"><a href="#34-“猴子补丁”（monkey-patching）指的是什么？这种做法好吗？" class="headerlink" title="34 “猴子补丁”（monkey patching）指的是什么？这种做法好吗？"></a>34 “猴子补丁”（monkey patching）指的是什么？这种做法好吗？</h4><p>答案：<br>“猴子补丁”就是指，在函数或对象已经定义之后，再去改变它们的行为。<br>举个例子：<br>import datetime<br>datetime.datetime.now = lambda: datetime.datetime(2012, 12, 12)<br>大部分情况下，这是种很不好的做法 - 因为函数在代码库中的行为最好是都保持一致。打“猴子补丁”的原因可能是为了测试。mock包对实现这个目的很有帮助。<br>为什么提这个问题？<br>答对这个问题说明你对单元测试的方法有一定了解。你如果提到要避免“猴子补丁”，可以说明你不是那种喜欢花里胡哨代码的程序员（公司里就有这种人，跟他们共事真是糟糕透了），而是更注重可维护性。还记得KISS原则码？答对这个问题还说明你明白一些Python底层运作的方式，函数实际是如何存储、调用等等。<br>另外：如果你没读过mock模块的话，真的值得花时间读一读。这个模块非常有用。</p>
<h4 id="35-阅读下面的代码，它的输出结果是什么？"><a href="#35-阅读下面的代码，它的输出结果是什么？" class="headerlink" title="35 阅读下面的代码，它的输出结果是什么？"></a>35 阅读下面的代码，它的输出结果是什么？</h4><p>class A(object):<br>def go(self):<br>print “go A go!”<br>def stop(self):<br>print “stop A stop!”<br>def pause(self):<br>raise Exception(“Not Implemented”)</p>
<p>class B(A):<br>def go(self):<br>super(B, self).go()<br>print “go B go!”</p>
<p>class C(A):<br>def go(self):<br>super(C, self).go()<br>print “go C go!”<br>def stop(self):<br>super(C, self).stop()<br>print “stop C stop!”</p>
<p>class D(B,C):<br>def go(self):<br>super(D, self).go()<br>print “go D go!”<br>def stop(self):<br>super(D, self).stop()<br>print “stop D stop!”<br>def pause(self):<br>print “wait D wait!”</p>
<p>class E(B,C): pass</p>
<p>a = A()<br>b = B()<br>c = C()<br>d = D()<br>e = E()</p>
<h1 id="说明下列代码的输出结果"><a href="#说明下列代码的输出结果" class="headerlink" title="说明下列代码的输出结果"></a>说明下列代码的输出结果</h1><p>a.go()<br>b.go()<br>c.go()<br>d.go()<br>e.go()</p>
<p>a.stop()<br>b.stop()<br>c.stop()<br>d.stop()<br>e.stop()</p>
<p>a.pause()<br>b.pause()<br>c.pause()<br>d.pause()<br>e.pause()<br>答案<br>输出结果以注释的形式表示：<br>a.go()</p>
<h1 id="go-A-go"><a href="#go-A-go" class="headerlink" title="go A go!"></a>go A go!</h1><p>b.go()</p>
<h1 id="go-A-go-1"><a href="#go-A-go-1" class="headerlink" title="go A go!"></a>go A go!</h1><h1 id="go-B-go"><a href="#go-B-go" class="headerlink" title="go B go!"></a>go B go!</h1><p>c.go()</p>
<h1 id="go-A-go-2"><a href="#go-A-go-2" class="headerlink" title="go A go!"></a>go A go!</h1><h1 id="go-C-go"><a href="#go-C-go" class="headerlink" title="go C go!"></a>go C go!</h1><p>d.go()</p>
<h1 id="go-A-go-3"><a href="#go-A-go-3" class="headerlink" title="go A go!"></a>go A go!</h1><h1 id="go-C-go-1"><a href="#go-C-go-1" class="headerlink" title="go C go!"></a>go C go!</h1><h1 id="go-B-go-1"><a href="#go-B-go-1" class="headerlink" title="go B go!"></a>go B go!</h1><h1 id="go-D-go"><a href="#go-D-go" class="headerlink" title="go D go!"></a>go D go!</h1><p>e.go()</p>
<h1 id="go-A-go-4"><a href="#go-A-go-4" class="headerlink" title="go A go!"></a>go A go!</h1><h1 id="go-C-go-2"><a href="#go-C-go-2" class="headerlink" title="go C go!"></a>go C go!</h1><h1 id="go-B-go-2"><a href="#go-B-go-2" class="headerlink" title="go B go!"></a>go B go!</h1><p>a.stop()</p>
<h1 id="stop-A-stop"><a href="#stop-A-stop" class="headerlink" title="stop A stop!"></a>stop A stop!</h1><p>b.stop()</p>
<h1 id="stop-A-stop-1"><a href="#stop-A-stop-1" class="headerlink" title="stop A stop!"></a>stop A stop!</h1><p>c.stop()</p>
<h1 id="stop-A-stop-2"><a href="#stop-A-stop-2" class="headerlink" title="stop A stop!"></a>stop A stop!</h1><h1 id="stop-C-stop"><a href="#stop-C-stop" class="headerlink" title="stop C stop!"></a>stop C stop!</h1><p>d.stop()</p>
<h1 id="stop-A-stop-3"><a href="#stop-A-stop-3" class="headerlink" title="stop A stop!"></a>stop A stop!</h1><h1 id="stop-C-stop-1"><a href="#stop-C-stop-1" class="headerlink" title="stop C stop!"></a>stop C stop!</h1><h1 id="stop-D-stop"><a href="#stop-D-stop" class="headerlink" title="stop D stop!"></a>stop D stop!</h1><p>e.stop()</p>
<h1 id="stop-A-stop-4"><a href="#stop-A-stop-4" class="headerlink" title="stop A stop!"></a>stop A stop!</h1><p>a.pause()</p>
<h1 id="…-Exception-Not-Implemented"><a href="#…-Exception-Not-Implemented" class="headerlink" title="… Exception: Not Implemented"></a>… Exception: Not Implemented</h1><p>b.pause()</p>
<h1 id="…-Exception-Not-Implemented-1"><a href="#…-Exception-Not-Implemented-1" class="headerlink" title="… Exception: Not Implemented"></a>… Exception: Not Implemented</h1><p>c.pause()</p>
<h1 id="…-Exception-Not-Implemented-2"><a href="#…-Exception-Not-Implemented-2" class="headerlink" title="… Exception: Not Implemented"></a>… Exception: Not Implemented</h1><p>d.pause()</p>
<h1 id="wait-D-wait"><a href="#wait-D-wait" class="headerlink" title="wait D wait!"></a>wait D wait!</h1><p>e.pause()</p>
<h1 id="…Exception-Not-Implemented"><a href="#…Exception-Not-Implemented" class="headerlink" title="…Exception: Not Implemented"></a>…Exception: Not Implemented</h1><p>为什么提这个问题？<br>因为面向对象的编程真的真的很重要。不骗你。答对这道问题说明你理解了继承和Python中super函数的用法。</p>
<h4 id="36-阅读下面的代码，它的输出结果是什么？"><a href="#36-阅读下面的代码，它的输出结果是什么？" class="headerlink" title="36 阅读下面的代码，它的输出结果是什么？"></a>36 阅读下面的代码，它的输出结果是什么？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">def __init__(self,sName):</span><br><span class="line">self._lChildren &#x3D; []</span><br><span class="line">self.sName &#x3D; sName</span><br><span class="line">def __repr__(self):</span><br><span class="line">return &quot;&lt;Node &#39;&#123;&#125;&#39;&gt;&quot;.format(self.sName)</span><br><span class="line">def append(self,*args,**kwargs):</span><br><span class="line">self._lChildren.append(*args,**kwargs)</span><br><span class="line">def print_all_1(self):</span><br><span class="line">print self</span><br><span class="line">for oChild in self._lChildren:</span><br><span class="line">oChild.print_all_1()</span><br><span class="line">def print_all_2(self):</span><br><span class="line">def gen(o):</span><br><span class="line">lAll &#x3D; [o,]</span><br><span class="line">while lAll:</span><br><span class="line">oNext &#x3D; lAll.pop(0)</span><br><span class="line">lAll.extend(oNext._lChildren)</span><br><span class="line">yield oNext</span><br><span class="line">for oNode in gen(self):</span><br><span class="line">print oNode</span><br><span class="line"></span><br><span class="line">oRoot &#x3D; Node(&quot;root&quot;)</span><br><span class="line">oChild1 &#x3D; Node(&quot;child1&quot;)</span><br><span class="line">oChild2 &#x3D; Node(&quot;child2&quot;)</span><br><span class="line">oChild3 &#x3D; Node(&quot;child3&quot;)</span><br><span class="line">oChild4 &#x3D; Node(&quot;child4&quot;)</span><br><span class="line">oChild5 &#x3D; Node(&quot;child5&quot;)</span><br><span class="line">oChild6 &#x3D; Node(&quot;child6&quot;)</span><br><span class="line">oChild7 &#x3D; Node(&quot;child7&quot;)</span><br><span class="line">oChild8 &#x3D; Node(&quot;child8&quot;)</span><br><span class="line">oChild9 &#x3D; Node(&quot;child9&quot;)</span><br><span class="line">oChild10 &#x3D; Node(&quot;child10&quot;)</span><br><span class="line"></span><br><span class="line">oRoot.append(oChild1)</span><br><span class="line">oRoot.append(oChild2)</span><br><span class="line">oRoot.append(oChild3)</span><br><span class="line">oChild1.append(oChild4)</span><br><span class="line">oChild1.append(oChild5)</span><br><span class="line">oChild2.append(oChild6)</span><br><span class="line">oChild4.append(oChild7)</span><br><span class="line">oChild3.append(oChild8)</span><br><span class="line">oChild3.append(oChild9)</span><br><span class="line">oChild6.append(oChild10)</span><br><span class="line"></span><br><span class="line"># 说明下面代码的输出结果</span><br><span class="line"></span><br><span class="line">oRoot.print_all_1()</span><br><span class="line">oRoot.print_all_2()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">答案</span><br><span class="line">oRoot.print_all_1()会打印下面的结果：</span><br><span class="line">&lt;Node &#39;root&#39;&gt;</span><br><span class="line">&lt;Node &#39;child1&#39;&gt;</span><br><span class="line">&lt;Node &#39;child4&#39;&gt;</span><br><span class="line">&lt;Node &#39;child7&#39;&gt;</span><br><span class="line">&lt;Node &#39;child5&#39;&gt;</span><br><span class="line">&lt;Node &#39;child2&#39;&gt;</span><br><span class="line">&lt;Node &#39;child6&#39;&gt;</span><br><span class="line">&lt;Node &#39;child10&#39;&gt;</span><br><span class="line">&lt;Node &#39;child3&#39;&gt;</span><br><span class="line">&lt;Node &#39;child8&#39;&gt;</span><br><span class="line">&lt;Node &#39;child9&#39;&gt;</span><br><span class="line">oRoot.print_all_1()会打印下面的结果：</span><br><span class="line">&lt;Node &#39;root&#39;&gt;</span><br><span class="line">&lt;Node &#39;child1&#39;&gt;</span><br><span class="line">&lt;Node &#39;child2&#39;&gt;</span><br><span class="line">&lt;Node &#39;child3&#39;&gt;</span><br><span class="line">&lt;Node &#39;child4&#39;&gt;</span><br><span class="line">&lt;Node &#39;child5&#39;&gt;</span><br><span class="line">&lt;Node &#39;child6&#39;&gt;</span><br><span class="line">&lt;Node &#39;child8&#39;&gt;</span><br><span class="line">&lt;Node &#39;child9&#39;&gt;</span><br><span class="line">&lt;Node &#39;child7&#39;&gt;</span><br><span class="line">&lt;Node &#39;child10&#39;&gt;</span><br></pre></td></tr></table></figure>
<p>为什么提这个问题？<br>因为对象的精髓就在于组合（composition）与对象构造（object construction）。对象需要有组合成分构成，而且得以某种方式初始化。这里也涉及到递归和生成器（generator）的使用。<br>生成器是很棒的数据类型。你可以只通过构造一个很长的列表，然后打印列表的内容，就可以取得与print_all_2类似的功能。生成器还有一个好处，就是不用占据很多内存。<br>有一点还值得指出，就是print_all_1会以深度优先（depth-first）的方式遍历树(tree),而print_all_2则是宽度优先（width-first）。有时候，一种遍历方式比另一种更合适。但这要看你的应用的具体情况。</p>
<h4 id="37-介绍一下except的用法和作用？"><a href="#37-介绍一下except的用法和作用？" class="headerlink" title="37 介绍一下except的用法和作用？"></a>37 介绍一下except的用法和作用？</h4><p>答：try…except…except…[else…][finally…]<br>执行try下的语句，如果引发异常，则执行过程会跳到except语句。对每个except分支顺序尝试执行，如果引发的异常与except中的异常组匹配，执行相应的语句。如果所有的except都不匹配，则异常会传递到下一个调用本代码的最高层try代码中。<br>try下的语句正常执行，则执行else块代码。如果发生异常，就不会执行<br>如果存在finally语句，最后总是会执行。</p>
<h4 id="38-Python中pass语句的作用是什么？"><a href="#38-Python中pass语句的作用是什么？" class="headerlink" title="38 Python中pass语句的作用是什么？"></a>38 Python中pass语句的作用是什么？</h4><p>答：pass语句不会执行任何操作，一般作为占位符或者创建占位程序，whileFalse:pass</p>
<h4 id="39-介绍一下Python下range-函数的用法？"><a href="#39-介绍一下Python下range-函数的用法？" class="headerlink" title="39 介绍一下Python下range()函数的用法？"></a>39 介绍一下Python下range()函数的用法？</h4><p>答：列出一组数据，经常用在for  in range()循环中</p>
<h4 id="40-Python里面match-和search-的区别？"><a href="#40-Python里面match-和search-的区别？" class="headerlink" title="40 Python里面match()和search()的区别？"></a>40 Python里面match()和search()的区别？</h4><p>答：re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。<br>re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(re.match(‘super’, ‘superstition’).span())<br>(0, 5)<br>print(re.match(‘super’, ‘insuperable’))<br>None<br>print(re.search(‘super’, ‘superstition’).span())<br>(0, 5)<br>print(re.search(‘super’, ‘insuperable’).span())<br>(2, 7)</p>
</blockquote>
</blockquote>
</blockquote>
<h4 id="41-用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？"><a href="#41-用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？" class="headerlink" title="41 用Python匹配HTML tag的时候，&lt;.&gt;和&lt;.?&gt;有什么区别？"></a>41 用Python匹配HTML tag的时候，&lt;.<em>&gt;和&lt;.</em>?&gt;有什么区别？</h4><p>答：术语叫贪婪匹配( &lt;.<em>&gt; )和非贪婪匹配(&lt;.</em>?&gt; )<br>例如:<br>test<br>&lt;.<em>&gt; :<br>test<br>&lt;.</em>?&gt; :</p>
<h4 id="42-Python里面如何生成随机数？"><a href="#42-Python里面如何生成随机数？" class="headerlink" title="42 Python里面如何生成随机数？"></a>42 Python里面如何生成随机数？</h4><p>答：random模块<br>随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=b<br>random.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。<br>随机实数：random.random( ):返回0到1之间的浮点数<br>random.uniform(a,b):返回指定范围内的浮点数。</p>
<h4 id="43-有没有一个工具可以帮助查找python的bug和进行静态的代码分析？"><a href="#43-有没有一个工具可以帮助查找python的bug和进行静态的代码分析？" class="headerlink" title="43 有没有一个工具可以帮助查找python的bug和进行静态的代码分析？"></a>43 有没有一个工具可以帮助查找python的bug和进行静态的代码分析？</h4><p>答：PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告<br>Pylint是另外一个工具可以进行codingstandard检查</p>
<h4 id="44-如何在一个function里面设置一个全局的变量？"><a href="#44-如何在一个function里面设置一个全局的变量？" class="headerlink" title="44 如何在一个function里面设置一个全局的变量？"></a>44 如何在一个function里面设置一个全局的变量？</h4><p>答：解决方法是在function的开始插入一个global声明：<br>def f()<br>global x</p>
<h4 id="45-单引号，双引号，三引号的区别"><a href="#45-单引号，双引号，三引号的区别" class="headerlink" title="45 单引号，双引号，三引号的区别"></a>45 单引号，双引号，三引号的区别</h4><p>答：单引号和双引号是等效的，如果要换行，需要符号(),三引号则可以直接换行，并且可以包含注释<br>如果要表示Let’s go 这个字符串<br>单引号：s4 = ‘Let\’s go’<br>双引号：s5 = “Let’s go”<br>s6 = ‘I realy like“python”!’<br>这就是单引号和双引号都可以表示字符串的原因了</p>
<h4 id="46-Python和多线程（multi-threading）。这是个好主意吗？列举一些让Python代码以并行方式运行的方法。"><a href="#46-Python和多线程（multi-threading）。这是个好主意吗？列举一些让Python代码以并行方式运行的方法。" class="headerlink" title="46 Python和多线程（multi-threading）。这是个好主意吗？列举一些让Python代码以并行方式运行的方法。"></a>46 Python和多线程（multi-threading）。这是个好主意吗？列举一些让Python代码以并行方式运行的方法。</h4><p>答案:Python并不支持真正意义上的多线程。Python中提供了多线程包，但是如果你想通过多线程提高代码的速度，使用多线程包并不是个好主意。Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。线程的执行速度非常之快，会让你误以为线程是并行执行的，但是实际上都是轮流执行。经过GIL这一道关卡处理，会增加执行的开销。这意味着，如果你想提高代码的运行速度，使用threading包并不是一个很好的方法。<br>不过还是有很多理由促使我们使用threading包的。如果你想同时执行一些任务，而且不考虑效率问题，那么使用这个包是完全没问题的，而且也很方便。但是大部分情况下，并不是这么一回事，你会希望把多线程的部分外包给操作系统完成（通过开启多个进程），或者是某些调用你的Python代码的外部程序（例如Spark或Hadoop），又或者是你的Python代码调用的其他代码（例如，你可以在Python中调用C函数，用于处理开销较大的多线程工作）。<br>为什么提这个问题<br>因为GIL就是个混账东西（A-hole）。很多人花费大量的时间，试图寻找自己多线程代码中的瓶颈，直到他们明白GIL的存在。</p>
<h4 id="47-将下面的函数按照执行效率高低排序。"><a href="#47-将下面的函数按照执行效率高低排序。" class="headerlink" title="47 将下面的函数按照执行效率高低排序。"></a>47 将下面的函数按照执行效率高低排序。</h4><p>它们都接受由0至1之间的数字构成的列表作为输入。这个列表可以很长。一个输入列表的示例如下：[random.random() for i in range(100000)]。你如何证明自己的答案是正确的。<br>def f1(lIn):<br>l1 = sorted(lIn)<br>l2 = [i for i in l1 if i&lt;0.5]<br>return [i*i for i in l2]</p>
<p>def f2(lIn):<br>l1 = [i for i in lIn if i&lt;0.5]<br>l2 = sorted(l1)<br>return [i*i for i in l2]</p>
<p>def f3(lIn):<br>l1 = [i<em>i for i in lIn]<br>l2 = sorted(l1)<br>return [i for i in l1 if i&lt;(0.5</em>0.5)]</p>
<p>答案:按执行效率从高到低排列：f2、f1和f3。要证明这个答案是对的，你应该知道如何分析自己代码的性能。Python中有一个很好的程序分析包，可以满足这个需求。<br>import cProfile<br>lIn = [random.random() for i in range(100000)]<br>cProfile.run(‘f1(lIn)’)<br>cProfile.run(‘f2(lIn)’)<br>cProfile.run(‘f3(lIn)’)</p>
<p>为了向大家进行完整地说明，下面我们给出上述分析代码的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; cProfile.run(&#39;f1(lIn)&#39;)</span><br><span class="line">4 function calls in 0.045 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: standard name</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">1    0.009    0.009    0.044    0.044 &lt;stdin&gt;:1(f1)</span><br><span class="line">1    0.001    0.001    0.045    0.045 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;</span><br><span class="line">1    0.035    0.035    0.035    0.035 &#123;sorted&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; cProfile.run(&#39;f2(lIn)&#39;)</span><br><span class="line">4 function calls in 0.024 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: standard name</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">1    0.008    0.008    0.023    0.023 &lt;stdin&gt;:1(f2)</span><br><span class="line">1    0.001    0.001    0.024    0.024 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;</span><br><span class="line">1    0.016    0.016    0.016    0.016 &#123;sorted&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; cProfile.run(&#39;f3(lIn)&#39;)</span><br><span class="line">4 function calls in 0.055 seconds</span><br><span class="line"></span><br><span class="line">Ordered by: standard name</span><br><span class="line"></span><br><span class="line">ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span><br><span class="line">1    0.016    0.016    0.054    0.054 &lt;stdin&gt;:1(f3)</span><br><span class="line">1    0.001    0.001    0.055    0.055 &lt;string&gt;:1(&lt;module&gt;)</span><br><span class="line">1    0.000    0.000    0.000    0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125;</span><br><span class="line">1    0.038    0.038    0.038    0.038 &#123;sorted&#125;</span><br></pre></td></tr></table></figure>
<p>为什么提这个问题？<br>定位并避免代码瓶颈是非常有价值的技能。想要编写许多高效的代码，最终都要回答常识上来——在上面的例子中，如果列表较小的话，很明显是先进行排序更快，因此如果你可以在排序前先进行筛选，那通常都是比较好的做法。其他不显而易见的问题仍然可以通过恰当的工具来定位。因此了解这些工具是有好处的。</p>
<h4 id="48-如何用Python来进行查询和替换一个文本字符串？"><a href="#48-如何用Python来进行查询和替换一个文本字符串？" class="headerlink" title="48 如何用Python来进行查询和替换一个文本字符串？"></a>48 如何用Python来进行查询和替换一个文本字符串？</h4><p>可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0])<br>replacement是被替换成的文本<br>string是需要被替换的文本<br>count是一个可选参数，指最大被替换的数量</p>
<h4 id="49-Python里面search-和match-的区别？"><a href="#49-Python里面search-和match-的区别？" class="headerlink" title="49 Python里面search()和match()的区别？"></a>49 Python里面search()和match()的区别？</h4><p>match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配, 也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none</p>
<h4 id="50-用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？"><a href="#50-用Python匹配HTML-tag的时候，-lt-gt-和-lt-gt-有什么区别？" class="headerlink" title="50 用Python匹配HTML tag的时候，&lt;.&gt;和&lt;.?&gt;有什么区别？"></a>50 用Python匹配HTML tag的时候，&lt;.<em>&gt;和&lt;.</em>?&gt;有什么区别？</h4><p>前者是贪婪匹配，会从头到尾匹配 <a>xyz</a>，而后者是非贪婪匹配，只匹配到第一个 &gt;。</p>
<h4 id="51-Python里面如何生成随机数？"><a href="#51-Python里面如何生成随机数？" class="headerlink" title="51 Python里面如何生成随机数？"></a>51 Python里面如何生成随机数？</h4><p>import random<br>random.random()<br>它会返回一个随机的0和1之间的浮点数</p>
<h4 id="52-super-init"><a href="#52-super-init" class="headerlink" title="52 super init"></a>52 super init</h4><p>super() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already.</p>
<p>Note that the syntax changed in Python 3.0: you can just say super().<code><strong>init</strong></code>() instead of super(ChildB, self).<code><strong>init</strong></code>() which IMO is quite a bit nicer.<br><a href="http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods" target="_blank" rel="external nofollow noopener noreferrer">http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods</a><br><a href="http://blog.csdn.net/mrlevo520/article/details/51712440" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/mrlevo520/article/details/51712440</a></p>
<h4 id="53-range-and-xrange"><a href="#53-range-and-xrange" class="headerlink" title="53 range and xrange"></a>53 range and xrange</h4><p>都在循环时使用，xrange内存性能更好。 for i in range(0, 20): for i in xrange(0, 20): What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily.<br><a href="http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x" target="_blank" rel="external nofollow noopener noreferrer">http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x</a></p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="1-select-poll和epoll"><a href="#1-select-poll和epoll" class="headerlink" title="1 select,poll和epoll"></a>1 select,poll和epoll</h4><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.<br>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.<br>基本上select有3个缺点:</p>
<ol>
<li>连接数受限</li>
<li>查找配对速度慢</li>
<li>数据由内核拷贝到用户态<br>poll改善了第一个缺点<br>epoll改了三个缺点.<h5 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2 调度算法"></a>2 调度算法</h5></li>
<li>先来先服务(FCFS, First Come First Serve)</li>
<li>短作业优先(SJF, Shortest Job First)</li>
<li>最高优先权调度(Priority Scheduling)</li>
<li>时间片轮转(RR, Round Robin)</li>
<li>多级反馈队列调度(multilevel feedback queue scheduling)<br>实时调度算法:</li>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF<h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h4>原因:</li>
<li>竞争资源</li>
<li>程序推进顺序不当<br>必要条件:</li>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件<br>处理死锁基本方法:</li>
<li>预防死锁(摒弃除1以外的条件)</li>
<li>避免死锁(银行家算法)</li>
<li>检测死锁(资源分配图)</li>
<li>解除死锁</li>
<li>剥夺资源</li>
<li>撤销进程<h4 id="4-程序编译与链接"><a href="#4-程序编译与链接" class="headerlink" title="4 程序编译与链接"></a>4 程序编译与链接</h4>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)<br>以c语言为例:<h5 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h5>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</li>
<li>将所有的“#define”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li>
<li>删除所有注释</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。<h5 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h5>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。<h5 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h5>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)<h5 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h5>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。<h4 id="5-静态链接和动态链接"><a href="#5-静态链接和动态链接" class="headerlink" title="5 静态链接和动态链接"></a>5 静态链接和动态链接</h4>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库<br>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序<h4 id="6-虚拟内存技术"><a href="#6-虚拟内存技术" class="headerlink" title="6 虚拟内存技术"></a>6 虚拟内存技术</h4>虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.<h4 id="7-分页和分段"><a href="#7-分页和分段" class="headerlink" title="7 分页和分段"></a>7 分页和分段</h4>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。<br>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。<br>分页与分段的主要区别</li>
<li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li>
<li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li>
<li>分页的作业地址空间是一维的.分段的地址空间是二维的.<h4 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8 页面置换算法"></a>8 页面置换算法</h4></li>
<li>最佳置换算法OPT:不可能实现</li>
<li>先进先出FIFO</li>
<li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li>
<li>clock算法<h4 id="9-边沿触发和水平触发"><a href="#9-边沿触发和水平触发" class="headerlink" title="9 边沿触发和水平触发"></a>9 边沿触发和水平触发</h4>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</li>
</ol>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h4 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h4><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p>
<h4 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h4><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。<br>索引分为聚簇索引和非聚簇索引两种，聚簇索引 是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。<br>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external nofollow noopener noreferrer">http://tech.meituan.com/mysql-index.html</a></p>
<h4 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h4><h4 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4 乐观锁和悲观锁"></a>4 乐观锁和悲观锁</h4><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h4 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h4><p>大多数的MySQL事务型存储引擎，如InnoDB，Falcon以及PBXT都不使用一种简单的行锁机制。事实上，他们都和另外一种用来增加并发性的被称为“多版本并发控制（MVCC）”的机制来一起使用。MVCC不只使用在MySQL中，Oracle、PostgreSQL，以及其他一些数据库系统也同样使用它。</p>
<h4 id="6-MyISAM和InnoDB"><a href="#6-MyISAM和InnoDB" class="headerlink" title="6 MyISAM和InnoDB"></a>6 MyISAM和InnoDB</h4><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT( * )这类的计算是超快无比的。<br>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h4><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。<h4 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h4>CP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。<br>（1）客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。<br>（2）服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。<br>（3）服务器B关闭与客户端A的连接，发送一个FIN给客户端A。<br>（4）客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。<h4 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h4>地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议<h4 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h4>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</li>
<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。<h4 id="5-Post和Get区别"><a href="#5-Post和Get区别" class="headerlink" title="5 Post和Get区别"></a>5 Post和Get区别</h4>GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。<br>GET书签可收藏，POST为书签不可收藏。<br>GET能被缓存，POST不能缓存 。<br>GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。<br>GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。<br>GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。<br>GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。<br>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。<br>GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。<h4 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h4>Cookie    Session<br>储存位置    客户端    服务器端<br>目的    跟踪会话，也可以保存用户偏好设置或者保存用户名密码等    跟踪会话<br>安全性    不安全    安全<br>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。<h4 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h4>nginx 相对 apache 的优点：<br>•    轻量级，同样起web 服务，比apache 占用更少的内存及资源<br>•    抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能<br>•    配置简洁<br>•    高度模块化的设计，编写模块相对简单<br>•    社区活跃<br>apache 相对nginx 的优点：<br>•    rewrite ，比nginx 的rewrite 强大<br>•    模块超多，基本想到的都可以找到<br>•    少bug ，nginx 的bug 相对较多<br>•    超稳定</li>
</ol>
<h4 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h4><ol>
<li>明文保存</li>
<li>明文hash后保存,如md5</li>
<li>MD5+Salt方式,这个salt可以随机</li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h4 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h4><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司进行，提供了身份验证与加密通讯方法，现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。<br>超文本传输协议 (HTTP-Hypertext transfer protocol) 是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p>
<h4 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h4><p>•    CSRF(Cross-site request forgery)跨站请求伪造<br>•    XSS(Cross Site Scripting)跨站脚本攻击<br>CSRF重点在请求,XSS重点在脚本</p>
<h4 id="11-RESTful架构-SOAP-RPC"><a href="#11-RESTful架构-SOAP-RPC" class="headerlink" title="11 RESTful架构(SOAP,RPC)"></a>11 RESTful架构(SOAP,RPC)</h4><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<h4 id="12-SOAP"><a href="#12-SOAP" class="headerlink" title="12 SOAP"></a>12 SOAP</h4><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p>
<h4 id="13-RPC"><a href="#13-RPC" class="headerlink" title="13 RPC"></a>13 RPC</h4><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.<br>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p>
<h4 id="14-CGI和WSGI"><a href="#14-CGI和WSGI" class="headerlink" title="14 CGI和WSGI"></a>14 CGI和WSGI</h4><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。<br>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<h4 id="15-幂等-Idempotence"><a href="#15-幂等-Idempotence" class="headerlink" title="15 幂等 Idempotence"></a>15 幂等 Idempotence</h4><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用)<code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果</code>，但它本身并没有产生任何副作用，因而是满足幂等性的。</p>
<p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles的语义是在http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
<h4 id="16-中间人攻击"><a href="#16-中间人攻击" class="headerlink" title="16 中间人攻击"></a>16 中间人攻击</h4><p>在GFW里屡见不鲜的,呵呵.<br>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h4 id="17-c10k问题"><a href="#17-c10k问题" class="headerlink" title="17 c10k问题"></a>17 c10k问题</h4><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。</p>
<h4 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h4><p>Socket=Ip address+ TCP/UDP + port</p>
<h4 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h4><p>推荐: <a href="http://web.jobbole.com/84367/" target="_blank" rel="external nofollow noopener noreferrer">http://web.jobbole.com/84367/</a><br>浏览器缓存机制，其实主要就是HTTP协议定义的缓存机制（如： Expires； Cache-control等）<br>Expires策略<br>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。<br>Cache-control策略（重点关注）<br>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</p>
<h4 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h4><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<ol>
<li>请求头Host字段,一个服务器多个网站</li>
<li>长链接</li>
<li>文件断点续传</li>
<li>身份认证,状态管理,Cache缓存<h4 id="21-Ajax"><a href="#21-Ajax" class="headerlink" title="21 Ajax"></a>21 Ajax</h4>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h4><p>红黑树与AVL的比较：<br>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；<br>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；<br>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h4 id="1-台阶问题-斐波纳挈"><a href="#1-台阶问题-斐波纳挈" class="headerlink" title="1 台阶问题/斐波纳挈"></a>1 台阶问题/斐波纳挈</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br>1    fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2)<br>第二种记忆方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def memo(func):</span><br><span class="line">cache &#x3D; &#123;&#125;</span><br><span class="line">def wrap(*args):</span><br><span class="line">if args not in cache:</span><br><span class="line">cache[args] &#x3D; func(*args)</span><br><span class="line">return cache[args]</span><br><span class="line">return wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@ memo</span><br><span class="line">def fib(i):</span><br><span class="line">if i &lt; 2:</span><br><span class="line">return 1</span><br><span class="line">return fib(i-1) + fib(i-2)</span><br><span class="line">第三种方法</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5	def fib(n):</span><br><span class="line">a, b &#x3D; 0, 1</span><br><span class="line">for _ in xrange(n):</span><br><span class="line">a, b &#x3D; b, a + b</span><br><span class="line">return b</span><br></pre></td></tr></table></figure>
<h4 id="2-变态台阶问题"><a href="#2-变态台阶问题" class="headerlink" title="2 变态台阶问题"></a>2 变态台阶问题</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br><span class="line">​`</span><br></pre></td></tr></table></figure>
<h4 id="3-矩形覆盖"><a href="#3-矩形覆盖" class="headerlink" title="3 矩形覆盖"></a>3 矩形覆盖</h4><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2<em>1的小矩形无重叠地覆盖一个2</em>n的大矩形，总共有多少种方法？<br>第2*n个矩形的覆盖方法等于第2</em>(n-1)加上第2*(n-2)的方法。<br>​``` python<br>f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 4 杨氏矩阵查找</span><br><span class="line">在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line">使用Step-wise线性搜索。</span><br><span class="line">&#96;&#96;&#96; python3</span><br><span class="line">def get_value(l, r, c):</span><br><span class="line">return l[r][c]</span><br><span class="line"></span><br><span class="line">def find(l, x):</span><br><span class="line">m &#x3D; len(l) - 1</span><br><span class="line">n &#x3D; len(l[0]) - 1</span><br><span class="line">r &#x3D; 0</span><br><span class="line">c &#x3D; n</span><br><span class="line">while c &gt;&#x3D; 0 and r &lt;&#x3D; m:</span><br><span class="line">value &#x3D; get_value(l, r, c)</span><br><span class="line">if value &#x3D;&#x3D; x:</span><br><span class="line">return True</span><br><span class="line">elif value &gt; x:</span><br><span class="line">c &#x3D; c - 1</span><br><span class="line">elif value &lt; x:</span><br><span class="line">r &#x3D; r + 1</span><br><span class="line">return False</span><br></pre></td></tr></table></figure>
<h4 id="5-去除列表中的重复元素"><a href="#5-去除列表中的重复元素" class="headerlink" title="5 去除列表中的重复元素"></a>5 去除列表中的重复元素</h4><p>用集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(set(l))</span><br></pre></td></tr></table></figure>
<p>用字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure>
<p>用字典并保持顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]</span><br><span class="line">l2 &#x3D; list(set(l1))</span><br><span class="line">l2.sort(key&#x3D;l1.index)</span><br><span class="line">print l2</span><br></pre></td></tr></table></figure>
<p>列表推导式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l1 &#x3D; [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;]</span><br><span class="line">l2 &#x3D; []</span><br><span class="line">[l2.append(i) for i in l1 if not i in l2]</span><br></pre></td></tr></table></figure>
<p>sorted排序并且用列表推导式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">l &#x3D; [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;] [single.append(i) for i in sorted(l) if i not in single] print single</span><br></pre></td></tr></table></figure>
<p>面试官提到的,先排序然后删除.</p>
<h4 id="6-链表成对调换"><a href="#6-链表成对调换" class="headerlink" title="6 链表成对调换"></a>6 链表成对调换</h4><p>1-&gt;2-&gt;3-&gt;4转换成2-&gt;1-&gt;4-&gt;3.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">def __init__(self, x):</span><br><span class="line">self.val &#x3D; x</span><br><span class="line">self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line"># @param a ListNode</span><br><span class="line"># @return a ListNode</span><br><span class="line">def swapPairs(self, head):</span><br><span class="line">if head !&#x3D; None and head.next !&#x3D; None:</span><br><span class="line">next &#x3D; head.next</span><br><span class="line">head.next &#x3D; self.swapPairs(next.next)</span><br><span class="line">next.next &#x3D; head</span><br><span class="line">return next</span><br><span class="line">return head</span><br></pre></td></tr></table></figure>
<h4 id="7-创建字典的方法"><a href="#7-创建字典的方法" class="headerlink" title="7 创建字典的方法"></a>7 创建字典的方法</h4><h5 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict &#x3D; &#123;&#39;name&#39;:&#39;earth&#39;, &#39;port&#39;:&#39;80&#39;&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">items&#x3D;[(&#39;name&#39;,&#39;earth&#39;),(&#39;port&#39;,&#39;80&#39;)]</span><br><span class="line">dict2&#x3D;dict(items)</span><br><span class="line">dict1&#x3D;dict(([&#39;name&#39;,&#39;earth&#39;],[&#39;port&#39;,&#39;80&#39;]))</span><br></pre></td></tr></table></figure>
<h6 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict1&#x3D;&#123;&#125;.fromkeys((&#39;x&#39;,&#39;y&#39;),-1)</span><br><span class="line">dict&#x3D;&#123;&#39;x&#39;:-1,&#39;y&#39;:-1&#125;</span><br><span class="line">dict2&#x3D;&#123;&#125;.fromkeys((&#39;x&#39;,&#39;y&#39;))</span><br><span class="line">dict2&#x3D;&#123;&#39;x&#39;:None, &#39;y&#39;:None&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-合并两个有序列表"><a href="#8-合并两个有序列表" class="headerlink" title="8 合并两个有序列表"></a>8 合并两个有序列表</h4><p>知乎远程面试要求编程</p>
<blockquote>
<p> 尾递归</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def _recursion_merge_sort2(l1, l2, tmp):</span><br><span class="line">if len(l1) &#x3D;&#x3D; 0 or len(l2) &#x3D;&#x3D; 0:</span><br><span class="line">tmp.extend(l1)</span><br><span class="line">tmp.extend(l2)</span><br><span class="line">return tmp</span><br><span class="line">else:</span><br><span class="line">if l1[0] &lt; l2[0]:</span><br><span class="line">tmp.append(l1[0])</span><br><span class="line">del l1[0]</span><br><span class="line">else:</span><br><span class="line">tmp.append(l2[0])</span><br><span class="line">del l2[0]</span><br><span class="line">return _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line">def recursion_merge_sort2(l1, l2):</span><br><span class="line">return _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 循环算法</p>
</blockquote>
<p>思路：定义一个新的空列表,比较两个列表的首个元素,小的就插入到新列表里,把已经插入新列表的元素从旧列表删除,直到两个旧列表有一个为空,再把旧列表加到新列表后面.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loop_merge_sort</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">tmp = []</span><br><span class="line"><span class="keyword">while</span> len(l1) &gt; <span class="number">0</span> <span class="keyword">and</span> len(l2) &gt; <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">tmp.append(l1[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">tmp.append(l2[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">tmp.extend(l1)</span><br><span class="line">tmp.extend(l2)</span><br><span class="line"><span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
<blockquote>
<p> pop弹出</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sortedlist</span><span class="params">(a,b)</span>:</span></span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">while</span> a <span class="keyword">and</span> b:</span><br><span class="line"><span class="keyword">if</span> a[<span class="number">0</span>] &gt;= b[<span class="number">0</span>]:</span><br><span class="line">c.append(b.pop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">c.append(a.pop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">while</span> a:</span><br><span class="line">c.append(a.pop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">while</span> b:</span><br><span class="line">c.append(b.pop(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line"><span class="keyword">print</span> merge_sortedlist(a,b)</span><br></pre></td></tr></table></figure>
<h4 id="9-交叉链表求交点"><a href="#9-交叉链表求交点" class="headerlink" title="9 交叉链表求交点"></a>9 交叉链表求交点</h4><blockquote>
<p>其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示</p>
</blockquote>
<p><img alt data-src="http://ww1.sinaimg.cn/large/006DGX4tly1ftstyh1ye6j30l9076aaf.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ListNode:</span><br><span class="line">def __init__(self, x):</span><br><span class="line">self.val &#x3D; x</span><br><span class="line">self.next &#x3D; None</span><br><span class="line">def node(l1, l2):</span><br><span class="line">length1, lenth2 &#x3D; 0, 0</span><br><span class="line"># 求两个链表长度</span><br><span class="line">while l1.next:</span><br><span class="line">l1 &#x3D; l1.next</span><br><span class="line">length1 +&#x3D; 1</span><br><span class="line">while l2.next:</span><br><span class="line">l2 &#x3D; l2.next</span><br><span class="line">length2 +&#x3D; 1</span><br><span class="line"># 长的链表先走</span><br><span class="line">if length1 &gt; lenth2:</span><br><span class="line">for _ in range(length1 - length2):</span><br><span class="line">l1 &#x3D; l1.next</span><br><span class="line">else:</span><br><span class="line">for _ in range(length2 - length1):</span><br><span class="line">l2 &#x3D; l2.next</span><br><span class="line">while l1 and l2:</span><br><span class="line">if l1.next &#x3D;&#x3D; l2.next:</span><br><span class="line">return l1.next</span><br><span class="line">else:</span><br><span class="line">l1 &#x3D; l1.next</span><br><span class="line">l2 &#x3D; l2.next</span><br></pre></td></tr></table></figure>
<p>修改了一下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">class ListNode:</span><br><span class="line">def __init__(self, x):</span><br><span class="line">self.val &#x3D; x</span><br><span class="line">self.next &#x3D; None</span><br><span class="line"></span><br><span class="line">def node(l1, l2):</span><br><span class="line">length1, length2 &#x3D; 0, 0</span><br><span class="line"># 求两个链表长度</span><br><span class="line">while l1.next:</span><br><span class="line">l1 &#x3D; l1.next#尾节点</span><br><span class="line">length1 +&#x3D; 1</span><br><span class="line">while l2.next:</span><br><span class="line">l2 &#x3D; l2.next#尾节点</span><br><span class="line">length2 +&#x3D; 1</span><br><span class="line"></span><br><span class="line">#如果相交</span><br><span class="line">if l1.next &#x3D;&#x3D; l2.next:</span><br><span class="line"># 长的链表先走</span><br><span class="line">if length1 &gt; length2:</span><br><span class="line">for _ in range(length1 - length2):</span><br><span class="line">l1 &#x3D; l1.next</span><br><span class="line">return l1#返回交点</span><br><span class="line">else:</span><br><span class="line">for _ in range(length2 - length1):</span><br><span class="line">l2 &#x3D; l2.next</span><br><span class="line">return l2#返回交点</span><br><span class="line"># 如果不相交</span><br><span class="line">else:</span><br><span class="line">return</span><br></pre></td></tr></table></figure>
<p>思路： <a href="http://humaoli.blog.163.com/blog/static/13346651820141125102125995/" target="_blank" rel="external nofollow noopener noreferrer">http://humaoli.blog.163.com/blog/static/13346651820141125102125995/</a></p>
<h4 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10 二分查找"></a>10 二分查找</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def binarySearch(l, t):</span><br><span class="line">low, high &#x3D; 0, len(l) - 1</span><br><span class="line">while low &lt; high:</span><br><span class="line">print low, high</span><br><span class="line">mid &#x3D; (low + high) &#x2F; 2</span><br><span class="line">if l[mid] &gt; t:</span><br><span class="line">high &#x3D; mid</span><br><span class="line">elif l[mid] &lt; t:</span><br><span class="line">low &#x3D; mid + 1</span><br><span class="line">else:</span><br><span class="line">return mid</span><br><span class="line">return low if l[low] &#x3D;&#x3D; t else False</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">l &#x3D; [1, 4, 12, 45, 66, 99, 120, 444]</span><br><span class="line">print binarySearch(l, 12)</span><br><span class="line">print binarySearch(l, 1)</span><br><span class="line">print binarySearch(l, 13)</span><br><span class="line">print binarySearch(l, 444)</span><br></pre></td></tr></table></figure>
<p>参考：<a href="http://blog.csdn.net/u013205877/article/details/76411718" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/u013205877/article/details/76411718</a></p>
<h4 id="11-快排"><a href="#11-快排" class="headerlink" title="11 快排"></a>11 快排</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(seq)</span>:</span></span><br><span class="line"><span class="keyword">if</span> seq==[]:</span><br><span class="line"><span class="keyword">return</span> []</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">pivot=seq[<span class="number">0</span>]</span><br><span class="line">lesser=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&lt;pivot])</span><br><span class="line">greater=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&gt;=pivot])</span><br><span class="line"><span class="keyword">return</span> lesser+[pivot]+greater</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">seq=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">78</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-65</span>,<span class="number">12</span>]</span><br><span class="line">print(qsort(seq))</span><br></pre></td></tr></table></figure>
<h4 id="12-找零问题"><a href="#12-找零问题" class="headerlink" title="12 找零问题"></a>12 找零问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def  coinChange(values, money, coinsUsed):</span><br><span class="line">#values    T[1:n]数组</span><br><span class="line">#valuesCounts   钱币对应的种类数</span><br><span class="line">#money  找出来的总钱数</span><br><span class="line">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span><br><span class="line">for cents in range(1, money+1):</span><br><span class="line">minCoins &#x3D; cents     #从第一个开始到money的所有情况初始</span><br><span class="line">for value in values:</span><br><span class="line">if value &lt;&#x3D; cents:</span><br><span class="line">temp &#x3D; coinsUsed[cents - value] + 1</span><br><span class="line">if temp &lt; minCoins:</span><br><span class="line">minCoins &#x3D; temp</span><br><span class="line">coinsUsed[cents] &#x3D; minCoins</span><br><span class="line">print(&#39;面值为：&#123;0&#125; 的最小硬币数目为：&#123;1&#125; &#39;.format(cents, coinsUsed[cents]) )</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">values &#x3D; [ 25, 21, 10, 5, 1]</span><br><span class="line">money &#x3D; 63</span><br><span class="line">coinsUsed &#x3D; &#123;i:0 for i in range(money+1)&#125;</span><br><span class="line">coinChange(values, money, coinsUsed)</span><br></pre></td></tr></table></figure>
<h4 id="13-广度遍历和深度遍历二叉树"><a href="#13-广度遍历和深度遍历二叉树" class="headerlink" title="13 广度遍历和深度遍历二叉树"></a>13 广度遍历和深度遍历二叉树</h4><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p>
<h4 id="14-二叉树节点"><a href="#14-二叉树节点" class="headerlink" title="14 二叉树节点"></a>14 二叉树节点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">def __init__(self, data, left&#x3D;None, right&#x3D;None):</span><br><span class="line">self.data &#x3D; data</span><br><span class="line">self.left &#x3D; left</span><br><span class="line">self.right &#x3D; right</span><br><span class="line"></span><br><span class="line">tree &#x3D; Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4)))</span><br></pre></td></tr></table></figure>
<h4 id="15-层次遍历"><a href="#15-层次遍历" class="headerlink" title="15 层次遍历"></a>15 层次遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def lookup(root):</span><br><span class="line">stack &#x3D; [root]</span><br><span class="line">while stack:</span><br><span class="line">current &#x3D; stack.pop(0)</span><br><span class="line">print current.data</span><br><span class="line">if current.left:</span><br><span class="line">stack.append(current.left)</span><br><span class="line">if current.right:</span><br><span class="line">stack.append(current.right)</span><br></pre></td></tr></table></figure>
<h4 id="16-深度遍历"><a href="#16-深度遍历" class="headerlink" title="16 深度遍历"></a>16 深度遍历</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def deep(root):</span><br><span class="line">if not root:</span><br><span class="line">return</span><br><span class="line">print root.data</span><br><span class="line">deep(root.left)</span><br><span class="line">deep(root.right)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">lookup(tree)</span><br><span class="line">deep(tree)</span><br></pre></td></tr></table></figure>
<h4 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h4><p>深度遍历改变顺序就OK了.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">#二叉树的遍历</span><br><span class="line">#简单的二叉树节点类</span><br><span class="line">class Node(object):</span><br><span class="line">def __init__(self,value,left,right):</span><br><span class="line">self.value &#x3D; value</span><br><span class="line">self.left &#x3D; left</span><br><span class="line">self.right &#x3D; right</span><br><span class="line"></span><br><span class="line">#中序遍历:遍历左子树,访问当前节点,遍历右子树</span><br><span class="line"></span><br><span class="line">def mid_travelsal(root):</span><br><span class="line">if root.left is None:</span><br><span class="line">mid_travelsal(root.left)</span><br><span class="line">#访问当前节点</span><br><span class="line">print(root.value)</span><br><span class="line">if root.right is not None:</span><br><span class="line">mid_travelsal(root.right)</span><br><span class="line"></span><br><span class="line">#前序遍历:访问当前节点,遍历左子树,遍历右子树</span><br><span class="line"></span><br><span class="line">def pre_travelsal(root):</span><br><span class="line">print (root.value)</span><br><span class="line">if root.left is not None:</span><br><span class="line">pre_travelsal(root.left)</span><br><span class="line">if root.right is not None:</span><br><span class="line">pre_travelsal(root.right)</span><br><span class="line"></span><br><span class="line">#后续遍历:遍历左子树,遍历右子树,访问当前节点</span><br><span class="line"></span><br><span class="line">def post_trvelsal(root):</span><br><span class="line">if root.left is not None:</span><br><span class="line">post_trvelsal(root.left)</span><br><span class="line">if root.right is not None:</span><br><span class="line">post_trvelsal(root.right)</span><br><span class="line">print (root.value)</span><br></pre></td></tr></table></figure>
<h4 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def maxDepth(root):</span><br><span class="line">if not root:</span><br><span class="line">return 0</span><br><span class="line">return max(maxDepth(root.left), maxDepth(root.right)) + 1</span><br></pre></td></tr></table></figure>
<h4 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def isSameTree(p, q):</span><br><span class="line">if p &#x3D;&#x3D; None and q &#x3D;&#x3D; None:</span><br><span class="line">return True</span><br><span class="line">elif p and q :</span><br><span class="line">return p.val &#x3D;&#x3D; q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right)</span><br><span class="line">else :</span><br><span class="line">return False</span><br></pre></td></tr></table></figure>
<h4 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def rebuild(pre, center):</span><br><span class="line">if not pre:</span><br><span class="line">return</span><br><span class="line">cur &#x3D; Node(pre[0])</span><br><span class="line">index &#x3D; center.index(pre[0])</span><br><span class="line">cur.left &#x3D; rebuild(pre[1:index + 1], center[:index])</span><br><span class="line">cur.right &#x3D; rebuild(pre[index + 1:], center[index + 1:])</span><br><span class="line">return cur</span><br><span class="line"></span><br><span class="line">def deep(root):</span><br><span class="line">if not root:</span><br><span class="line">return</span><br><span class="line">deep(root.left)</span><br><span class="line">deep(root.right)</span><br><span class="line">print root.data</span><br></pre></td></tr></table></figure>
<p>推荐：<a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p>
<h4 id="21-单链表逆置"><a href="#21-单链表逆置" class="headerlink" title="21 单链表逆置"></a>21 单链表逆置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">def __init__(self, data&#x3D;None, next&#x3D;None):</span><br><span class="line">self.data &#x3D; data</span><br><span class="line">self.next &#x3D; next</span><br><span class="line"></span><br><span class="line">link &#x3D; Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))</span><br><span class="line"></span><br><span class="line">def rev(link):</span><br><span class="line">pre &#x3D; link</span><br><span class="line">cur &#x3D; link.next</span><br><span class="line">pre.next &#x3D; None</span><br><span class="line">while cur:</span><br><span class="line">tmp &#x3D; cur.next</span><br><span class="line">cur.next &#x3D; pre</span><br><span class="line">pre &#x3D; cur</span><br><span class="line">cur &#x3D; tmp</span><br><span class="line">return pre</span><br><span class="line"></span><br><span class="line">root &#x3D; rev(link)</span><br><span class="line">while root:</span><br><span class="line">print root.data</span><br><span class="line">root &#x3D; root.next</span><br></pre></td></tr></table></figure>
<p>思路：<a href="http://blog.csdn.net/feliciafay/article/details/6841115" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/feliciafay/article/details/6841115</a><br>方法：<a href="http://www.xuebuyuan.com/2066385.html?mobile=1" target="_blank" rel="external nofollow noopener noreferrer">http://www.xuebuyuan.com/2066385.html?mobile=1</a></p>
<h4 id="22-两个字符串是否是变位词"><a href="#22-两个字符串是否是变位词" class="headerlink" title="22 两个字符串是否是变位词"></a>22 两个字符串是否是变位词</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Anagram:</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@:param s1: The first string</span><br><span class="line">@:param s2: The second string</span><br><span class="line">@:return true or false</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">def Solution1(s1,s2):</span><br><span class="line">alist &#x3D; list(s2)</span><br><span class="line"></span><br><span class="line">pos1 &#x3D; 0</span><br><span class="line">stillOK &#x3D; True</span><br><span class="line"></span><br><span class="line">while pos1 &lt; len(s1) and stillOK:</span><br><span class="line">pos2 &#x3D; 0</span><br><span class="line">found &#x3D; False</span><br><span class="line">while pos2 &lt; len(alist) and not found:</span><br><span class="line">if s1[pos1] &#x3D;&#x3D; alist[pos2]:</span><br><span class="line">found &#x3D; True</span><br><span class="line">else:</span><br><span class="line">pos2 &#x3D; pos2 + 1</span><br><span class="line"></span><br><span class="line">if found:</span><br><span class="line">alist[pos2] &#x3D; None</span><br><span class="line">else:</span><br><span class="line">stillOK &#x3D; False</span><br><span class="line"></span><br><span class="line">pos1 &#x3D; pos1 + 1</span><br><span class="line"></span><br><span class="line">return stillOK</span><br><span class="line"></span><br><span class="line">print(Solution1(&#39;abcd&#39;,&#39;dcba&#39;))</span><br><span class="line"></span><br><span class="line">def Solution2(s1,s2):</span><br><span class="line">alist1 &#x3D; list(s1)</span><br><span class="line">alist2 &#x3D; list(s2)</span><br><span class="line"></span><br><span class="line">alist1.sort()</span><br><span class="line">alist2.sort()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos &#x3D; 0</span><br><span class="line">matches &#x3D; True</span><br><span class="line"></span><br><span class="line">while pos &lt; len(s1) and matches:</span><br><span class="line">if alist1[pos] &#x3D;&#x3D; alist2[pos]:</span><br><span class="line">pos &#x3D; pos + 1</span><br><span class="line">else:</span><br><span class="line">matches &#x3D; False</span><br><span class="line"></span><br><span class="line">return matches</span><br><span class="line"></span><br><span class="line">print(Solution2(&#39;abcde&#39;,&#39;edcbg&#39;))</span><br><span class="line"></span><br><span class="line">def Solution3(s1,s2):</span><br><span class="line">c1 &#x3D; [0]*26</span><br><span class="line">c2 &#x3D; [0]*26</span><br><span class="line"></span><br><span class="line">for i in range(len(s1)):</span><br><span class="line">pos &#x3D; ord(s1[i])-ord(&#39;a&#39;)</span><br><span class="line">c1[pos] &#x3D; c1[pos] + 1</span><br><span class="line"></span><br><span class="line">for i in range(len(s2)):</span><br><span class="line">pos &#x3D; ord(s2[i])-ord(&#39;a&#39;)</span><br><span class="line">c2[pos] &#x3D; c2[pos] + 1</span><br><span class="line"></span><br><span class="line">j &#x3D; 0</span><br><span class="line">stillOK &#x3D; True</span><br><span class="line">while j&lt;26 and stillOK:</span><br><span class="line">if c1[j] &#x3D;&#x3D; c2[j]:</span><br><span class="line">j &#x3D; j + 1</span><br><span class="line">else:</span><br><span class="line">stillOK &#x3D; False</span><br><span class="line"></span><br><span class="line">return stillOK</span><br><span class="line"></span><br><span class="line">print(Solution3(&#39;apple&#39;,&#39;pleap&#39;))</span><br></pre></td></tr></table></figure>
<h4 id="23-动态规划问题"><a href="#23-动态规划问题" class="headerlink" title="23 动态规划问题"></a>23 动态规划问题</h4><blockquote>
<p> 可参考: <a href="http://blog.csdn.net/mrlevo520/article/details/75676160" target="_blank" rel="external nofollow noopener noreferrer">动态规划(DP)的整理-Python描述</a></p>
</blockquote>
<h3 id="Python-Web相关"><a href="#Python-Web相关" class="headerlink" title="Python Web相关"></a>Python Web相关</h3><h4 id="1-解释一下-WSGI-和-FastCGI-的关系？"><a href="#1-解释一下-WSGI-和-FastCGI-的关系？" class="headerlink" title="1 解释一下 WSGI 和 FastCGI 的关系？"></a>1 解释一下 WSGI 和 FastCGI 的关系？</h4><p>CGI全称是“公共网关接口”(CommonGateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。　CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。</p>
<p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute模式)。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。<br>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。<br>WSGI的全称为： PythonWeb Server Gateway Interface v1.0 （Python Web 服务器网关接口），<br>它是 Python 应用程序和 WEB 服务器之间的一种接口。<br>它的作用，类似于FCGI 或 FASTCGI 之类的协议的作用。<br>WSGI 的目标，是要建立一个简单的普遍适用的服务器与 WEB 框架之间的接口。<br>Flup就是使用 Python 语言对 WSGI 的一种实现，是可以用于 Python 的应用开发中的一种工具或者说是一种库。<br>Spawn-fcgi是一个小程序，这个程序的作用是管理fast-cgi进程，那么管理wsgi进程也是没有问题的，功能和php-fpm类似。<br>故，简单地说，WSGI和FastCGI都是一种CGI，用于连接WEB服务器与应用程序，而WSGI专指Python应用程序。而flup是WSGI的一种实现，Spawn-fcgi是用于管理flup进程的一个工具，可以启动多个wsgi进程，并管理它们。</p>
<h4 id="2-解释一下-Django-和-Tornado-的关系、差别"><a href="#2-解释一下-Django-和-Tornado-的关系、差别" class="headerlink" title="2 解释一下 Django 和 Tornado 的关系、差别"></a>2 解释一下 Django 和 Tornado 的关系、差别</h4><p>Django源自一个在线新闻 Web站点，于 2005 年以开源的形式被释放出来。<br>Django 框架的核心组件有：<br>用于创建模型的对象关系映射为最终用户设计的完美管理界面一流的 URL 设计设计者友好的模板语言缓存系统等等<br>它鼓励快速开发,并遵循MVC设计。Django遵守 BSD版权，最新发行版本是Django<br>1.4，于2012年03月23日发布.Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用,多个组件可以很方便的以“插件”形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(Do Not RepeatYourself)原则。<br>Tornado是 FriendFeed使用的可扩展的非阻塞式 web 服务器及其相关工具的开源版本。这个 Web 框架看起来有些像 web.py 或者 Google 的 webapp，不过为了能有效利用非阻塞式服务器环境，这个 Web 框架还包含了一些相关的有用工具和优化。<br>Tornado 和现在的主流 Web 服务器框架（包括大多数Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其 非阻塞的方式和对epoll的运用，Tornado 每秒可以处理数以千计的连接，这意味着对于实时 Web服务来说，Tornado 是一个理想的 Web 框架。我们开发这个 Web 服务器的主要目的就是为了处理 FriendFeed 的实时功能 ——在 FriendFeed 的应用里每一个活动用户都会保持着一个服务器连接。（关于如何扩容 服务器，以处理数以千计的客户端的连接的问题。</p>
<h4 id="3-解释下django-debug-toolbar的使用"><a href="#3-解释下django-debug-toolbar的使用" class="headerlink" title="3 解释下django-debug-toolbar的使用"></a>3 解释下django-debug-toolbar的使用</h4><p>使用django开发站点时，可以使用django-debug-toolbar来进行调试。在settings.py中添加’debug_toolbar.middleware.DebugToolbarMiddleware’到项目的MIDDLEWARE_CLASSES 内。</p>
<h4 id="4-解释下Django使用redis缓存服务器"><a href="#4-解释下Django使用redis缓存服务器" class="headerlink" title="4 解释下Django使用redis缓存服务器"></a>4 解释下Django使用redis缓存服务器</h4><p>为了能在Django中使用redis，还需要安装redis for Django的插件。然后在Django的settings中配置了。现在连接和配置都已经完成了，接下来是一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="comment">#read cache user id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_from_cache</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">key = <span class="string">'user_id_of_'</span>+user_name</span><br><span class="line">value = cache.get(key)</span><br><span class="line"><span class="keyword">if</span> value == <span class="literal">None</span>:</span><br><span class="line">data = <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">data = json.loads(value)</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line"><span class="comment">#write cache user id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_cache</span><span class="params">(self, user_name)</span>:</span></span><br><span class="line">key = <span class="string">'user_id_of_'</span>+user_name</span><br><span class="line">cache.set(key, json.dumps(user_name), settings.NEVER_REDIS_TIMEOUT)</span><br></pre></td></tr></table></figure>
<h4 id="5-如何进行Django单元测试"><a href="#5-如何进行Django单元测试" class="headerlink" title="5 如何进行Django单元测试"></a>5 如何进行Django单元测试</h4><p>Django的单元测试使用python的unittest模块，这个模块使用基于类的方法来定义测试。类名为django.test.TestCase,继承于python的unittest.TestCase。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.test <span class="keyword">import</span> TestCase</span><br><span class="line"><span class="keyword">from</span> myapp.models <span class="keyword">import</span> Animal</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimalTestCase</span><span class="params">(TestCase)</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">Animal.objects.create(name=<span class="string">"lion"</span>, sound=<span class="string">"roar"</span>)</span><br><span class="line">Animal.objects.create(name=<span class="string">"cat"</span>, sound=<span class="string">"meow"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_animals_can_speak</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="string">"""Animals that can speak are correctly identified"""</span></span><br><span class="line">lion = Animal.objects.get(name=<span class="string">"lion"</span>)</span><br><span class="line">cat = Animal.objects.get(name=<span class="string">"cat"</span>)</span><br><span class="line">self.assertEqual(lion.speak(), <span class="string">'The lion says "roar"'</span>)</span><br><span class="line">self.assertEqual(cat.speak(), <span class="string">'The cat says "meow"'</span>)</span><br></pre></td></tr></table></figure>
<p>执行目录下所有的测试(所有的test*.py文件)：运行测试的时候，测试程序会在所有以test开头的文件中查找所有的test cases(inittest.TestCase的子类),自动建立测试集然后运行测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python manage.py <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>执行animals项目下tests包里的测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python manage.py testanimals.tests</span><br></pre></td></tr></table></figure>
<p>执行animals项目里的test测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python manage.py testanimals</span><br></pre></td></tr></table></figure>
<p>单独执行某个test case：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python manage.py testanimals.tests.AnimalTestCase</span><br></pre></td></tr></table></figure>
<p>单独执行某个测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python manage.py testanimals.tests.AnimalTestCase.test_animals_can_speak</span><br></pre></td></tr></table></figure>
<p>为测试文件提供路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python manage.py testanimals&#x2F;</span><br></pre></td></tr></table></figure>
<p>通配测试文件名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python manage.py test--pattern&#x3D;&quot;tests_*.py&quot;</span><br></pre></td></tr></table></figure>
<p>启用warnings提醒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python -Wall manage.py test</span><br></pre></td></tr></table></figure>
<h4 id="6-解释下Http协议"><a href="#6-解释下Http协议" class="headerlink" title="6 解释下Http协议"></a>6 解释下Http协议</h4><p>HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。<br>HTTP协议的主要特点可概括如下：<br>1.支持客户/服务器模式。<br>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p>
<h4 id="7-解释下Http请求头和常见响应状态码"><a href="#7-解释下Http请求头和常见响应状态码" class="headerlink" title="7 解释下Http请求头和常见响应状态码"></a>7 解释下Http请求头和常见响应状态码</h4><p>Accept:指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式。<br>Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1.<br>Accept-Language：指出浏览器可以接受的语言种类，如en或en-us，指英语。<br>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。<br>Cache-Control：设置关于请求被代理服务器存储的相关选项。一般用不到。<br>Connection：用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接。<br>Content-Type：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。<br>Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</p>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br>1xx：指示信息–表示请求已接收，继续处理<br>2xx：成功–表示请求已被成功接收、理解、接受<br>3xx：重定向–要完成请求必须进行更进一步的操作<br>4xx：客户端错误–请求有语法错误或请求无法实现<br>5xx：服务器端错误–服务器未能实现合法的请求<br>常见状态代码、状态描述、说明：<br>200 OK     //客户端请求成功<br>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用<br>403 Forbidden  //服务器收到请求，但是拒绝提供服务<br>404 Not Found  //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error //服务器发生不可预期的错误<br>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br>eg：HTTP/1.1 200 OK （CRLF）</p>
<h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><h4 id="1-试列出至少三种目前流行的大型数据库的名称-、-、-其中您最熟悉的是-从-年开始使用。"><a href="#1-试列出至少三种目前流行的大型数据库的名称-、-、-其中您最熟悉的是-从-年开始使用。" class="headerlink" title="1 试列出至少三种目前流行的大型数据库的名称:____、_____、__,其中您最熟悉的是__,从__年开始使用。"></a>1 试列出至少三种目前流行的大型数据库的名称:<strong>____</strong>、<strong>_____</strong>、<strong><strong>__</strong></strong>,其中您最熟悉的是<strong><strong>__</strong></strong>,从<strong><strong>__</strong></strong>年开始使用。</h4><p>Oracle，Mysql，SQLServer Oracle根据自己情况</p>
<h4 id="2-有表List，并有字段A、B、C，类型都是整数。表中有如下几条记录："><a href="#2-有表List，并有字段A、B、C，类型都是整数。表中有如下几条记录：" class="headerlink" title="2 有表List，并有字段A、B、C，类型都是整数。表中有如下几条记录："></a>2 有表List，并有字段A、B、C，类型都是整数。表中有如下几条记录：</h4><p>A    B    C<br>2    7    9<br>5    6    4<br>3    11    9<br>现在对该表一次完成以下操作：<br>查询出B和C列的值，要求按B列升序排列<br>写出一条新的记录，值为{7,9,8}<br>查询C列，要求消除重复的值，按降序排列<br>写出完成完成以上操作的标准的SQL语句，并且写出操作3的结果。<br>create table List(A int,B int,C int)<br>Select B,C from List order by B<br>Insert into List values(7,9,8)<br>Select distinct(C) from List order by desc;<br>984</p>
<h4 id="3-请简要说明视图的作用"><a href="#3-请简要说明视图的作用" class="headerlink" title="3 请简要说明视图的作用"></a>3 请简要说明视图的作用</h4><p>1.数据库视图隐藏了数据的复杂性。<br>2.数据库视图有利于控制用户对表中某些列的访问。<br>3.数据库视图使用户查询变得简单。</p>
<h4 id="4-列举您使用过的python网络爬虫所用到的网络数据包（最熟悉的在前）："><a href="#4-列举您使用过的python网络爬虫所用到的网络数据包（最熟悉的在前）：" class="headerlink" title="4 列举您使用过的python网络爬虫所用到的网络数据包（最熟悉的在前）："></a>4 列举您使用过的python网络爬虫所用到的网络数据包（最熟悉的在前）：</h4><p>requests、urllib、urllib2、httplib2</p>
<h4 id="5-列举您使用过的python网络爬虫所用到的解析数据包（最熟悉的在前）："><a href="#5-列举您使用过的python网络爬虫所用到的解析数据包（最熟悉的在前）：" class="headerlink" title="5 列举您使用过的python网络爬虫所用到的解析数据包（最熟悉的在前）："></a>5 列举您使用过的python网络爬虫所用到的解析数据包（最熟悉的在前）：</h4><p>BeautifulSoup、pyquery、Xpath、lxml</p>
<h4 id="6-列举您使用过的python中的编码方式（最熟悉的在前）："><a href="#6-列举您使用过的python中的编码方式（最熟悉的在前）：" class="headerlink" title="6 列举您使用过的python中的编码方式（最熟悉的在前）："></a>6 列举您使用过的python中的编码方式（最熟悉的在前）：</h4><p>UTF-8，ASCII，gbk</p>
<h4 id="7-python3-5语言中enumerate的意思是"><a href="#7-python3-5语言中enumerate的意思是" class="headerlink" title="7 python3.5语言中enumerate的意思是___"></a>7 python3.5语言中enumerate的意思是<strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></h4><p>对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值<br>enumerate多用于在for循环中得到计数</p>
<h4 id="8-99的八进制表示是"><a href="#8-99的八进制表示是" class="headerlink" title="8 99的八进制表示是___"></a>8 99的八进制表示是<strong><strong><strong><strong><strong>___</strong></strong></strong></strong></strong></h4><p>143</p>
<h4 id="9-请举出三种常用的排序算法"><a href="#9-请举出三种常用的排序算法" class="headerlink" title="9 请举出三种常用的排序算法"></a>9 请举出三种常用的排序算法</h4><p>冒泡、选择、快速</p>
<h4 id="10-列出比较熟悉的爬虫框架"><a href="#10-列出比较熟悉的爬虫框架" class="headerlink" title="10 列出比较熟悉的爬虫框架"></a>10 列出比较熟悉的爬虫框架</h4><p>Scrapy</p>
<h4 id="11-用4、9、2、7四个数字，可以使用-、-、-和-，每个数字使用一次，使表达式的结果为24，表达式是"><a href="#11-用4、9、2、7四个数字，可以使用-、-、-和-，每个数字使用一次，使表达式的结果为24，表达式是" class="headerlink" title="11 用4、9、2、7四个数字，可以使用+、-、* 和 /，每个数字使用一次，使表达式的结果为24，表达式是_____"></a>11 用4、9、2、7四个数字，可以使用+、-、* 和 /，每个数字使用一次，使表达式的结果为24，表达式是<strong><strong><strong><strong><strong><strong>_____</strong></strong></strong></strong></strong></strong></h4><p>（9+7-4）* 2</p>
<h4 id="12-对你最有影响的或是您认为最有价值的软件方面的几本书是？"><a href="#12-对你最有影响的或是您认为最有价值的软件方面的几本书是？" class="headerlink" title="12 对你最有影响的或是您认为最有价值的软件方面的几本书是？"></a>12 对你最有影响的或是您认为最有价值的软件方面的几本书是？</h4><h4 id="13-您最熟悉的Unix环境是-Unix下查询环境变量的命令是-查询脚本定时任务的命令是"><a href="#13-您最熟悉的Unix环境是-Unix下查询环境变量的命令是-查询脚本定时任务的命令是" class="headerlink" title="13 您最熟悉的Unix环境是_____.Unix下查询环境变量的命令是____,查询脚本定时任务的命令是____"></a>13 您最熟悉的Unix环境是<strong><strong>_____</strong></strong>.Unix下查询环境变量的命令是<strong>____</strong>,查询脚本定时任务的命令是<strong><strong><strong><strong>____</strong></strong></strong></strong></h4><p>1AIX，envcrontab</p>
<h4 id="14-写出在网络爬虫爬取数据的过程中，遇到的防爬虫问题的解决方案"><a href="#14-写出在网络爬虫爬取数据的过程中，遇到的防爬虫问题的解决方案" class="headerlink" title="14 写出在网络爬虫爬取数据的过程中，遇到的防爬虫问题的解决方案"></a>14 写出在网络爬虫爬取数据的过程中，遇到的防爬虫问题的解决方案</h4><p>通过headers反爬虫：解决策略，伪造headers<br>基于用户行为反爬虫：动态变化去爬取数据，模拟普通用户的行为<br>基于动态页面的反爬虫：跟踪服务器发送的ajax请求，模拟ajax请求</p>
<h4 id="15-阅读以下Python程序"><a href="#15-阅读以下Python程序" class="headerlink" title="15 阅读以下Python程序"></a>15 阅读以下Python程序</h4><p>foriinrange(5,0,-1):<br>print(i)<br>请在下面写出打印结果<br>54321</p>
<h4 id="16-在某系统中一个整数占用两个八位字节，使用Python按下面的要求编写完整程序。"><a href="#16-在某系统中一个整数占用两个八位字节，使用Python按下面的要求编写完整程序。" class="headerlink" title="16 在某系统中一个整数占用两个八位字节，使用Python按下面的要求编写完整程序。"></a>16 在某系统中一个整数占用两个八位字节，使用Python按下面的要求编写完整程序。</h4><p>接收从标准输入中依次输入的五个数字，将其组合成为一个整数，放入全局变量n中，随后在标准输出输出这个整数。（ord(char)获取字符ASCII值的函数）</p>
<p>人，从刚出生来到这个世界，便开始探索这个世界。累了就歇会，精神了就继续探索，直至死亡。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab-runner-ssh_on_ubuntu18.04</title>
    <url>/posts/c250a948/</url>
    <content><![CDATA[<p>需求是利用gitlabci的流程在编译打包成功后直接在开发机上部署，所以直接在ubuntu18.04上安装gitlab-runner，而不是docker运行，此处选择ssh的方式部署到远程服务器，<strong>注意</strong>：此处待验证是否可以同时ssh到多个机器部署。<br>这个坑在于官方并不完善，以下步骤必须完成，否则会有两个问题:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker-compose pull &amp;&amp; sudo docker-compose up -d</span><br><span class="line">sudo: no tty present and no askpass program specified</span><br><span class="line">ERROR: Job failed: Process exited with: 1. Reason was:  ()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR: Preparation failed: ssh: unsupported key <span class="built_in">type</span> <span class="string">"OPENSSH PRIVATE KEY"</span></span><br><span class="line">Will be retried <span class="keyword">in</span> 3s ...</span><br></pre></td></tr></table></figure>

<p>解决方案两点：<br>1、生成秘钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ssh-keygen -t rsa -C <span class="string">"dev-110"</span> -b 4096</span><br><span class="line">...</span><br><span class="line">&gt; ssh-copy-id localhost(&#123;node-ip&#125;)</span><br></pre></td></tr></table></figure>
<p>拷贝~/.ssh/id_rsa.pub并上传到gitlab设置的SSH Keys中</p>
<p>2、更改sudo设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudo   ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为</span></span><br><span class="line">%sudo   ALL=(ALL:ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure>

<p>另外gitlab-runner的配置文件为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">concurrent = 1</span><br><span class="line">check_interval = 0</span><br><span class="line"></span><br><span class="line">[session_server]</span><br><span class="line">  session_timeout = 1800</span><br><span class="line"></span><br><span class="line">[[runners]]</span><br><span class="line">  name = <span class="string">"dev"</span></span><br><span class="line">  url = <span class="string">"http://gitlab/"</span></span><br><span class="line">  token = <span class="string">"3c4c563580ee515093b1ca8b7929b0"</span></span><br><span class="line">  executor = <span class="string">"ssh"</span></span><br><span class="line">  [runners.custom_build_dir]</span><br><span class="line">  [runners.ssh]</span><br><span class="line">    user = <span class="string">"vissssa"</span></span><br><span class="line">    password = <span class="string">"123"</span></span><br><span class="line">    host = <span class="string">"localhost"</span></span><br><span class="line">    port = <span class="string">"22"</span></span><br><span class="line">    identity_file = <span class="string">"/home/vissssa/.ssh/id_rsa"</span></span><br><span class="line">  [runners.cache]</span><br><span class="line">    [runners.cache.s3]</span><br><span class="line">    [runners.cache.gcs]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask浅析-request上下文</title>
    <url>/posts/2662e6b2/</url>
    <content><![CDATA[<h5 id="Flask浅析系列"><a href="#Flask浅析系列" class="headerlink" title="Flask浅析系列"></a>Flask浅析系列</h5><a href="/posts/2662e6b2/" title="Flask浅析-request上下文">Flask浅析-request上下文</a><br>
<a href="/posts/a287ede/" title="Flask浅析-信号和Hook">Flask浅析-信号和Hook</a><br>
<hr>
<h1 id="理解Flask的request上下文"><a href="#理解Flask的request上下文" class="headerlink" title="理解Flask的request上下文"></a>理解Flask的request上下文</h1><p>request是全局变量，但request的属性总是对应当前请求的值，这是如何做到的呢？同样的还有current_app。</p>
<p>request/app context是保存到栈里的，我们什么时候需要栈？很多人都有这样的疑问，有人在stackoverflow提了个很好的问题：<a href="https://stackoverflow.com/questions/20036520/what-is-the-purpose-of-flasks-context-stacks" target="_blank" rel="external nofollow noopener noreferrer">What is the purpose of Flask’s context stacks?</a></p>
<p>初次接触Flask的人会觉得很神奇，即使是经验丰富的开发者也未必清楚其中的原因。Flask的文档对request context和app context的解释只会让不清楚实现细节的人更加迷惑。本文将试图从Flask的源码找到答案，向大家揭开这个黑魔法的面纱，并把这两个问题解释清楚。</p>
<p>以下的分析基于当前最新版的代码（0.13-dev）。</p>
<h2 id="通过全局变量request访问当前请求的属性"><a href="#通过全局变量request访问当前请求的属性" class="headerlink" title="通过全局变量request访问当前请求的属性:"></a>通过全局变量request访问当前请求的属性:<a name="1"></a></h2><h3 id="request只是一个代理"><a href="#request只是一个代理" class="headerlink" title="request只是一个代理"></a>request只是一个代理</h3><p>在同一个python进程中同时处理多个请求时，这里的同时是指并发，比如CherryPy使用多线程处理并发请求，Gunicorn为每个请求创建一个greenlet协程，那么request全局变量如何保存当前请求的属性呢？ request当然不是一个普通的全局变量，它其实是代理类LocalProxy的对象，当访问request.path时会调用request的<code>__getattr__</code>魔术方法，该方法会正确地找到当前请求对应的request对象。</p>
<p>那么问题来了，LocalProxy类如何找到当前请求的对象？</p>
<h3 id="request的内部机制"><a href="#request的内部机制" class="headerlink" title="request的内部机制"></a>request的内部机制</h3><p>是时候看着源码讨论实现细节了，为了方便理解，以下忽略了无关的代码。</p>
<p>我们从获取request的属性开始跟踪代码的执行。 先看request全局变量定义的地方（flask/globals.py），</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_lookup_req_object</span><span class="params">(name)</span>:</span></span><br><span class="line">    top = _request_ctx_stack.top</span><br><span class="line">    <span class="keyword">if</span> top <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(_request_ctx_err_msg)</span><br><span class="line">    <span class="keyword">return</span> getattr(top, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line"></span><br><span class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">'request'</span>))</span><br></pre></td></tr></table></figure>

<p>LocalProxy充当代理类的作用，代码位于werkzeug/local.py，Werkzeug是Flask依赖的包，它是Flask的核心。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalProxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, local, name=None)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        object.__setattr__(self, <span class="string">'_LocalProxy__local'</span>, local)</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_current_object</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self.__local, <span class="string">'__release_local__'</span>):</span><br><span class="line">            <span class="keyword">return</span> self.__local()</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> getattr(self._get_current_object(), name)</span><br></pre></td></tr></table></figure>

<p>可见，request全局变量总是对应_request_ctx_stack栈顶的request context的request属性。但还无法解释为什么访问request总是得到当前请求的值。</p>
<p>进一步看LocalStack的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._local = Local()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">        <span class="string">"""Pushes a new item to the stack"""</span></span><br><span class="line">        rv = getattr(self._local, <span class="string">'stack'</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> rv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self._local.stack = rv = []</span><br><span class="line">        rv.append(obj)</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._local.stack[<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">except</span> (AttributeError, IndexError):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>可见，LocalStack的栈保存在Local的stack属性上，它只是对Local的一层包装。</p>
<p>关键的地方在于Local</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># since each thread has its own greenlet we can just use those as identifiers</span></span><br><span class="line"><span class="comment"># for the context.  If greenlets are not available we fall back to the</span></span><br><span class="line"><span class="comment"># current thread ident depending on where it is.</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> greenlet <span class="keyword">import</span> getcurrent <span class="keyword">as</span> get_ident</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">from</span> thread <span class="keyword">import</span> get_ident</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="keyword">from</span> _thread <span class="keyword">import</span> get_ident</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br></pre></td></tr></table></figure>

<p>Local的属性集（是一个dict）保存在内部的<strong>storage</strong>这个dict里，并以当前协程作为id或当前线程id作为key。因此，</p>
<p>不同协程或线程可以共用同一个Local全局变量而不产生冲突</p>
<p>。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># globally</span></span><br><span class="line">local = Local()</span><br><span class="line"><span class="comment"># …</span></span><br><span class="line"><span class="comment"># on thread 1</span></span><br><span class="line">local.name = ‘yxr’</span><br><span class="line"></span><br><span class="line"><span class="comment"># on thread 2</span></span><br><span class="line">local.name = ‘asoka’</span><br></pre></td></tr></table></figure>

<p>这就是前面提到的黑魔法。</p>
<p>有个疑问：如果当前环境安装了greenlet，但是使用多线程处理并发请求，那么根据代码，会使用greenlet的getcurrent作为当前请求的唯一id，这是否可行呢？答案是肯定的，greenlet的文档<a href="https://greenlet.readthedocs.io/en/latest/" target="_blank" rel="external nofollow noopener noreferrer">greenlet: Lightweight concurrent programming</a>说每个线程都会有独立的主协程：</p>
<blockquote>
<p>Greenlets can be combined with Python threads; in this case, each thread contains an independent “main” greenlet with a tree of sub-greenlets. It is not possible to mix or switch between greenlets belonging to different threads.</p>
</blockquote>
<h3 id="为什么需要LocalProxy和LocalStack"><a href="#为什么需要LocalProxy和LocalStack" class="headerlink" title="为什么需要LocalProxy和LocalStack"></a>为什么需要LocalProxy和LocalStack</h3><p>也许你会有这样的困惑，直接将context作为Local的属性或使context继承Local就可以达到并发请求公用一个全局变量的目的，那为什么需要LocalProxy和LocalStack呢？</p>
<p>使用LocalProxy的目的简单的说就是为访问提供便利。通过传入一个look up函数，可以代理任何感兴趣的对象，比如_request_ctx_stack.top实际返回的是当前请求的context对象，它的request属性对应当前的Request实例，request全局变量就是访问这个属性的代理，除了request还有session代理。</p>
<p>至于request context保存到栈里的目的<a href="http://flask.pocoo.org/docs/0.12/reqcontext/" target="_blank" rel="external nofollow noopener noreferrer">Flask文档:The Request Context</a>是这样解释的：</p>
<blockquote>
<p>Because the request context is internally maintained as a stack you can push and pop multiple times. This is very handy to implement things like internal redirects.</p>
</blockquote>
<p>然而实际上，Flask并没有内部重定向的方法，即一个view在内部访问另一个view，在第一个view中获取第二个view执行的结果。 Flask的redirect函数只不过是给客户端返回30x的状态码，浏览器会发送一个新的请求到指定的地址。redirect函数不会产生一个新的request context，当然也就不需要压栈，因此文档的解释有些不合道理。也许以后会支持这种功能，所以，使用栈来保存上下文能够为以后的功能扩展提供支持。</p>
<p>那么到底什么时候栈上会出现多个request context的情况呢？我无法构造出这种场景，似乎也没人给出过这样的例子。</p>
<p>不得不承认，这部分代码有些过于复杂了，也可能是某些地方我没有考虑到。</p>
<h2 id="请求的生命周期"><a href="#请求的生命周期" class="headerlink" title="请求的生命周期"></a>请求的生命周期</h2><p>为了弄清楚request是如何被赋值的，来了解一下一次请求的生命周期。 一个Flask的实例就是一个wsgi app，对于每个请求wsgi server都会以如下方式调用这个app</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">app(environ, start_response)</span><br></pre></td></tr></table></figure>

<p>因此它的入口就是<strong>call</strong>方法，以该方法为突破口，一个请求的从开始到结束的流程大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ctx = self.request_context(environ)</span><br><span class="line">ctx.push()</span><br><span class="line">    _app_ctx_stack.push(app_ctx)</span><br><span class="line">    _request_ctx_stack.push(self)</span><br><span class="line">response = self.full_dispatch_request(e)</span><br><span class="line">    preprocess_request</span><br><span class="line">        url_value_preprocessors</span><br><span class="line">        before_request_func</span><br><span class="line">    dispatch_request</span><br><span class="line">        self.view_functions[rule.endpoint](**req.view_args)</span><br><span class="line">    process_response</span><br><span class="line">        after_request_func</span><br><span class="line"></span><br><span class="line">ctx.auto_pop(error)</span><br><span class="line">    teardown_request</span><br><span class="line">    _request_ctx_stack.pop()</span><br><span class="line">    teardown_appcontext</span><br><span class="line">    _app_ctx_stack.pop()</span><br></pre></td></tr></table></figure>



<ul>
<li><p>第1步创建了一个RequestContext对象，代表当前请求的上下文，内部包含Request和Session对象；</p>
</li>
<li><p>第2步将该context压栈，同时还创建了application context并压栈，可见每个请求都会有自己的app context，Flask的文档也对此进行了说明：</p>
<blockquote>
<p>The application context is created and destroyed as necessary. It never moves between threads and it will not be shared between requests.</p>
</blockquote>
</li>
<li><p>第3步是调用view function处理请求</p>
</li>
<li><p>第4步是弹出request和app ctx</p>
</li>
</ul>
<p>request全局变量是对_request_ctx_stack的代理，但仅限于读，修改操作则是直接在_request_ctx_stack上完成，同样的还有_app_ctx_stack</p>
<h3 id="以g为延伸了解上下文的Local"><a href="#以g为延伸了解上下文的Local" class="headerlink" title="以g为延伸了解上下文的Local"></a>以g为延伸了解上下文的Local</h3><p><img alt="上下文的Local" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/flask%E4%B8%8A%E4%B8%8B%E6%96%87Local%E5%AF%B9%E8%B1%A1.jpg"></p>
]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
        <tag>request</tag>
        <tag>deep</tag>
      </tags>
  </entry>
  <entry>
    <title>GIL</title>
    <url>/posts/d445bba0/</url>
    <content><![CDATA[<h2 id="GIL-有什么好处？"><a href="#GIL-有什么好处？" class="headerlink" title="GIL 有什么好处？"></a>GIL 有什么好处？</h2><p>简单来说，它在单线程的情况更快，并且在和 C 库结合时更方便，而且不用考虑线程安全问题，这也是早期 Python 最常见的应用场景和优势。</p>
<a id="more"></a>
<h2 id="Python（CPython）为什么存在-GIL？"><a href="#Python（CPython）为什么存在-GIL？" class="headerlink" title="Python（CPython）为什么存在 GIL？"></a>Python（CPython）为什么存在 GIL？</h2><p>根据官方 wiki，CPython 内存管理不是线程安全的，因此需要 GIL 来保证多个原生线程不会并发执行 Python 字节码。</p>
<p>GIL 的存在一直是富有争议的，它导致 CPython 程序无法真正利用现代操作系统的多进程特性。需要注意的是，对于 I/O 图形处理、NumPy 数学计算这样的耗时操作都发生在 GIL 之外，实际上基本不受影响，真正受影响的都是 CPython 字节码的执行，GIL 会导致性能瓶颈的出现。</p>
<p>Python 采用 GIL 而非管理锁出于以下原因：</p>
<ul>
<li>单线程情况下更快。</li>
<li>瓶颈在于 I/O 的多线程环境下更快。</li>
<li>CPU 耗时操作发生在 C 库调用上时更快。</li>
<li>编写 C 扩展会更容易：除非你手动指定，否则不会发生 Python 线程切换的问题。</li>
<li>封装 C 库变得更容易，因为不需要考虑线程安全问题。如果该库不是线程安全的，你只需要保证调用时 GIL 是锁定的。</li>
</ul>
<p>GIL 可以被 C 扩展释放，Python 标准库会在每次 I/O 阻塞结束后释放 GIL，因此 GIL 不会对 I/O 服务器产生很大的性能影响。因此你可以 fork 进程或者创建多线程来创建网络服务器处理异步 I/O，GIL 在这种情况下并没有影响。</p>
<p>很多 C 或者 Fortran 编写的数值解析库（numerical libraries）也可以使用类似的方法释放 GIL。在 C 扩展等待 FFT 完成时，解释器可能正在执行其它线程，GIL 在这种情况下相比精良设计的锁解构更简单也更高效。数值解析的部分都是这样的解构，NumPy 扩展会在不需要时及时释放 GIL。</p>
<p>实际上，在很多时候多线程对于服务器程序来说都不是一个好注意。对于低负载程序，fork 多进程更简单更清晰，对于高负载程序，异步 I/O 或者事件驱动更加高效（比如使用 Twisted 框架）。或许，使用多线程的唯一合理解释在于 Windows 上没有 os.fork 。</p>
<p>总之，只有在使用纯 Python 做 CPU 密集运算时 GIL 会是问题。不过你可以使用多进程或者消息传递（比如 mpi4py）来替代，并得到更清晰的架构。 此外，Python 还有 processing 这个库可供选择，它提供了和 threading 相同的接口，（比如你可以使用 processing.Process 来代替 threading.Thread。）</p>
<p>如果没有 GIL 的话，多线程可以提供更迅速的 GUI 反应，如果 GIL 影响了性能（比如上面讨论的情况），你可以创建一个独立进程并等待它结束。</p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基础知识</title>
    <url>/posts/99a22ef9/</url>
    <content><![CDATA[<h1 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h1><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。</p>
<ul>
<li>URI（Uniform Resource Identifier，统一资源标识符）</li>
<li>URL（Uniform Resource Locator，统一资源定位符）</li>
<li>URN（Uniform Resource Name，统一资源名称）</li>
</ul>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/urlnuri.jpg"> </div><br>

<h2 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h2><h3 id="1-请求报文"><a href="#1-请求报文" class="headerlink" title="1. 请求报文"></a>1. 请求报文</h3><div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/HTTP_RequestMessageExample.png"> </div><br>

<h3 id="2-响应报文"><a href="#2-响应报文" class="headerlink" title="2. 响应报文"></a>2. 响应报文</h3><div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/HTTP_ResponseMessageExample.png"> </div><br>

<h1 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h1><p>客户端发送的  <strong>请求报文</strong>  第一行为请求行，包含了方法字段。</p>
<h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><blockquote>
<p>获取资源</p>
</blockquote>
<p>当前网络请求中，绝大部分使用的是 GET 方法。</p>
<h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><blockquote>
<p>获取报文首部</p>
</blockquote>
<p>和 GET 方法一样，但是不返回报文实体主体部分。</p>
<p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p>
<h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><blockquote>
<p>传输实体主体</p>
</blockquote>
<p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p>
<p>更多 POST 与 GET 的比较请见第八章。</p>
<h2 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h2><blockquote>
<p>上传文件</p>
</blockquote>
<p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>New File<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h2><blockquote>
<p>对资源进行部分修改</p>
</blockquote>
<p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></table></figure>

<h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><blockquote>
<p>删除文件</p>
</blockquote>
<p>与 PUT 功能相反，并且同样不带验证机制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><blockquote>
<p>查询支持的方法</p>
</blockquote>
<p>查询指定的 URL 能够支持的方法。</p>
<p>会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。</p>
<h2 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h2><blockquote>
<p>要求在与代理服务器通信时建立隧道</p>
</blockquote>
<p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></table></figure>

<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/dc00f70e-c5c8-4d20-baf1-2d70014a97e3.jpg"> </div><br>

<h2 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h2><blockquote>
<p>追踪路径</p>
</blockquote>
<p>服务器会将通信路径返回给客户端。</p>
<p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p>
<p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p>
<h1 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h1><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">类别</th>
<th align="center">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1XX</td>
<td align="center">Informational（信息性状态码）</td>
<td align="center">接收的请求正在处理</td>
</tr>
<tr>
<td align="center">2XX</td>
<td align="center">Success（成功状态码）</td>
<td align="center">请求正常处理完毕</td>
</tr>
<tr>
<td align="center">3XX</td>
<td align="center">Redirection（重定向状态码）</td>
<td align="center">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="center">4XX</td>
<td align="center">Client Error（客户端错误状态码）</td>
<td align="center">服务器无法处理请求</td>
</tr>
<tr>
<td align="center">5XX</td>
<td align="center">Server Error（服务器错误状态码）</td>
<td align="center">服务器处理请求出错</td>
</tr>
</tbody></table>
<h2 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h2><ul>
<li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><p><strong>200 OK</strong></p>
</li>
<li><p><strong>204 No Content</strong> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li><p><strong>206 Partial Content</strong> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><p><strong>301 Moved Permanently</strong> ：永久性重定向</p>
</li>
<li><p><strong>302 Found</strong> ：临时性重定向</p>
</li>
<li><p><strong>303 See Other</strong> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li><p>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</p>
</li>
<li><p><strong>304 Not Modified</strong> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li><p><strong>307 Temporary Redirect</strong> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ul>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><p><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</p>
</li>
<li><p><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li><p><strong>403 Forbidden</strong> ：请求被拒绝。</p>
</li>
<li><p><strong>404 Not Found</strong></p>
</li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li><p><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</p>
</li>
<li><p><strong>503 Service Unavailable</strong> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ul>
<h1 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h1><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p>
<p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p>
<h2 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Cache-Control</td>
<td align="center">控制缓存的行为</td>
</tr>
<tr>
<td align="center">Connection</td>
<td align="center">控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">创建报文的日期时间</td>
</tr>
<tr>
<td align="center">Pragma</td>
<td align="center">报文指令</td>
</tr>
<tr>
<td align="center">Trailer</td>
<td align="center">报文末端的首部一览</td>
</tr>
<tr>
<td align="center">Transfer-Encoding</td>
<td align="center">指定报文主体的传输编码方式</td>
</tr>
<tr>
<td align="center">Upgrade</td>
<td align="center">升级为其他协议</td>
</tr>
<tr>
<td align="center">Via</td>
<td align="center">代理服务器的相关信息</td>
</tr>
<tr>
<td align="center">Warning</td>
<td align="center">错误通知</td>
</tr>
</tbody></table>
<h2 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept</td>
<td align="center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td align="center">Accept-Charset</td>
<td align="center">优先的字符集</td>
</tr>
<tr>
<td align="center">Accept-Encoding</td>
<td align="center">优先的内容编码</td>
</tr>
<tr>
<td align="center">Accept-Language</td>
<td align="center">优先的语言（自然语言）</td>
</tr>
<tr>
<td align="center">Authorization</td>
<td align="center">Web 认证信息</td>
</tr>
<tr>
<td align="center">Expect</td>
<td align="center">期待服务器的特定行为</td>
</tr>
<tr>
<td align="center">From</td>
<td align="center">用户的电子邮箱地址</td>
</tr>
<tr>
<td align="center">Host</td>
<td align="center">请求资源所在服务器</td>
</tr>
<tr>
<td align="center">If-Match</td>
<td align="center">比较实体标记（ETag）</td>
</tr>
<tr>
<td align="center">If-Modified-Since</td>
<td align="center">比较资源的更新时间</td>
</tr>
<tr>
<td align="center">If-None-Match</td>
<td align="center">比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td align="center">If-Range</td>
<td align="center">资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td align="center">If-Unmodified-Since</td>
<td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td align="center">Max-Forwards</td>
<td align="center">最大传输逐跳数</td>
</tr>
<tr>
<td align="center">Proxy-Authorization</td>
<td align="center">代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td align="center">Range</td>
<td align="center">实体的字节范围请求</td>
</tr>
<tr>
<td align="center">Referer</td>
<td align="center">对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td align="center">TE</td>
<td align="center">传输编码的优先级</td>
</tr>
<tr>
<td align="center">User-Agent</td>
<td align="center">HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h2 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Accept-Ranges</td>
<td align="center">是否接受字节范围请求</td>
</tr>
<tr>
<td align="center">Age</td>
<td align="center">推算资源创建经过时间</td>
</tr>
<tr>
<td align="center">ETag</td>
<td align="center">资源的匹配信息</td>
</tr>
<tr>
<td align="center">Location</td>
<td align="center">令客户端重定向至指定 URI</td>
</tr>
<tr>
<td align="center">Proxy-Authenticate</td>
<td align="center">代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td align="center">Retry-After</td>
<td align="center">对再次发起请求的时机要求</td>
</tr>
<tr>
<td align="center">Server</td>
<td align="center">HTTP 服务器的安装信息</td>
</tr>
<tr>
<td align="center">Vary</td>
<td align="center">代理服务器缓存的管理信息</td>
</tr>
<tr>
<td align="center">WWW-Authenticate</td>
<td align="center">服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h2 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><table>
<thead>
<tr>
<th align="center">首部字段名</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Allow</td>
<td align="center">资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">实体主体适用的编码方式</td>
</tr>
<tr>
<td align="center">Content-Language</td>
<td align="center">实体主体的自然语言</td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">实体主体的大小</td>
</tr>
<tr>
<td align="center">Content-Location</td>
<td align="center">替代对应资源的 URI</td>
</tr>
<tr>
<td align="center">Content-MD5</td>
<td align="center">实体主体的报文摘要</td>
</tr>
<tr>
<td align="center">Content-Range</td>
<td align="center">实体主体的位置范围</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">实体主体的媒体类型</td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">实体主体过期的日期时间</td>
</tr>
<tr>
<td align="center">Last-Modified</td>
<td align="center">资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h1 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB。</p>
<h3 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h3><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h3 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h3><ul>
<li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li>
<li>持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<h3 id="4-JavaScript-获取-Cookie"><a href="#4-JavaScript-获取-Cookie" class="headerlink" title="4. JavaScript 获取 Cookie"></a>4. JavaScript 获取 Cookie</h3><p>通过 <code>Document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></table></figure>

<h3 id="5-Secure-和-HttpOnly"><a href="#5-Secure-和-HttpOnly" class="headerlink" title="5. Secure 和 HttpOnly"></a>5. Secure 和 HttpOnly</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p>
<p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>Document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<h3 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p>
<p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p>
<ul>
<li>/docs</li>
<li>/docs/Web/</li>
<li>/docs/Web/HTTP</li>
</ul>
<h3 id="7-Session"><a href="#7-Session" class="headerlink" title="7. Session"></a>7. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码；</li>
<li>如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li>
</ul>
<p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
<h3 id="8-浏览器禁用-Cookie"><a href="#8-浏览器禁用-Cookie" class="headerlink" title="8. 浏览器禁用 Cookie"></a>8. 浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p>
<h3 id="9-Cookie-与-Session-选择"><a href="#9-Cookie-与-Session-选择" class="headerlink" title="9. Cookie 与 Session 选择"></a>9. Cookie 与 Session 选择</h3><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h3><ul>
<li>缓解服务器压力；</li>
<li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li>
</ul>
<h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><ul>
<li>让代理服务器进行缓存；</li>
<li>让客户端浏览器进行缓存。</li>
</ul>
<h3 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p>
<p><strong>（一）禁止进行缓存</strong></p>
<p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></table></figure>

<p><strong>（二）强制确认缓存</strong></p>
<p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></table></figure>

<p><strong>（三）私有缓存和公共缓存</strong></p>
<p>private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></table></figure>

<p>public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></table></figure>

<p><strong>（四）缓存过期机制</strong></p>
<p>max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p>
<p>max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></table></figure>

<p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p>
<ul>
<li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li>
<li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure>

<h3 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure>

<p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></table></figure>

<p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/HTTP1_x_Connections.png"> </div><br>

<h3 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p>
<ul>
<li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li>
<li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li>
</ul>
<h3 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。</p>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p>
<h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h3><p><strong>（一）服务端驱动型</strong></p>
<p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。</p>
<p>它存在以下问题：</p>
<ul>
<li>服务器很难知道客户端浏览器的全部信息；</li>
<li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li>
<li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li>
</ul>
<p><strong>（二）代理驱动型</strong></p>
<p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p>
<h3 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure>

<p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p>
<p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p>
<h2 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h2><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p>
<p>常用的内容编码有：gzip、compress、deflate、identity。</p>
<p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应的 Vary 首部至少要包含 Content-Encoding。</p>
<h2 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p>
<h3 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></table></figure>

<p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></table></figure>

<h3 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h3 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3. 响应状态码"></a>3. 响应状态码</h3><ul>
<li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li>
<li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li>
<li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li>
</ul>
<h2 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h2><p>Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。</p>
<h2 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p>
<p>例如，上传多个表单时可以使用如下方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure>

<h2 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p>
<h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><h3 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p>
<p>使用代理的主要目的是：</p>
<ul>
<li>缓存</li>
<li>负载均衡</li>
<li>网络访问控制</li>
<li>访问日志记录</li>
</ul>
<p>代理服务器分为正向代理和反向代理两种：</p>
<ul>
<li>用户察觉得到正向代理的存在。</li>
</ul>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/a314bb79-5b18-4e63-a976-3448bffa6f1b.png"> </div><br>

<ul>
<li>而反向代理一般位于内部网络中，用户察觉不到。</li>
</ul>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/2d09a847-b854-439c-9198-b29c65810944.png"> </div><br>

<h3 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p>
<h3 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<h1 id="六、HTTPs"><a href="#六、HTTPs" class="headerlink" title="六、HTTPs"></a>六、HTTPs</h1><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听；</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li>
<li>无法证明报文的完整性，报文有可能遭篡改。</li>
</ul>
<p>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。</p>
<p>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/ssl-offloading.jpg"> </div><br>

<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p>
<ul>
<li>优点：运算速度快；</li>
<li>缺点：无法安全地将密钥传输给通信方。</li>
</ul>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png"> </div><br>

<h3 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p>
<p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p>
<p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p>
<ul>
<li>优点：可以更安全地将公开密钥传输给通信发送方；</li>
<li>缺点：运算速度慢。</li>
</ul>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png"> </div><br>

<h3 id="3-HTTPs-采用的加密方式"><a href="#3-HTTPs-采用的加密方式" class="headerlink" title="3. HTTPs 采用的加密方式"></a>3. HTTPs 采用的加密方式</h3><p>HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/How-HTTPS-Works.png"> </div><br>

<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p>
<p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p>
<p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p>
<p>进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p>
<p>通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。</p>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/2017-06-11-ca.png"> </div><br>

<h2 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p>
<p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p>
<p>HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p>
<h2 id="HTTPs-的缺点"><a href="#HTTPs-的缺点" class="headerlink" title="HTTPs 的缺点"></a>HTTPs 的缺点</h2><ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用。</li>
</ul>
<h2 id="配置-HTTPs"><a href="#配置-HTTPs" class="headerlink" title="配置 HTTPs"></a>配置 HTTPs</h2><p><a href="https://aotu.io/notes/2016/08/16/nginx-https/index.html" target="_blank" rel="external nofollow noopener noreferrer">Nginx 配置 HTTPS 服务器</a></p>
<h1 id="七、HTTP-2-0"><a href="#七、HTTP-2-0" class="headerlink" title="七、HTTP/2.0"></a>七、HTTP/2.0</h1><h2 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h2><p> HTTP/1.x 实现简单是以牺牲性能为代价的：</p>
<ul>
<li>客户端需要使用多个连接才能实现并发和缩短延迟；</li>
<li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li>
<li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li>
</ul>
<h2 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p>
<div align="center"> <img width="400" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/86e6a91d-a285-447a-9345-c5484b8d0c47.png"> </div><br>

<p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p>
<ul>
<li>一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li>
<li>消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。</li>
<li>帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li>
</ul>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/af198da1-2480-4043-b07f-a3b91a88b815.png"> </div><br>

<h2 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/e3f1657c-80fc-4dfa-9643-bf51abd201c6.png"> </div><br>

<h2 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p>
<p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/_u4E0B_u8F7D.png"> </div><br>

<h1 id="八、GET-和-POST-比较"><a href="#八、GET-和-POST-比较" class="headerlink" title="八、GET 和 POST 比较"></a>八、GET 和 POST 比较</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p>
<p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参考支持标准字符集。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;test&#x2F;demo_form.asp?name1&#x3D;value1&amp;name2&#x3D;value2 HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;test&#x2F;demo_form.asp HTTP&#x2F;1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1&#x3D;value1&amp;name2&#x3D;value2</span><br></pre></td></tr></table></figure>

<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p>
<p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p>
<p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p>
<p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p>
<h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
<p>所有的安全方法也都是幂等的。</p>
<p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p>
<p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br><span class="line">GET &#x2F;pageX HTTP&#x2F;1.1</span><br></pre></td></tr></table></figure>

<p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST &#x2F;add_row HTTP&#x2F;1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></table></figure>

<p>DELETE /idX/delete HTTP/1.1 是幂等的，即便不同的请求接收到的状态码不一样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1   -&gt; Returns 404</span><br></pre></td></tr></table></figure>

<h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li>
<li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li>
</ul>
<h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p>
<blockquote>
<p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p>
</blockquote>
<ul>
<li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送。</li>
</ul>
<h1 id="九、HTTP-1-0-与-HTTP-1-1-的区别"><a href="#九、HTTP-1-0-与-HTTP-1-1-的区别" class="headerlink" title="九、HTTP/1.0 与 HTTP/1.1 的区别"></a>九、HTTP/1.0 与 HTTP/1.1 的区别</h1><blockquote>
<p>详细内容请见上文</p>
</blockquote>
<ul>
<li><p>HTTP/1.1 默认是长连接</p>
</li>
<li><p>HTTP/1.1 支持管线化处理</p>
</li>
<li><p>HTTP/1.1 支持同时打开多个 TCP 连接</p>
</li>
<li><p>HTTP/1.1 支持虚拟主机</p>
</li>
<li><p>HTTP/1.1 新增状态码 100</p>
</li>
<li><p>HTTP/1.1 支持分块传输编码</p>
</li>
<li><p>HTTP/1.1 新增缓存处理指令 max-age</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP" target="_blank" rel="external nofollow noopener noreferrer">MDN : HTTP</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2 简介</a></li>
<li><a href="http://php.net/manual/zh/function.htmlspecialchars.php" target="_blank" rel="external nofollow noopener noreferrer">htmlspecialchars</a></li>
<li><a href="http://java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java" target="_blank" rel="external nofollow noopener noreferrer">Difference between file URI and URL in java</a></li>
<li><a href="https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement" target="_blank" rel="external nofollow noopener noreferrer">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li>
<li><a href="https://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external nofollow noopener noreferrer">浅谈 HTTP 中 Get 与 Post 的区别</a></li>
<li><a href="https://www.webdancers.com/are-http-and-www-necesary/" target="_blank" rel="external nofollow noopener noreferrer">Are http:// and www really necessary?</a></li>
<li><a href="https://www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html" target="_blank" rel="external nofollow noopener noreferrer">HTTP (HyperText Transfer Protocol)</a></li>
<li><a href="https://www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/" target="_blank" rel="external nofollow noopener noreferrer">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li>
<li><a href="http://en.wikipedia.org/wiki/File:HTTP_persistent_connection.svg" target="_blank" rel="external nofollow noopener noreferrer">File:HTTP persistent connection.svg</a></li>
<li><a href="https://en.wikipedia.org/wiki/Proxy_server" target="_blank" rel="external nofollow noopener noreferrer">Proxy server</a></li>
<li><a href="https://www.x-cart.com/blog/what-is-https-and-ssl.html" target="_blank" rel="external nofollow noopener noreferrer">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li>
<li><a href="https://securebox.comodo.com/ssl-sniffing/ssl-offloading/" target="_blank" rel="external nofollow noopener noreferrer">What is SSL Offloading?</a></li>
<li><a href="https://docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html" target="_blank" rel="external nofollow noopener noreferrer">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li>
<li><a href="https://www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication" target="_blank" rel="external nofollow noopener noreferrer">An Introduction to Mutual SSL Authentication</a></li>
<li><a href="https://danielmiessler.com/study/url-uri/" target="_blank" rel="external nofollow noopener noreferrer">The Difference Between URLs and URIs</a></li>
<li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e#comment" target="_blank" rel="external nofollow noopener noreferrer">Cookie 与 Session 的区别</a></li>
<li><a href="https://www.zhihu.com/question/19786827" target="_blank" rel="external nofollow noopener noreferrer">COOKIE 和 SESSION 有什么区别</a></li>
<li><a href="https://harttle.land/2015/08/10/cookie-session.html" target="_blank" rel="external nofollow noopener noreferrer">Cookie/Session 的机制与安全</a></li>
<li><a href="https://shijianan.com/2017/06/11/https/" target="_blank" rel="external nofollow noopener noreferrer">HTTPS 证书原理</a></li>
<li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn" target="_blank" rel="external nofollow noopener noreferrer">What is the difference between a URI, a URL and a URN?</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external nofollow noopener noreferrer">XMLHttpRequest</a></li>
<li><a href="https://blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/" target="_blank" rel="external nofollow noopener noreferrer">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li>
<li><a href="https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences" target="_blank" rel="external nofollow noopener noreferrer">Symmetric vs. Asymmetric Encryption – What are differences?</a></li>
<li><a href="https://www.kancloud.cn/digest/web-performance-http2" target="_blank" rel="external nofollow noopener noreferrer">Web 性能优化与 HTTP/2</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="external nofollow noopener noreferrer">HTTP/2 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Note-Of-Python3-CookBook</title>
    <url>/posts/887a2def/</url>
    <content><![CDATA[<h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ol>
<li><p><code>*</code>的巧妙使用方法，运用在所有可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比赛求分数，去掉最大值和最小值求平均数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = sorted(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l, *m, h = b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(m)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line">&gt;&gt;&gt; avg = sum(m)/len(m)</span><br><span class="line"><span class="number">7.0</span></span><br></pre></td></tr></table></figure>

<p>ps.  <code>_</code>一般用于准备垃圾数据，在python终端中也代表上一个你使用的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>record = (<span class="string">'ACME'</span>, <span class="number">50</span>, <span class="number">123.45</span>, (<span class="number">12</span>, <span class="number">18</span>, <span class="number">2012</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name, *_, (*_, year) = record</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name</span><br><span class="line"><span class="string">'ACME'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>year</span><br><span class="line"><span class="number">2012</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只保留n条记录：<code>collections.deque</code>不仅仅拥有列表的属性，还可以对表头进行增删，即<code>appendleft</code>和<code>popleft</code>，更可以指定长度，当满了且新增数据时，会FIFO，删除最先进来的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">deque([iterable[, maxlen]]) --&gt; deque object</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    A list-like sequence optimized for data accesses near its endpoints.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(lines, pattern, history=<span class="number">5</span>)</span>:</span></span><br><span class="line">    previous_lines = deque(maxlen=history)	<span class="comment"># 2</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:	<span class="comment"># 3	11</span></span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:	<span class="comment"># 4</span></span><br><span class="line">            <span class="keyword">yield</span> line, previous_lines	<span class="comment"># 5</span></span><br><span class="line">        previous_lines.append(line)	<span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Example use on a file</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'demo.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line, prevlines <span class="keyword">in</span> search(f, <span class="string">'python'</span>, <span class="number">5</span>):	<span class="comment"># 1</span></span><br><span class="line">            <span class="keyword">for</span> pline <span class="keyword">in</span> prevlines:	<span class="comment"># 6</span></span><br><span class="line">                print(pline, end=<span class="string">''</span>)  <span class="comment"># 7(第一次没有)</span></span><br><span class="line">            print(line, end=<span class="string">''</span>)	<span class="comment"># 8</span></span><br><span class="line">            print(<span class="string">'-'</span> * <span class="number">20</span>)	<span class="comment"># 9</span></span><br></pre></td></tr></table></figure>

<p>另外一些常用的<code>collections</code>的功能模块有<code>defaultdict</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd = defaultdict(<span class="keyword">lambda</span>: <span class="string">'N/A'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dd[<span class="string">'key'</span>]</span><br><span class="line"><span class="string">'N/A'</span></span><br></pre></td></tr></table></figure>

<p>还有<code>OrderedDict</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="comment"># dict的Key是无序的</span></span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od = OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>od <span class="comment"># OrderedDict的Key是有序的</span></span><br><span class="line">OrderedDict([(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>), (<span class="string">'c'</span>, <span class="number">3</span>)])</span><br></pre></td></tr></table></figure>

<p>但是他的KEY顺序是<strong>插入顺序</strong>，所以还可以做成一个FIFO的有限长度队列出来</p>
<p><code>OrderedDict</code> 内部维护着一个根据键插入顺序排序的双向链表。每次当一个新的元素插入进来的时候， 它会被放到链表的尾部。对于一个已经存在的键的重复赋值不会改变键的顺序。</p>
<p><strong>需要注意的是</strong>，一个 <code>OrderedDict</code> 的大小是一个普通字典的<strong>两倍</strong>，因为它内部维护着另外一个链表。 所以如果你要构建一个需要大量 <code>OrderedDict</code> 实例的数据结构的时候（比如读取 100,000 行 CSV 数据到一个 <code>OrderedDict</code> 列表中去）， 那么你就得仔细权衡一下是否使用 <code>OrderedDict</code> 带来的好处要大过额外内存消耗的影响。</p>
</li>
<li><p>查找最大或最小的 N 个元素， <code>heapq</code>模块两个方法<code>nlargest( )</code>和<code>nsmallest( )</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">23</span>, <span class="number">7</span>, <span class="number">-4</span>, <span class="number">18</span>, <span class="number">23</span>, <span class="number">42</span>, <span class="number">37</span>, <span class="number">2</span>]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, nums)) <span class="comment"># Prints [42, 37, 23]</span></span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, nums)) <span class="comment"># Prints [-4, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p>复杂用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">portfolio = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">cheap = heapq.nsmallest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br><span class="line">expensive = heapq.nlargest(<span class="number">3</span>, portfolio, key=<span class="keyword">lambda</span> s: s[<span class="string">'price'</span>])</span><br></pre></td></tr></table></figure>

<p>迭代portfolio，每一条作为参数传入lambda，获取它的price作为nsmallest的比较参数。</p>
<p>实现原理是，将集合数据进行<code>堆排序</code>并放入一个列表</p>
<p>堆数据结构最重要的特征是 <code>heap[0]</code> 永远是最小的元素。并且剩余的元素可以很容易的通过调用 <code>heapq.heappop()</code> 方法得到， 该方法会先将第一个元素弹出来，然后用下一个最小的元素来取代被弹出元素（这种操作时间复杂度仅仅是 O(log N)，N 是堆大小）。</p>
<p><strong>当要查找的元素个数相对比较小的时候</strong>，函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 是很合适的。 <strong>如果你仅仅想查找唯一的最小或最大（N=1）的元素的话</strong>，那么使用 <code>min()</code> 和 <code>max()</code> 函数会更快些。 类似的，<strong>如果 N 的大小和集合大小接近的时候</strong>，通常先排序这个集合然后再使用切片操作会更快点 （ <code>sorted(items)[:N]</code> 或者是 <code>sorted(items)[-N:]</code> ）。 需要在正确场合使用函数 <code>nlargest()</code> 和 <code>nsmallest()</code> 才能发挥它们的优势 （如果 N 快接近集合大小了，那么使用排序操作会更好些）。</p>
<p>用heapq的堆排序特性，定义一个优先级队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._queue = []</span><br><span class="line">        self._index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item, priority)</span>:</span></span><br><span class="line">        heapq.heappush(self._queue, (-priority, self._index, item))</span><br><span class="line">        self._index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(self._queue)[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._queue</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Item(&#123;!r&#125;)'</span>.format(self.name)</span><br><span class="line"></span><br><span class="line">q = PriorityQueue()</span><br><span class="line">q.push(Item(<span class="string">'foo'</span>), <span class="number">1</span>)</span><br><span class="line">q.push(Item(<span class="string">'bar'</span>), <span class="number">5</span>)</span><br><span class="line">q.push(Item(<span class="string">'spam'</span>), <span class="number">4</span>)</span><br><span class="line">q.push(Item(<span class="string">'grok'</span>), <span class="number">1</span>)</span><br><span class="line">print(q.queue())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    print(q.pop())</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">[(-5, 1, Item('bar')), (-1, 0, Item('foo')), (-4, 2, Item('spam')), (-1, 3, Item('grok'))]</span></span><br><span class="line"><span class="string">Item('bar')</span></span><br><span class="line"><span class="string">Item('spam')</span></span><br><span class="line"><span class="string">Item('foo')</span></span><br><span class="line"><span class="string">Item('grok')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<p>需注意：此处队列不是线程安全的，定义<code>index</code>用于同等优先级按添加顺序排序</p>
</li>
<li><p>dict的key是可以作为一个集合来进行运算的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'x'</span> : <span class="number">1</span>, <span class="string">'y'</span> : <span class="number">2</span>, <span class="string">'z'</span> : <span class="number">3</span>&#125;</span><br><span class="line">b = &#123;<span class="string">'w'</span> : <span class="number">10</span>, <span class="string">'x'</span> : <span class="number">11</span>, <span class="string">'y'</span> : <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment"># Find keys in common</span></span><br><span class="line">a.keys() &amp; b.keys() <span class="comment"># &#123; 'x', 'y' &#125;</span></span><br><span class="line"><span class="comment"># Find keys in a that are not in b</span></span><br><span class="line">a.keys() - b.keys() <span class="comment"># &#123; 'z' &#125;</span></span><br><span class="line"><span class="comment"># Find (key,value) pairs in common</span></span><br><span class="line">a.items() &amp; b.items() <span class="comment"># &#123; ('y', 2) &#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成器和匿名函数lambda的一个运用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保持元素顺序的同时消除重复的值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe</span><span class="params">(items)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(item)</span><br><span class="line">    print(seen)</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">print(list(dedupe(a)))</span><br><span class="line"><span class="comment"># [1, 5, 2, 9, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进阶</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dedupe_1</span><span class="params">(items, key=None)</span>:</span></span><br><span class="line">    seen = set()</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        输入&#123;'x': 1, 'y': 2&#125;</span></span><br><span class="line"><span class="string">        返回(1, 2)元组</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        val = item <span class="keyword">if</span> key <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> key(item)</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line">            seen.add(val)</span><br><span class="line">    print(seen)</span><br><span class="line"></span><br><span class="line">b = [&#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">3</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">4</span>&#125;]</span><br><span class="line">print(list(dedupe_1(b, key=<span class="keyword">lambda</span> d: (d[<span class="string">'x'</span>], d[<span class="string">'y'</span>]))))</span><br><span class="line"><span class="comment"># [&#123;'x': 1, 'y': 2&#125;, &#123;'x': 1, 'y': 3&#125;, &#123;'x': 2, 'y': 4&#125;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切片对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.slice(<span class="number">5</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.start</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.stop</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.step</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'HelloWorld'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.indices(len(s))</span><br><span class="line">(<span class="number">5</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(*a.indices(len(s))):</span><br><span class="line"><span class="meta">... </span>    print(s[i])</span><br><span class="line">...</span><br><span class="line">W</span><br><span class="line">r</span><br><span class="line">d</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>你还可以通过调用切片的 <code>indices(size)</code> 方法将它映射到一个已知大小的序列上。 这个方法返回一个三元组 <code>(start, stop, step)</code> ，所有的值都会被缩小，直到适合这个已知序列的边界为止。 这样，使用的时就不会出现 <code>IndexError</code> 异常。</p>
</li>
<li><p>序列中重复次数最多的元素<code>hashable</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">word_counts = Counter(words)</span><br><span class="line"><span class="comment"># 出现频率最高的3个单词</span></span><br><span class="line">top_three = word_counts.most_common(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过某个关键字排序</p>
<p>通常情况下对字典列表排序或者最大值最小值会使用lambda：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows = [</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'Brian'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1003</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'David'</span>, <span class="string">'lname'</span>: <span class="string">'Beazley'</span>, <span class="string">'uid'</span>: <span class="number">1002</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'John'</span>, <span class="string">'lname'</span>: <span class="string">'Cleese'</span>, <span class="string">'uid'</span>: <span class="number">1001</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'fname'</span>: <span class="string">'Big'</span>, <span class="string">'lname'</span>: <span class="string">'Jones'</span>, <span class="string">'uid'</span>: <span class="number">1004</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_fname = sorted(rows, key=<span class="keyword">lambda</span> r: r[<span class="string">'fname'</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(rows, key=<span class="keyword">lambda</span> r: r[<span class="string">'uid'</span>])</span><br></pre></td></tr></table></figure>

<p>但是有一个性能更好的方法，通过使用 <code>operator</code> 模块的 <code>itemgetter</code> 函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rows_by_fname = sorted(rows, key=itemgetter(<span class="string">'fname'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min(rows, key=itemgetter(<span class="string">'uid'</span>))</span><br></pre></td></tr></table></figure>

<p>当需要对一个不支持原生比较的对象排序时，可以使用<code>operator</code> 模块的 <code>attrgetter</code>函数，原理同上，可以很好地代替lambda，且运用范围更广。</p>
</li>
<li><p>通过某个字段分组</p>
<p>你有一个字典或者实例的序列，然后你想根据某个特定的字段比如 <code>date</code> 来分组迭代访问，<code>itertools.groupby()</code> 函数对于这样的数据分组操作非常实用。</p>
<p>结合上面函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> groupby</span><br><span class="line"></span><br><span class="line">rows = [</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5412 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5148 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5800 E 58TH'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'2122 N CLARK'</span>, <span class="string">'date'</span>: <span class="string">'07/03/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'5645 N RAVENSWOOD'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'1060 W ADDISON'</span>, <span class="string">'date'</span>: <span class="string">'07/02/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'4801 N BROADWAY'</span>, <span class="string">'date'</span>: <span class="string">'07/01/2012'</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'address'</span>: <span class="string">'1039 W GRANVILLE'</span>, <span class="string">'date'</span>: <span class="string">'07/04/2012'</span>&#125;,</span><br><span class="line">]</span><br><span class="line"><span class="comment"># Sort by the desired field first</span></span><br><span class="line">rows.sort(key=itemgetter(<span class="string">'date'</span>))</span><br><span class="line"><span class="comment"># Iterate in groups</span></span><br><span class="line"><span class="keyword">for</span> date, items <span class="keyword">in</span> groupby(rows, key=itemgetter(<span class="string">'date'</span>)):</span><br><span class="line">    print(date)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">        print(<span class="string">' '</span>, i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>过滤元素，可以使用列表推导式<code>[n for n in mylist if n &gt; 0]</code>，当数据源可能比较大时，为了内存需要使用生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos = (n <span class="keyword">for</span> n ib mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1006a0eb0</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> pos:</span><br><span class="line"><span class="meta">... </span>print(x)</span><br></pre></td></tr></table></figure>

<p>推导式也可以进行一些简单的数据转换等，不仅仅是丢弃数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> math</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[math.sqrt(n) <span class="keyword">for</span> n <span class="keyword">in</span> mylist <span class="keyword">if</span> n &gt; <span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[n <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> n <span class="keyword">in</span> mylist]</span><br></pre></td></tr></table></figure>

<p>但是当过滤规则较复杂时，包括一些异常处理等，则使用内置函数<code>filter( )</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'-3'</span>, <span class="string">'-'</span>, <span class="string">'4'</span>, <span class="string">'N/A'</span>, <span class="string">'5'</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_int</span><span class="params">(val)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = int(val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">ivals = list(filter(is_int, values))</span><br><span class="line">print(ivals)</span><br><span class="line"><span class="comment"># Outputs ['1', '2', '-3', '4', '5']</span></span><br></pre></td></tr></table></figure>

<p>额外还有一个 <code>itertools.compress( )</code> 值得关注，需要用另外一个相关联的序列来过滤某个序列的时候比较好运用。</p>
</li>
<li><p>字典推导式比较快</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">'ACME'</span>: <span class="number">45.23</span>,</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">612.78</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">205.55</span>,</span><br><span class="line">    <span class="string">'HPQ'</span>: <span class="number">37.20</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">10.75</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 这个方式比下面的快，且易于阅读</span></span><br><span class="line">p1 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>&#125;</span><br><span class="line">p1_1 = dict((key, value) <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">tech_names = &#123;<span class="string">'AAPL'</span>, <span class="string">'IBM'</span>, <span class="string">'HPQ'</span>, <span class="string">'MSFT'</span>&#125;</span><br><span class="line">p2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> key <span class="keyword">in</span> tech_names&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="测试、调试和异常"><a href="#测试、调试和异常" class="headerlink" title="测试、调试和异常"></a>测试、调试和异常</h3><ol>
<li><p>捕获异常，自定义异常或者异常信息显示最好加上原来捕获的异常情况，具体用法是<code>raise from</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            int(<span class="string">'N/A'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span> RuntimeError(<span class="string">'A parsing error occurred'</span>) <span class="keyword">from</span> e</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> example</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'N/A'</span></span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> example</span><br><span class="line">RuntimeError: A parsing error occurred</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 或者这样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">try</span>:</span><br><span class="line"><span class="meta">... </span>            int(<span class="string">'N/A'</span>)</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">except</span> ValueError:</span><br><span class="line"><span class="meta">... </span>            print(<span class="string">"Didn't work"</span>)</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">raise</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example()</span><br><span class="line">Didn<span class="string">'t work</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 3, in example</span></span><br><span class="line"><span class="string">ValueError: invalid literal for int() with base 10: '</span>N/A<span class="string">'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>性能测试</p>
<p>可以直接测试整个文件的运行情况，使用<code>time  python3  foo.py</code>或者<code>python3  -m  cProfile  foo.py</code>，前者过于简洁，后者过于详细，而且一般我们都是针对于少数函数或者代码块来检测性能</p>
<p>装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># thistime.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">thistime</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        r = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">'&#123;&#125;.&#123;&#125; : &#123;&#125;'</span>.format(func.__module__, func.__name__, end - start))</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>@thistime</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">10000000</span>)</span><br><span class="line">__main__.countdown : <span class="number">0.803001880645752</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   代码块</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeblock</span><span class="params">(label)</span>:</span></span><br><span class="line">    start = time.perf_counter()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">'&#123;&#125; : &#123;&#125;'</span>.format(label, end - start))</span><br></pre></td></tr></table></figure>

   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> timeblock(<span class="string">'counting'</span>):</span><br><span class="line"><span class="meta">... </span>    n = <span class="number">10000000</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line"><span class="meta">... </span>            n -= <span class="number">1</span></span><br><span class="line">...</span><br><span class="line">counting : <span class="number">1.5551159381866455</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>



<p>   极小代码片段</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">'math.sqrt(2)'</span>, <span class="string">'import math'</span>)</span><br><span class="line"><span class="number">0.1432319980012835</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>timeit(<span class="string">'sqrt(2)'</span>, <span class="string">'from math import sqrt'</span>)</span><br><span class="line"><span class="number">0.10836604500218527</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>   需要提醒的是，<code>time.perf_counter( )</code>会是给定平台上最高精度的计时值，但仍是时钟值，所以可以更换为<code>time.process_time( )</code></p>
<ol start="3">
<li><p>加速程序运行</p>
<ol>
<li><p><strong>将代码运行在函数中</strong>，一般提升15%-30%的性能，这是因为全局变量和局部变量</p>
</li>
<li><p><strong>尽可能去掉属性访问</strong>，每一次使用<code>.</code>来访问属性会带来额外的开销，会触发特定的<code>__getattribute__( )</code>和<code>__getattr__( )</code>，会进行字典操作，所以需要使用<code>from  modele  import  name</code>来导入，原来代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> TimeUtils <span class="keyword">import</span> timeblock  <span class="comment"># 上面自定义的计时器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_roots</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        result.append(math.sqrt(n))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> timeblock(<span class="string">'count'</span>):</span><br><span class="line">    nums = range(<span class="number">1000000</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        r = compute_roots(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">count : <span class="number">39.508564</span></span><br></pre></td></tr></table></figure>

<p>修改为下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">from</span> TimeUtils <span class="keyword">import</span> timeblock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_roots</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    result_append = result.append</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        result_append(sqrt(n))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> timeblock(<span class="string">'count'</span>):</span><br><span class="line">    nums = range(<span class="number">1000000</span>)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        r = compute_roots(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">count : <span class="number">26.378584</span></span><br></pre></td></tr></table></figure>

<p>这么大的差距缘由在于大量重复调用，所以遇到这种情况需要调优</p>
</li>
</ol>
</li>
<li><p><strong>局部变量</strong>，承接上一节，修改<code>compute_roots</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_roots</span><span class="params">(nums)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 定义为局部变量</span></span><br><span class="line">    l_sqrt = sqrt</span><br><span class="line">    result_append = result.append</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">        result_append(l_sqrt(n))</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">count : <span class="number">24.394634</span></span><br></pre></td></tr></table></figure>

<p>又有所提升，包括<code>self.value</code>如果被某个函数频繁调用，也需要内部转为局部变量<code>l_value  =  self.value</code></p>
</li>
<li><p><strong>避免不必要的抽象</strong>，不要把别的语言(Java)的思想带到Python中，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self._y = y</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._y</span><br><span class="line"></span><br><span class="line"><span class="meta">    @y.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._y = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">print(timeit(<span class="string">'a.x'</span>, <span class="string">'from __main__ import a'</span>))</span><br><span class="line">print(timeit(<span class="string">'a.y'</span>, <span class="string">'from __main__ import a'</span>))</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line"><span class="number">0.032640684</span></span><br><span class="line"><span class="number">0.11556200499999997</span></span><br></pre></td></tr></table></figure>

<p>需要审视是否需要定义属性访问器。</p>
</li>
<li><p><strong>使用内置的容器</strong>，内置的数据类型比如字符串、元组、列表、集合和字典都是使用C来实现的，运行起来非常快。 如果你想自己实现新的数据结构（比如链接列表、平衡树等）， 那么要想在性能上达到内置的速度几乎不可能，因此，还是乖乖的使用内置的吧。</p>
</li>
<li><p><strong>避免创建不必要的数据结构或复制</strong></p>
</li>
<li><p>字典的创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;</span><br><span class="line">    <span class="string">'name'</span> : <span class="string">'AAPL'</span>,</span><br><span class="line">    <span class="string">'shares'</span> : <span class="number">100</span>,</span><br><span class="line">    <span class="string">'price'</span> : <span class="number">534.22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = dict(name=<span class="string">'AAPL'</span>, shares=<span class="number">100</span>, price=<span class="number">534.22</span>)</span><br></pre></td></tr></table></figure>

<p>第二种方法比第一种慢上三倍。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Pause容器</title>
    <url>/posts/523ad239/</url>
    <content><![CDATA[<blockquote>
<p>来自<a href="https://jimmysong.io/kubernetes-handbook/concepts/pause-container.html#" target="_blank" rel="external nofollow noopener noreferrer">jimmysong.io</a></p>
</blockquote>
<p>Pause容器，又叫Infra容器，本文将探究该容器的作用与原理。</p>
<p>我们知道在kubelet的配置中有这样一个参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBELET_POD_INFRA_CONTAINER=--pod-infra-container-image=registry.access.redhat.com/rhel7/pod-infrastructure:latest</span><br></pre></td></tr></table></figure>

<p>上面是openshift中的配置参数，kubernetes中默认的配置参数是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">KUBELET_POD_INFRA_CONTAINER=--pod-infra-container-image=gcr.io/google_containers/pause-amd64:3.0</span><br></pre></td></tr></table></figure>

<p>Pause容器，是可以自己来定义，官方使用的<code>gcr.io/google_containers/pause-amd64:3.0</code>容器的代码见<a href="https://github.com/kubernetes/kubernetes/tree/master/build/pause" target="_blank" rel="external nofollow noopener noreferrer">Github</a>，使用C语言编写。</p>
<h2 id="Pause容器的作用"><a href="#Pause容器的作用" class="headerlink" title="Pause容器的作用"></a>Pause容器的作用</h2><p>我们检查node节点的时候会发现每个node上都运行了很多的pause容器，例如如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                                                                                                    COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">2c7d50f1a7be        docker.io/jimmysong/heapster-grafana-amd64@sha256:d663759b3de86cf62e64a43b021f133c383e8f7b0dc2bdd78115bc95db371c9a       <span class="string">"/run.sh"</span>                3 hours ago         Up 3 hours                              k8s_grafana_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0</span><br><span class="line">5df93dea877a        docker.io/jimmysong/heapster-influxdb-amd64@sha256:a217008b68cb49e8f038c4eeb6029261f02adca81d8eae8c5c01d030361274b8      <span class="string">"influxd --config ..."</span>   3 hours ago         Up 3 hours                              k8s_influxdb_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0</span><br><span class="line">9cec6c0ef583        jimmysong/pause-amd64:3.0                                                                                                <span class="string">"/pause"</span>                 3 hours ago         Up 3 hours                              k8s_POD_monitoring-influxdb-grafana-v4-5697c6b59-76zqs_kube-system_5788a3c5-29c0-11e8-9e88-525400005732_0</span><br><span class="line">54d06e30a4c7        docker.io/jimmysong/kubernetes-dashboard-amd64@sha256:668710d034c4209f8fa9a342db6d8be72b6cb5f1f3f696cee2379b8512330be4   <span class="string">"/dashboard --inse..."</span>   3 hours ago         Up 3 hours                              k8s_kubernetes-dashboard_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0</span><br><span class="line">5a5ef33b0d58        jimmysong/pause-amd64:3.0                                                                                                <span class="string">"/pause"</span>                 3 hours ago         Up 3 hours                              k8s_POD_kubernetes-dashboard-65486f5fdf-lshl7_kube-system_27c414a1-29c0-11e8-9e88-525400005732_0</span><br></pre></td></tr></table></figure>

<p>kubernetes中的pause容器主要为每个业务容器提供以下功能：</p>
<ul>
<li>在pod中担任Linux命名空间共享的基础；</li>
<li>启用pid命名空间，开启init进程。</li>
</ul>
<p>在<a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="external nofollow noopener noreferrer">The Almighty Pause Container</a>这篇文章中做出了详细的说明，pause容器的作用可以从这个例子中看出，首先见下图：</p>
<p><img alt="Pause容器" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/pause-container.png"></p>
<p>我们首先在节点上运行一个pause容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name pause -p 8880:80 jimmysong/pause-amd64:3.0</span><br></pre></td></tr></table></figure>

<p>然后再运行一个nginx容器，nginx将为<code>localhost:2368</code>创建一个代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF &gt;&gt; nginx.conff</span><br><span class="line">error_log stderr;</span><br><span class="line">events &#123; worker_connections  1024; &#125;</span><br><span class="line">http &#123;</span><br><span class="line">    access_log /dev/stdout combined;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80 default_server;</span><br><span class="line">        server_name example.com www.example.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://127.0.0.1:2368;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">$ docker run -d --name nginx -v `<span class="built_in">pwd</span>`/nginx.conf:/etc/nginx/nginx.conf --net=container:pause --ipc=container:pause --pid=container:pause nginx</span><br></pre></td></tr></table></figure>

<p>然后再为<a href="https://github.com/TryGhost/Ghost" target="_blank" rel="external nofollow noopener noreferrer">ghost</a>创建一个应用容器，这是一款博客软件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --name ghost --net=container:pause --ipc=container:pause --pid=container:pause ghost</span><br></pre></td></tr></table></figure>

<p>现在访问<a href="http://localhost:8880/" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8880/</a>就可以看到ghost博客的界面了。</p>
<p><strong>解析</strong></p>
<p>pause容器将内部的80端口映射到宿主机的8880端口，pause容器在宿主机上设置好了网络namespace后，nginx容器加入到该网络namespace中，我们看到nginx容器启动的时候指定了<code>--net=container:pause</code>，ghost容器同样加入到了该网络namespace中，这样三个容器就共享了网络，互相之间就可以使用<code>localhost</code>直接通信，<code>--ipc=contianer:pause --pid=container:pause</code>就是三个容器处于同一个namespace中，init进程为<code>pause</code>，这时我们进入到ghost容器中查看进程情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0   1024     4 ?        Ss   13:49   0:00 /pause</span><br><span class="line">root         5  0.0  0.1  32432  5736 ?        Ss   13:51   0:00 nginx: master p</span><br><span class="line">systemd+     9  0.0  0.0  32980  3304 ?        S    13:51   0:00 nginx: worker p</span><br><span class="line">node        10  0.3  2.0 1254200 83788 ?       Ssl  13:53   0:03 node current/<span class="keyword">in</span></span><br><span class="line">root        79  0.1  0.0   4336   812 pts/0    Ss   14:09   0:00 sh</span><br><span class="line">root        87  0.0  0.0  17500  2080 pts/0    R+   14:10   0:00 ps aux</span><br></pre></td></tr></table></figure>

<p>在ghost容器中同时可以看到pause和nginx容器的进程，并且pause容器的PID是1。而在kubernetes中容器的PID=1的进程即为容器本身的业务进程。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ianlewis.org/en/almighty-pause-container" target="_blank" rel="external nofollow noopener noreferrer">The Almighty Pause Container</a></li>
<li><a href="https://o-my-chenjian.com/2017/10/17/The-Pause-Container-Of-Kubernetes/" target="_blank" rel="external nofollow noopener noreferrer">Kubernetes之Pause容器</a></li>
</ul>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>Protecting-Python-Sources-With-Cython</title>
    <url>/posts/5e430375/</url>
    <content><![CDATA[<p>Protecting your Python sources from unwanted readers is easier said than done, because <strong>.pyc</strong> bytecode is <a href="https://github.com/rocky/python-uncompyle6" target="_blank" rel="external nofollow noopener noreferrer">decompileable</a> and the obfuscation is easily reverse-engineered. It took me a while to figure out a proper way to hide Python code…</p>
<p>Meet <a href="http://cython.org/" target="_blank" rel="external nofollow noopener noreferrer"><strong>Cython</strong></a><strong>,</strong> an <strong>optimizing static compiler</strong> that takes your <code>.py</code> modules and translates them to high-performant C files. Resulting C files can be compiled into native binary libraries with no effort. When the compilation is done there’s no way to reverse compiled libraries back to readable Python source code! Cython supports both Python 2 and 3, including the modern <strong>async/await</strong> syntax. From my experience, the only thing it couldn’t do is asynchronous generators.</p>
<h3 id="1-Install-Cython"><a href="#1-Install-Cython" class="headerlink" title="1. Install Cython"></a>1. Install Cython</h3><p>Installation is as easy as typing <code>pip install cython</code> or <code>pip3 install cython</code>(for Python 3).</p>
<h3 id="2-Add-compile-py"><a href="#2-Add-compile-py" class="headerlink" title="2. Add compile.py"></a>2. Add compile.py</h3><p>Add the following script to your project folder (as <code>compile.py</code>). It will act as a “makefile” for the build:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from distutils.core import setup</span><br><span class="line">from distutils.extension import Extension</span><br><span class="line">from Cython.Distutils import build_ext</span><br><span class="line">ext_modules &#x3D; [</span><br><span class="line">    Extension(&quot;mymodule1&quot;,  [&quot;mymodule1.py&quot;]),</span><br><span class="line">    Extension(&quot;mymodule2&quot;,  [&quot;mymodule2.py&quot;]),</span><br><span class="line">#   ... all your modules that need be compiled ...</span><br><span class="line">]</span><br><span class="line">setup(</span><br><span class="line">    name &#x3D; &#39;My Program Name&#39;,</span><br><span class="line">    cmdclass &#x3D; &#123;&#39;build_ext&#39;: build_ext&#125;,</span><br><span class="line">    ext_modules &#x3D; ext_modules</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>The script should explicitly enumerate files that you want to be compiled. You can also leave some files uncompiled as well, if you want. Those will still remain <code>import</code>able from binary modules.</p>
<h3 id="3-Add-main-py"><a href="#3-Add-main-py" class="headerlink" title="3. Add main.py"></a>3. Add main.py</h3><p>Make the entry point Python file for your application. You will import and launch all the compiled logic from there. An entry point file is required because Cython does not generate executable binaries by default (though it is capable to), so you will need a dummy Python file, where you simply import all the compiled logic and run it. It can be as simple as:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from logic import main      # this comes from a compiled binary</span><br><span class="line">main ()</span><br></pre></td></tr></table></figure>

<h3 id="4-Run-compile-py"><a href="#4-Run-compile-py" class="headerlink" title="4. Run compile.py"></a>4. Run compile.py</h3><p>Depending on the Python version you use, run:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python compile.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>…or, for Python 3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python3 compile.py build_ext --inplace</span><br></pre></td></tr></table></figure>

<p>The above command will generate <code>.so</code> and <code>.c</code> files next to your <code>.py</code> source files:</p>
<p><img alt="img" data-src="https://cdn-images-1.medium.com/max/1600/1*KQCTp5cE9R84Ku_0oaG1Cw.png"></p>
<p>The <code>.c</code> files are intermediate sources used to generate <code>.so</code> files, which are binary modules you want to distribute. When building on Windows these files will probably have the <code>.dll</code> extension (<strong>UPD</strong>: in the comments people suggest that they actually have the <code>.pyd</code> extension on Windows).</p>
<p>You can delete <code>.c</code> and <code>.py</code> files after a successful build and keep the <code>.so</code>files only.</p>
<p>Note that <code>.so</code>-files contain the target platform in their names (e.g. <code>darwin</code>on my MacOS). Obviously, the compiled modules are not cross-platform. If you distribute your program to Ubuntu Linux users, you should compile it on Linux. Otherwise you won’t be able to load these binaries. So you’ll have to compile a platform-specific version of your code for each of your targeted platforms.</p>
<p>Luckily, there are tools like <a href="https://www.vagrantup.com/" target="_blank" rel="external nofollow noopener noreferrer">Vagrant</a> that can help reduce all the OS installation burden to a couple of simple commands…</p>
<h3 id="Setting-Up-a-Different-OS-Environment-Using-VirtualBox-and-Vagrant"><a href="#Setting-Up-a-Different-OS-Environment-Using-VirtualBox-and-Vagrant" class="headerlink" title="Setting Up a Different OS Environment Using VirtualBox and Vagrant"></a>Setting Up a Different OS Environment Using VirtualBox and Vagrant</h3><p>Here’s an example of how I’ve managed to compile my project on Ubuntu 16.04, while using MacOS.</p>
<ol>
<li>Install <a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="external nofollow noopener noreferrer">VirtualBox</a> and <a href="https://www.vagrantup.com/" target="_blank" rel="external nofollow noopener noreferrer">Vagrant</a>.</li>
<li>Run <code>export VAGRANT_DEFAULT_PROVIDER=virtualbox</code> (you can add it to your Bash startup script at <code>~/.bash_profile</code> for convenience).</li>
<li>Choose an OS here: <a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="external nofollow noopener noreferrer">https://app.vagrantup.com/boxes/search</a>. Then click the <em>New</em> tab in “How to use” section. You’ll find setup instructions and commands there. Run those commands in your Python project folder:</li>
</ol>
<p><img alt="img" data-src="https://cdn-images-1.medium.com/max/1600/1*s4uPRId_oMQAFqSV1j4WjQ.png">)<img alt="img" data-src="https://cdn-images-1.medium.com/max/2000/1*s4uPRId_oMQAFqSV1j4WjQ.png"></p>
<p>Finally, run <code>vagrant ssh</code> to get into a freshly installed Ubuntu console (type <code>exit</code> to exit):</p>
<p><img alt="img" data-src="https://cdn-images-1.medium.com/max/1600/1*V5nAJ1gFlWbFTxpOPFg8Lw.png"></p>
<p><code>cd</code> to the <code>/vagrant</code> folder to see your project files. Then perform steps 1, 4 from this manual, and you’re done:</p>
<p><img alt="img" data-src="https://cdn-images-1.medium.com/max/1600/1*peFjOUpkICaIxgvMpXv6VA.png"></p>
<p>For projects with a short build/release cycle, multi-plaform builds could be automated using a CI (Continuous Integration) service, like <a href="https://travis-ci.org/" target="_blank" rel="external nofollow noopener noreferrer">TravisCI</a>, but that’s a story for another article.</p>
<h3 id="About-the-Author"><a href="#About-the-Author" class="headerlink" title="About the Author"></a>About the Author</h3><p>I’m a member of the developer team behind the open-source cross-language <a href="https://github.com/ccxt-dev/ccxt" target="_blank" rel="external nofollow noopener noreferrer">CCXT Library</a> (available for JavaScript, Python or PHP). The library is used to connect and trade with more than 100 cryptocurrency exchanges worldwide.</p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Rancher安装与部署K8s</title>
    <url>/posts/36f1f294/</url>
    <content><![CDATA[<blockquote>
<p>Rancher Kubernetes Engine(RKE), an extremely simple, lightning fast Kubernetes installer that works everywhere.</p>
</blockquote>
<p>安装前提：</p>
<ul>
<li><p>系统: Ubuntu 16.04 (64-bit)、Red Hat Enterprise Linux 7.5 (64-bit)</p>
</li>
<li><p>Docker Versions: 1.12.6、1.13.1、17.03.2</p>
</li>
<li><p>关闭防火墙</p>
</li>
</ul>
<h3 id="一、初始化和安装指定版本Docker"><a href="#一、初始化和安装指定版本Docker" class="headerlink" title="一、初始化和安装指定版本Docker"></a>一、初始化和安装指定版本Docker</h3><ol>
<li>关闭防火墙</li>
<li><a href="指定版本安装Docker.md">安装Docker</a></li>
</ol>
<h3 id="二、安装rancher"><a href="#二、安装rancher" class="headerlink" title="二、安装rancher"></a>二、安装rancher</h3><p>官网有单节点和高可用rancher的安装方法，这里我们只选择单节点rancher：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher</span><br></pre></td></tr></table></figure>

<p>然后打开<code>https://&lt;server_ip&gt;</code>即可看到以下：</p>
<p><img alt="rancher初始化" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E5%88%9D%E5%A7%8B%E5%8C%96.png"></p>
<p>设置密码后可进入主页，这里大量设置是与云服务有关的，包括没有显示的也可以手动添加，等待云服务商的接入，我们这里主要是本地部署自己的k8s集群。</p>
<p><img alt="rancher主页" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E4%B8%BB%E9%A1%B5.png"></p>
<ol>
<li>选择CUSTOM（添加主机自建Kubernetes集群）</li>
<li>K8s-rancher版本选择最新发布版</li>
</ol>
<p><img alt="rancher搭建k8s" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E6%90%AD%E5%BB%BAk8s.png"></p>
<p> 接下来就根据你的主机准备情况进行k8s和rancher组件的部署，他会根据你的选择自动生成docker命令，我们这里是在master节点部署etcd和control，kubelet和proxy部署在子节点上，我不太确定apiserver和调度器部署在哪，是不是由rancher组件代替了，后续需要查看文档。</p>
<p><img alt="rancher自动部署" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2.png"></p>
<p>需要注意的是为了给每个主机加上名称，因为名称唯一，所以每条命令只能在一台机器上部署，否则同名称主机只能识别一个</p>
<p>这里就是部署完成的页面，在这里可以查看Kubeconfig文件和进行kubectl命令行操作，可以打开进行一些测试。</p>
<p><img alt="rancher-k8s仪表盘" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E4%BB%AA%E8%A1%A8%E7%9B%98.png"></p>
<p>点击system可以看到kube-system下的一些部署服务，default就是默认的命名空间，这里部署两个简单的服务进行测试</p>
<p><img alt="rancher-k8s-system" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher-k8s-system.png"></p>
<p>registry.cn-shanghai.aliyuncs.com/vissssa/nginx:<code>frontend</code>和<code>zhangyu1</code>，我在frontend中设定nginx重定向到<code>http://zhangyu</code>，那么只要设定另一个服务名称为<code>zhangyu</code>即可，kube-dns已经自动部署了，暴露frontend接口：type=NodePort。</p>
<p><img alt="rancher部署服务" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/rancher%E9%83%A8%E7%BD%B2%E4%BB%BB%E5%8A%A11.png"></p>
<p>访问<code>http://&lt;work_ip&gt;:30000</code>即可看到结果。结果重定向到了<code>zhangyu</code>的nginx服务上。</p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>rancher</tag>
        <tag>deploy</tag>
      </tags>
  </entry>
  <entry>
    <title>Storm集群与Python项目的实践</title>
    <url>/posts/dea34e62/</url>
    <content><![CDATA[<p>目前主流的使用Storm的demo语言是Java,但我们使用的是Python,则需要引入一些第三方库,这里我选择的是<strong>Streamparse</strong></p>
<h1 id="安装Streamparse"><a href="#安装Streamparse" class="headerlink" title="安装Streamparse"></a>安装Streamparse</h1><p>根据<a href="http://streamparse.readthedocs.io/en/master/quickstart.html" target="_blank" rel="external nofollow noopener noreferrer">官方文档</a>来进行一个安装部署<br>因为我们是一个Centos6.4的版本,所以很需要注意一些必备工具的版本,jdk1.7+,然后下载安装<strong>lein</strong><br>需要注意的是使用普通用户,否则submit后续会有问题</p>
<p><em>Download the lein script (or on Windows lein.bat)<br>Place it on your $PATH where your shell can find it (eg. ~/bin)<br>Set it to be executable (chmod a+x ~/bin/lein)<br>Run it (lein) and it will download the self-install package</em></p>
<p>安装的lein会放在~/.lein中,如果构建项目时出现有关问题,可以先去删除重装</p>
<h2 id="安装Python3-6"><a href="#安装Python3-6" class="headerlink" title="安装Python3.6"></a>安装Python3.6</h2><p>centos6.4自带的2.6是不在Streamparse的支持范围内的,所以我们直接升级到3.6.6<br>使用源码安装(yum 没有3.6)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcc zlib</span><br><span class="line"></span><br><span class="line">&gt;&gt; wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;3.6.6&#x2F;Python-3.6.6.tgz</span><br><span class="line"></span><br><span class="line">&gt;&gt; tar zxvf Python-3.6.6.tgz</span><br><span class="line">&gt;&gt; cd Python-3.6.6</span><br><span class="line"></span><br><span class="line">&gt;&gt; .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3</span><br><span class="line">&gt;&gt; make</span><br><span class="line">&gt;&gt; sudo make install</span><br><span class="line">&gt;&gt; make clean</span><br><span class="line">&gt;&gt; make distclean</span><br><span class="line"></span><br><span class="line"># 再添加到环境变量中（后续virtualenv需要）</span><br><span class="line">&gt;&gt; vim &#x2F;etc&#x2F;profile</span><br><span class="line">export PATH&#x3D;&quot;$PATH:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&quot;</span><br><span class="line"></span><br><span class="line"># 更改软链接</span><br><span class="line">&gt;&gt; mv &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python.bak</span><br><span class="line">&gt;&gt; ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3.6</span><br><span class="line">&gt;&gt; ln -s &#x2F;usr&#x2F;bin&#x2F;python3.6 &#x2F;usr&#x2F;bin&#x2F;python</span><br><span class="line">&gt;&gt; ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip</span><br><span class="line"></span><br><span class="line"># 需注意，此时yum是不能使用的（yum update无效），原因是它依赖于python2.6</span><br><span class="line">&gt;&gt; vim &#x2F;usr&#x2F;bin&#x2F;yum</span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python  ---&gt;&gt;   #!&#x2F;usr&#x2F;bin&#x2F;python2.6</span><br><span class="line"></span><br><span class="line">#　最后就是安装virtualenv</span><br><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>环境搭建完毕，开始demo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; sparse quickstart wordcount</span><br><span class="line">&gt;&gt; sparse run</span><br></pre></td></tr></table></figure>
<p>当前目录生成一个简单的demo项目,并模拟运行<br>这时会报错（＝＝！），为啥呢，我也不知道，改就完事了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 第一个要改得是版本，把里面的版本改为你安装的storm版本</span><br><span class="line">&gt;&gt; vim project.clj</span><br><span class="line"># 第二个是py执行文件，加入两个options参数</span><br><span class="line">&gt;&gt; vim fabfile.py</span><br><span class="line">def pre_submit(topology_name, env_name, env_config,   options):</span><br><span class="line">    &quot;&quot;&quot;Override this function to perform custom actions prior to topology</span><br><span class="line">    submission. No SSH tunnels will be active when this function is called.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def post_submit(topo_name, env_name, env_config,   options):</span><br><span class="line">    &quot;&quot;&quot;Override this function to perform custom actions after topology</span><br><span class="line">    submission. Note that the SSH tunnel to Nimbus will still be active</span><br><span class="line">    when this function is called.&quot;&quot;&quot;</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>此时应当可以运行了<br>模拟通过就开始上传到集群了，修改config.json</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;serializer&quot;: &quot;json&quot;,</span><br><span class="line">    &quot;topology_specs&quot;: &quot;topologies&#x2F;&quot;,</span><br><span class="line">    &quot;virtualenv_specs&quot;: &quot;virtualenvs&#x2F;&quot;,</span><br><span class="line">    &quot;envs&quot;: &#123;</span><br><span class="line">        &quot;prod&quot;: &#123;</span><br><span class="line">            &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">            &quot;ssh_password&quot;: &quot;123123&quot;,</span><br><span class="line">            &quot;nimbus&quot;: &quot;192.168.1.125&quot;,</span><br><span class="line">            &quot;workers&quot;: [&quot;192.168.1.129&quot;, &quot;192.168.1.131&quot;],</span><br><span class="line">            &quot;log&quot;: &#123;</span><br><span class="line">                &quot;path&quot;: &quot;&#x2F;var&#x2F;log&#x2F;storm&#x2F;streamparse&quot;,</span><br><span class="line">                &quot;file&quot;: &quot;pystorm_&#123;topology_name&#125;_&#123;component_name&#125;_&#123;task_id&#125;_&#123;pid&#125;.log&quot;,</span><br><span class="line">                &quot;max_bytes&quot;: 1000000,</span><br><span class="line">                &quot;backup_count&quot;: 10,</span><br><span class="line">                &quot;level&quot;: &quot;info&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        &quot;virtualenv_root&quot;: &quot;&#x2F;data&#x2F;virtualenvs&#x2F;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：user填写root，为了获得权限来创建日志文件和虚拟环境<br>然后就是正式上传运行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; sparse submit</span><br><span class="line"></span><br><span class="line"># 此时会先在几个workers中检测虚拟环境并安装需要的库，requirements.txt在virtualenv&#x2F;下</span><br><span class="line"># 检测且通过则会将本地项目打包并上传到nimbus中进行任务分发，原理应该是topologies中的py文件的定义</span><br></pre></td></tr></table></figure>
<p>还需要注意的是nimbus和supervisor之间的联系，这是绕过zopkeeper的，是spouts和bolts之间的emit发射函数，所以需要开启端口，分别是nimbus的6627和supervisor的6700<br>可以在nimbus的ＵＩ页面来查看项目运行情况，以及任务分布以及状态．</p>
]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>deploy</tag>
        <tag>storm</tag>
      </tags>
  </entry>
  <entry>
    <title>Storm集群搭建</title>
    <url>/posts/48352a80/</url>
    <content><![CDATA[<h1 id="Zookeeper安装与部署"><a href="#Zookeeper安装与部署" class="headerlink" title="Zookeeper安装与部署"></a>Zookeeper安装与部署</h1><p><strong>首先,根据zookeeper的原理,他必须至少是三个,且为奇数,因为它的master主线程死了可以自动选举出一个,要求是剩下的节点必须大于总共的半数</strong><br>试验机是3台centos6.4虚拟机,首先下载所需的zookeeper的压缩包,接着解压</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; tar -zxvf zookeeper-3.4.9.tar.gz</span><br><span class="line">&gt;&gt;  zookeeper-3.4.9 &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">&gt;&gt; cd &#x2F;usr&#x2F;local&#x2F;</span><br><span class="line">&gt;&gt; mv zookeeper-3.4.9&#x2F; zookeeper</span><br><span class="line">&gt;&gt; cd zookeeper&#x2F;</span><br><span class="line">&gt;&gt; cd conf&#x2F;</span><br><span class="line">&gt;&gt; cp zoo_sample.cfg zoo.cfg</span><br><span class="line">&gt;&gt; vim zoo.cfg</span><br></pre></td></tr></table></figure>
<p>修改配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;# The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just</span><br><span class="line"># example sakes.</span><br><span class="line"></span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;data   #这里需要修改</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the</span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line">server.0&#x3D;192.168.1.114:2888:3888</span><br><span class="line">server.1&#x3D;192.168.1.116:2888:3888</span><br><span class="line">server.2&#x3D;192.168.1.132:2888:3888</span><br></pre></td></tr></table></figure>
<p>接着可以把zookeeper加入到环境变量(全程root用户)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export ZOOKEEPER_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper</span><br><span class="line">export PATH&#x3D;$PATH:$ZOOKEEPER_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>再根据配置文件中个个节点对应的server.x,在$ZOOKEEPER_HOME下建立data文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim myid</span><br><span class="line"></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<p><del><strong>最后关闭防火墙即可</strong></del><br><del>service iptables stop</del><br>开放指定端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables</span><br><span class="line"></span><br><span class="line"># Firewall configuration written by system-config-firewall</span><br><span class="line"># Manual customization of this file is not recommended.</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 2181 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 2888 -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3888 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line">&gt;&gt; service iptables restart</span><br><span class="line"></span><br><span class="line">&gt;&gt; cd &#x2F;usr.local&#x2F;zookeeper&#x2F;bin</span><br><span class="line"></span><br><span class="line">&gt;&gt; zkServer.sh start  开启服务</span><br><span class="line">&gt;&gt; zkServer.sh status 查看状态是否开启以及它的身份</span><br><span class="line">&gt;&gt; zkServer.sh stop   关闭服务</span><br></pre></td></tr></table></figure>
<p>检测某端口是否开放可以使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; telnet 192.168.1.114 2181</span><br></pre></td></tr></table></figure>

<h1 id="Storm安装与部署"><a href="#Storm安装与部署" class="headerlink" title="Storm安装与部署"></a>Storm安装与部署</h1><p>三台虚拟机,分别为nimbus,supervisor01,supervisor02<br>以nimbus为例<br><strong>我们的版本选择为storm版本是1.1，zookeeper3.4.9，java1.8。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; java -version  --&gt; 1.7   # 当前版本1.7</span><br><span class="line"></span><br><span class="line">&gt;&gt; sudo yum install java-1.8.0-openjdk</span><br><span class="line">&gt;&gt; java -version  --&gt;  1.8  # 所需版本</span><br></pre></td></tr></table></figure>
<p>接着开始安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;storm&#x2F;apache-storm-1.1.2&#x2F;apache-storm-1.1.2.tar.gz</span><br><span class="line">&gt;&gt; tar zxvf apache-storm-1.1.2.tar.gz</span><br><span class="line">&gt;&gt; mkdir storm_data</span><br><span class="line">&gt;&gt; cd apache-storm-1.1.2</span><br></pre></td></tr></table></figure>

<p>配置文件编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim conf&#x2F;storm.yaml</span><br><span class="line"></span><br><span class="line">storm.zookeeper.servers:</span><br><span class="line">    - &quot;192.168.1.114&quot;</span><br><span class="line">    - &quot;192.168.1.116&quot;</span><br><span class="line">    - &quot;192.168.1.132&quot;</span><br><span class="line">storm.local.dir: &quot;&#x2F;home&#x2F;123&#x2F;Desktop&#x2F;storm_data&quot;</span><br><span class="line">storm.local.hostname: &quot;192.168.1.125&quot;</span><br><span class="line"># storm.local.hostname: &quot;192.168.1.129&quot;</span><br><span class="line"># storm.local.hostname: &quot;192.168.1.131&quot;</span><br><span class="line"># 根据每台机子的ip地址自定义</span><br><span class="line">nimbus.seeds: [&quot;192.168.1.125&quot;]</span><br><span class="line"># 可以指定多个作为备用</span><br><span class="line"></span><br><span class="line">supervisor.slots.ports:</span><br><span class="line">    - 6700</span><br><span class="line">    - 6701</span><br><span class="line">    - 6702</span><br><span class="line">    - 6703</span><br><span class="line"></span><br><span class="line"># 两台supervisor的额外配置</span><br><span class="line"># supervisor.childopts: -verbose:gc -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.ssl&#x3D;false -Dcom.sun.management.jmxremote.authenticate&#x3D;false -Dcom.sun.management.jmxremote.port&#x3D;9998</span><br></pre></td></tr></table></figure>
<p>配置完成,接下来只需要把这两个文件夹同步到两个supervisor中即可</p>
<p>安装配置完成,接下来就是部署,首先开启需要开启的端口,接着:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nimbus:</span><br><span class="line"></span><br><span class="line">nohup bin&#x2F;storm ui &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br><span class="line"># 图形化控制面板  默认是当前服务器的8080端口,如果需要在控制面板需要看日志,则需要在各storm上开启logviewer,且防火墙放开8000端口</span><br><span class="line"></span><br><span class="line">nohup bin&#x2F;storm nimbus &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">supervisor</span><br><span class="line"></span><br><span class="line">nohup bin&#x2F;storm supervisor &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>




<p>Zookeeper集群负责Nimbus节点和Supervior节点之间的==通信==，监控各个节点之间的状态。</p>
]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>storm</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu和centos安装NodeJS</title>
    <url>/posts/b92a20d6/</url>
    <content><![CDATA[<p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境，其使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>Node.js 的包管理器 npm，是全球最大的开源库生态系统，功能及其强大。</p>
<p>本篇讲述的是通用安装且简单无脑，那就是使用NVM(Node version manager),github开源的项目, root下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://raw.githubusercontent.com/creationix/nvm/vx.x.x/install.sh | bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出支持的node版本</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm list-remote</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择版本安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nvm install v10.xx.xx</span></span><br></pre></td></tr></table></figure>

<p>具体的功能我没仔细研究，感觉很像是pyenv</p>
<p><del>这篇文章介绍如何在ubuntu环境下安装node环境。</del></p>
<p>我使用的系统是ubuntu 16.04，不过在其他版本的系统中应该也适用。</p>
<h3 id="安装python-software-properties"><a href="#安装python-software-properties" class="headerlink" title="安装python-software-properties"></a>安装python-software-properties</h3><p>首先需要安装依赖包python-software-properties。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install python-software-properties</span><br></pre></td></tr></table></figure>
<h3 id="添加PPA"><a href="#添加PPA" class="headerlink" title="添加PPA"></a>添加PPA</h3><p>网站deb.nodesource.com维护了nodejs的各版本安装包的PPA，我们可以从该网站上下载执行导入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_8.x | sudo -E bash -</span><br></pre></td></tr></table></figure>
<h3 id="安装nodejs和npm"><a href="#安装nodejs和npm" class="headerlink" title="安装nodejs和npm"></a>安装nodejs和npm</h3><p>接下来安装nodejs，安装完成之后npm也自动安装好了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install nodejs</span><br></pre></td></tr></table></figure>
<p>安装完成之后我们查看一下nodejs和npm的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v8.11.3</span><br><span class="line">$ npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure>
<h3 id="配置npm仓库"><a href="#配置npm仓库" class="headerlink" title="配置npm仓库"></a>配置npm仓库</h3><p>因为国内的网络环境，直接从npm官方源安装软件包速度会比较慢，甚至导致安装不成功。<br>我们可以安装nrm工具，用于管理软件源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g nrm</span><br></pre></td></tr></table></figure>
<p>安装完成之后，列出可用的软件源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nrm ls</span><br><span class="line">* npm ---- https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br><span class="line">  cnpm --- http:&#x2F;&#x2F;r.cnpmjs.org&#x2F;</span><br><span class="line">  taobao - https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line">  nj ----- https:&#x2F;&#x2F;registry.nodejitsu.com&#x2F;</span><br><span class="line">  rednpm - http:&#x2F;&#x2F;registry.mirror.cqupt.edu.cn&#x2F;</span><br><span class="line">  npmMirror  https:&#x2F;&#x2F;skimdb.npmjs.com&#x2F;registry&#x2F;</span><br><span class="line">  edunpm - http:&#x2F;&#x2F;registry.enpmjs.org&#x2F;</span><br></pre></td></tr></table></figure>
<p>在国内，我们可以使用taobao的源，速度还相对不错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nrm use taobao</span><br><span class="line">Registry has been set to: https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>centos</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6.4安装mysql并配置远程连接</title>
    <url>/posts/eb77891e/</url>
    <content><![CDATA[<h4 id="一、查看并卸载老的mysql"><a href="#一、查看并卸载老的mysql" class="headerlink" title="一、查看并卸载老的mysql"></a>一、查看并卸载老的mysql</h4><ol>
<li>查看该操作系统上是否已经安装了mysql数据库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -qa |grep mysql</span><br></pre></td></tr></table></figure></li>
<li>mysql的卸载<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -e mysql　　//普通删除模式</span><br><span class="line">$ rpm -e --nodeps mysql(mysql-server、mysql-devel)　　//强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</span><br></pre></td></tr></table></figure>
好吧，就试试rpm -e –nodeps mysql。</li>
</ol>
<p>通过 rpm -qa | grep mysql 查看是否已经卸载成功！！</p>
<h4 id="二、通过yum来进行mysql的安装"><a href="#二、通过yum来进行mysql的安装" class="headerlink" title="二、通过yum来进行mysql的安装"></a>二、通过yum来进行mysql的安装</h4><p>首先我们可以输入 yum list | grep mysql 命令来查看yum上提供的mysql数据库可下载的版本<br>然后我们可以通过输入yum install -y mysql-server mysql mysql-devel命令，将mysql mysql-server mysql-devel都安装好(注意:安装mysql时我们并不是安装了mysql客户端就相当于安装好了mysql数据库了，我们还需要安装mysql-server服务端才行)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rpm -qi mysql-server</span><br></pre></td></tr></table></figure>
<h4 id="三、mysql数据库的初始化及相关配置"><a href="#三、mysql数据库的初始化及相关配置" class="headerlink" title="三、mysql数据库的初始化及相关配置"></a>三、mysql数据库的初始化及相关配置</h4><p>我们在安装完mysql数据库以后，会发现会多出一个mysqld的服务，这个就是咱们的数据库服务，我们通过输入<strong>service mysqld start</strong>命令就可以启动我们的mysql服务。<br>注意：如果我们是第一次启动mysql服务，mysql服务器首先会进行初始化的配置,根据提示来配置我们的密码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看mysql开机时是否启动</span></span><br><span class="line">$ chkconfig --list |grep mysqld</span><br><span class="line">$ chkconfig mysqld on</span><br></pre></td></tr></table></figure>

<p>修改mysql的默认密码：</p>
<p>mysql数据库安装完以后只会有一个root管理员账号，但是此时的root账号还并没有为其设置密码，在第一次启动mysql服务时，会进行数据库的一些初始化工作，在输出的一大串信息中，我们看到有这样一行信息 ：</p>
<p>/usr/bin/mysqladmin -u root password ‘new-password’// 为root账号设置密码</p>
<p>所以我们可以通过 该命令来给我们的root账号设置密码(注意：这个root账号是mysql的root账号，非Linux的root账号)</p>
<p>mysqladmin -u root password ‘root’　　// 通过该命令给root账号设置密码为 root</p>
<p>如果在修改密码的时候报错：mysqladmin: connect to server at ‘localhost’ failed error: ‘Access denied for user ‘root’@’localhost’ (using password: NO)’</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ service mysqld stop</span><br><span class="line"></span><br><span class="line">$ mysqld_safe --user=mysql --skip-grant-tables --skip-networking &amp;</span><br><span class="line"></span><br><span class="line">$ mysql -u root mysql</span><br><span class="line"></span><br><span class="line">mysql&gt; UPDATE user SET Password=PASSWORD(<span class="string">'newpassword'</span>) <span class="built_in">where</span> USER=<span class="string">'root'</span>;</span><br><span class="line"></span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure>

<h4 id="四、mysql数据库的主要配置文件"><a href="#四、mysql数据库的主要配置文件" class="headerlink" title="四、mysql数据库的主要配置文件"></a>四、mysql数据库的主要配置文件</h4><ol>
<li>/etc/my.cnf这是mysql的主配置文件</li>
<li>/var/lib/mysql  mysql数据库的数据库文件存放位置 (<strong>删除这个文件夹来完成mysql的初始化</strong>)</li>
<li>/var/logmysql数据库的日志输出存放位置</li>
</ol>
<h4 id="五、配置远程连接"><a href="#五、配置远程连接" class="headerlink" title="五、配置远程连接"></a>五、配置远程连接</h4><p>设置数据库可以被远程访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line"></span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; grant all privileges on *.* to root@<span class="string">'%'</span> identified by <span class="string">'rootpassword'</span>;</span><br><span class="line">mysql&gt; flush privileges;</span><br><span class="line"></span><br><span class="line">$ service mysqld restart</span><br></pre></td></tr></table></figure>
<p>配置防火墙允许3306</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/sysconfig/iptables</span><br><span class="line"></span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line">$ service iptables restart</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph初见部署使用</title>
    <url>/posts/23c544ee/</url>
    <content><![CDATA[<blockquote>
<p>有鉴于官网教程不能对我这样的初学者有较好的帮助，在经历很多坑和查询资料，反复搭建数次后，总结了一套可以成功搭建的方法，但并不是官网最新版本的部署方法。</p>
</blockquote>
<p>原理图以及官方推荐系统等我就不写了，直接步入主题</p>
<h1 id="准备环节"><a href="#准备环节" class="headerlink" title="准备环节"></a>准备环节</h1><h3 id="1、系统节点信息"><a href="#1、系统节点信息" class="headerlink" title="1、系统节点信息"></a>1、系统节点信息</h3><table>
<thead>
<tr>
<th align="center">host</th>
<th align="center">roles</th>
<th align="center">ip</th>
<th align="center">volumes</th>
<th align="center">core</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ceph-admin</td>
<td align="center">ceph-deploy</td>
<td align="center">192.168.1.127</td>
<td align="center"></td>
<td align="center">CentOS Linux release 7.5.1804 (Core)</td>
</tr>
<tr>
<td align="center">ceph-node1</td>
<td align="center">mon<br>osd</td>
<td align="center">192.168.1.129</td>
<td align="center">10G+20G</td>
<td align="center">CentOS Linux release 7.5.1804 (Core)</td>
</tr>
<tr>
<td align="center">ceph-node2</td>
<td align="center">mon<br>osd</td>
<td align="center">192.168.1.126</td>
<td align="center">10G+20G</td>
<td align="center">CentOS Linux release 7.5.1804 (Core)</td>
</tr>
<tr>
<td align="center">ceph-node3</td>
<td align="center">mon<br>osd</td>
<td align="center">192.168.1.128</td>
<td align="center">10G+20G</td>
<td align="center">CentOS Linux release 7.5.1804 (Core)</td>
</tr>
</tbody></table>
<h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><h5 id="1、首先需要关闭SELINUX，然后开启需要的防火墙端口，此处节省时间直接关闭"><a href="#1、首先需要关闭SELINUX，然后开启需要的防火墙端口，此处节省时间直接关闭" class="headerlink" title="1、首先需要关闭SELINUX，然后开启需要的防火墙端口，此处节省时间直接关闭"></a>1、首先需要关闭SELINUX，然后开启需要的防火墙端口，此处节省时间直接关闭</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; sed -i <span class="string">'s/SELINUX=.*/SELINUX=disabled/'</span> /etc/selinux/config</span><br><span class="line">&gt;&gt; setenforce 0</span><br><span class="line">&gt;&gt; systemctl stop firewalld</span><br><span class="line">&gt;&gt; systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<p>官方不推荐root部署，这里也是为了迅速可用，直接root登录</p>
<h5 id="2、配置HOST"><a href="#2、配置HOST" class="headerlink" title="2、配置HOST"></a>2、配置HOST</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim /etc/hosts</span><br><span class="line"></span><br><span class="line">192.168.1.127 ceph-admin</span><br><span class="line">192.168.1.129 ceph-node1</span><br><span class="line">192.168.1.126 ceph-node2</span><br><span class="line">192.168.1.128 ceph-node3</span><br></pre></td></tr></table></figure>

<p>如需更方便，可以添加.ssh的相关配置。</p>
<p>然后建立ceph-admin到各个节点的信任ssh通信，在ceph-admin上:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ssh-keygen</span><br><span class="line"><span class="comment"># 一直回车即可</span></span><br><span class="line">...</span><br><span class="line">ssh-copy-id root@ceph-admin</span><br><span class="line">ssh-copy-id root@ceph-node1</span><br><span class="line">ssh-copy-id root@ceph-node2</span><br><span class="line">ssh-copy-id root@ceph-node3</span><br></pre></td></tr></table></figure>

<p>之所以要拷贝到自身，请看后面</p>
<h5 id="3、更新系统源头，全部节点更新为aliyun，虽然新的centos的系统源会自动寻找最快的mirrors，但我们还是选择aliyun吧（😝）"><a href="#3、更新系统源头，全部节点更新为aliyun，虽然新的centos的系统源会自动寻找最快的mirrors，但我们还是选择aliyun吧（😝）" class="headerlink" title="3、更新系统源头，全部节点更新为aliyun，虽然新的centos的系统源会自动寻找最快的mirrors，但我们还是选择aliyun吧（😝）"></a>3、更新系统源头，全部节点更新为aliyun，虽然新的centos的系统源会自动寻找最快的mirrors，但我们还是选择aliyun吧（😝）</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rm -rf /etc/yum.repos.d/*.repo</span><br><span class="line">&gt;&gt; curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">&gt;&gt; curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">&gt;&gt; sed -i <span class="string">'/aliyuncs/d'</span> /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">&gt;&gt; sed -i <span class="string">'s/$releasever/7/g'</span> /etc/yum.repos.d/CentOS-Base.repo</span><br><span class="line">&gt;&gt; sed -i <span class="string">'/aliyuncs/d'</span> /etc/yum.repos.d/epel.repo</span><br><span class="line">&gt;&gt; yum clean all</span><br><span class="line">&gt;&gt; yum makecache fast</span><br></pre></td></tr></table></figure>

<h5 id="4、NTP配置"><a href="#4、NTP配置" class="headerlink" title="4、NTP配置"></a>4、NTP配置</h5><p>分布式系统很重要的一个点，时钟同步，如果这一步不完成，ceph将会不允许任何i/o操作，本人在这一步有过一些很奇怪的问题，包括不能使用官方服务器、上次可以这次莫名其妙就不行等。</p>
<p>所有节点安装NTP：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; yum install -y ntp</span><br></pre></td></tr></table></figure>

<p>ceph-admin配置：注释掉官方自带的服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim /etc/ntp.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许局域网访问，但不允许修改</span></span><br><span class="line">restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap</span><br><span class="line"><span class="comment"># 来自中国授时中心</span></span><br><span class="line">server 0.cn.pool.ntp.org</span><br><span class="line">server 1.cn.pool.ntp.org</span><br><span class="line"><span class="comment"># 以上服务不行时，允许使用自己当前时间为服务器时间</span></span><br><span class="line">server 127.127.1.0 minpoll 4</span><br><span class="line">fudge 127.127.1.0 stratum 0</span><br><span class="line"></span><br><span class="line">&gt;&gt; vim /etc/ntp/step-tickers</span><br><span class="line"><span class="comment">#0.centos.pool.ntp.org</span></span><br><span class="line">127.127.1.0</span><br></pre></td></tr></table></figure>

<p>其他节点配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim /etc/ntp.conf</span><br><span class="line"><span class="comment">#server 0.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 1.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 2.centos.pool.ntp.org iburst</span></span><br><span class="line"><span class="comment">#server 3.centos.pool.ntp.org iburst</span></span><br><span class="line">server 192.168.1.127</span><br></pre></td></tr></table></figure>

<p>然后所有节点启动服务并且设置为开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; systemctl <span class="built_in">enable</span> ntpd ; systemctl start ntpd</span><br></pre></td></tr></table></figure>

<p>最后查看状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ntpq -p</span><br><span class="line"></span><br><span class="line">     remote           refid      st t when poll reach   delay   offset  jitter</span><br><span class="line">==============================================================================</span><br><span class="line">*ceph-admin      209.97.168.88    3 u   65   64  377    0.315  -238.63 151.966</span><br></pre></td></tr></table></figure>

<p>当所有node节点显示<code>*</code>时才是正确的，可以稍等一会查看信息，一般是十几秒同步一次</p>
<h1 id="正式搭建"><a href="#正式搭建" class="headerlink" title="正式搭建"></a>正式搭建</h1><h3 id="1、安装ceph-deploy"><a href="#1、安装ceph-deploy" class="headerlink" title="1、安装ceph-deploy"></a>1、安装ceph-deploy</h3><p>这是官方提供的用于简单搭建ceph框架的python脚本(<a href="https://github.com/ceph/ceph-deploy" target="_blank" rel="external nofollow noopener noreferrer">github</a>)，这里选择yum下载(ceph-admin)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; yum install http://mirrors.163.com/ceph/rpm-jewel/el7/noarch/ceph-deploy-1.5.38-0.noarch.rpm</span><br><span class="line">...</span><br><span class="line">&gt;&gt; ceph-deploy --version</span><br><span class="line">1.5.38</span><br></pre></td></tr></table></figure>

<h3 id="2、创建集群的准备"><a href="#2、创建集群的准备" class="headerlink" title="2、创建集群的准备"></a>2、创建集群的准备</h3><p>继续ceph-admin中准备环节：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; mkdir my-cluster</span><br><span class="line">&gt;&gt; <span class="built_in">cd</span> my-cluster</span><br><span class="line">&gt;&gt; ceph-deploy new ceph-node1 ceph-node2 ceph-node2</span><br><span class="line">...</span><br><span class="line">&gt;&gt; vim ceph.conf</span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">fsid = 9f1ae8b0-7d7a-45b9-9b19-663ced7397a1</span><br><span class="line">mon_initial_members = ceph-node1, ceph-node2, ceph-node3</span><br><span class="line">mon_host = 192.168.1.129,192.168.1.126,192.168.1.128</span><br><span class="line">auth_cluster_required = cephx</span><br><span class="line">auth_service_required = cephx</span><br><span class="line">auth_client_required = cephx</span><br><span class="line"><span class="comment"># 添加以下内容</span></span><br><span class="line">mon_clock_drift_allowed = 5</span><br><span class="line">osd_journal_size = 20480</span><br><span class="line">public_network = 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<h3 id="3、创建集群"><a href="#3、创建集群" class="headerlink" title="3、创建集群"></a>3、创建集群</h3><p>开始在各个节点安装ceph，还是在ceph-admin上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph-deploy install --release jewel --repo-url http://mirrors.163.com/ceph/rpm-jewel/el7 --gpg-url http://mirrors.163.com/ceph/keys/release.asc ceph-admin ceph-node1 ceph-node2 ceph-node3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>之所以在admin节点安装是为了一些配置和后续直接在admin上测试。</p>
<p>安装完成后检查成功与否：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph -v</span><br><span class="line"></span><br><span class="line">ceph version 10.2.11 (e4b061b47f07f583c92a050d9e84b1813a35671e)</span><br></pre></td></tr></table></figure>

<p>在ceph-admin上也配置权限查看ceph信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph-deploy admin ceph-master</span><br></pre></td></tr></table></figure>

<p>对了，我们是root用户，如果是自定义用户的话，可能需要对秘钥文件进行权限配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; chmod +r /etc/ceph/ceph.client.admin.keyring</span><br></pre></td></tr></table></figure>

<h3 id="4、配置集群"><a href="#4、配置集群" class="headerlink" title="4、配置集群"></a>4、配置集群</h3><p>初始化mon，须知道，ceph-deploy的这些操作需要在<code>my-cluster</code>目录下，读取我们<code>new</code>创建的<code>ceph.conf</code>文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph-deploy mon create-initial</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>各个节点查看当前ceph情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ceph -s</span><br></pre></td></tr></table></figure>

<p>当然是报错的，因为没有osd呢，所以开始准备osd吧</p>
<h3 id="5、OSD准备"><a href="#5、OSD准备" class="headerlink" title="5、OSD准备"></a>5、OSD准备</h3><p>osd节点上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; lsblk</span><br><span class="line"></span><br><span class="line">NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0   20G  0 disk</span><br><span class="line">├─sda1            8:1    0    1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0   19G  0 part</span><br><span class="line">  ├─centos-root 253:0    0   17G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]</span><br><span class="line">sdb               8:16   0   10G  0 disk</span><br><span class="line">sdc               8:32   0   20G  0 disk</span><br><span class="line">sr0              11:0    1 1024M  0 rom</span><br></pre></td></tr></table></figure>

<p>/dev/sdb我准备用来作为日志硬盘，/dev/sdc作为osd存储硬盘，根据流程来，首先给日志盘分区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; fdisk /dev/sdb</span><br><span class="line">...</span><br><span class="line"><span class="comment"># 输入n分区，其它默认，只分一个区，输入p查看当前分区，w结束分区</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; chown ceph:ceph /dev/sdb1</span><br><span class="line"><span class="comment"># 给日志硬盘操作权限，给admin来初始化使用</span></span><br></pre></td></tr></table></figure>

<h3 id="6、添加OSD"><a href="#6、添加OSD" class="headerlink" title="6、添加OSD"></a>6、添加OSD</h3><p>ceph-admin上执行以下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph-deploy osd create ceph-node1:/dev/sdc:/dev/sdb1 ceph-node2:/dev/sdc:/dev/sdb1 ceph-node3:/dev/sdc:/dev/sdb1</span><br></pre></td></tr></table></figure>

<p>再查看<code>ceph  -s</code>即可看到健康情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ceph osd tree</span><br><span class="line"><span class="comment"># 查看当前osd健康</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>ceph</tag>
      </tags>
  </entry>
  <entry>
    <title>fabric使用笔记</title>
    <url>/posts/a6ebedf/</url>
    <content><![CDATA[<p>官方文档在这: <a href="http://fabric-chs.readthedocs.io/zh_CN/chs/tutorial.html" target="_blank" rel="external nofollow noopener noreferrer">Fabric</a></p>
<p>废话不多说，直接上代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Time    : 2018&#x2F;8&#x2F;9 10:13</span><br><span class="line"># @Author  : vissssa</span><br><span class="line"># @Email   : 292724306@qq.com</span><br><span class="line"># @File    : fabfile.py</span><br><span class="line"># @Software: PyCharm</span><br><span class="line">from fabric.api import *</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">env.user &#x3D; &#39;root&#39;</span><br><span class="line"></span><br><span class="line">zookeeper01 &#x3D; &#39;root@192.168.1.168&#39;</span><br><span class="line">zookeeper02 &#x3D; &#39;root@192.168.1.167&#39;</span><br><span class="line">zookeeper03 &#x3D; &#39;root@192.168.1.166&#39;</span><br><span class="line">nimbus &#x3D; &#39;root@192.168.1.164&#39;</span><br><span class="line">nimbus_noroot &#x3D; &#39;123@192.168.1.164&#39;</span><br><span class="line">supervisor01 &#x3D; &#39;root@192.168.1.165&#39;</span><br><span class="line">supervisor02 &#x3D; &#39;root@192.168.1.163&#39;</span><br><span class="line"></span><br><span class="line">local_dir &#x3D; &#39;&#x2F;Users&#x2F;zhangyu&#x2F;PycharmProjects&#x2F;fabric_test&#x2F;local_dir&#39;</span><br><span class="line">remote_dir &#x3D; &#39;&#x2F;home&#x2F;123&#x2F;project_dpi&#39;</span><br><span class="line"></span><br><span class="line"># 为了后续分类并行执行命令</span><br><span class="line">env.roledefs &#x3D; &#123;</span><br><span class="line">    &#39;zookeeper&#39;: [zookeeper01, zookeeper02, zookeeper03],</span><br><span class="line">    &#39;zookeeper01&#39;: [zookeeper01],</span><br><span class="line">    &#39;zookeeper02&#39;: [zookeeper02],</span><br><span class="line">    &#39;zookeeper03&#39;: [zookeeper03],</span><br><span class="line">    &#39;nimbus&#39;: [nimbus],</span><br><span class="line">    &#39;supervisor01&#39;: [supervisor01],</span><br><span class="line">    &#39;supervisor02&#39;: [supervisor02],</span><br><span class="line">    &#39;storm&#39;: [nimbus, supervisor01, supervisor02],</span><br><span class="line">    &#39;nimbus_noroot&#39;: [nimbus_noroot]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 需要注意的是，这里的host strings必须由username@host:port三部分构成，缺一不可，否则运行时还是会要求输入密码</span><br><span class="line">env.passwords &#x3D; &#123;</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(zookeeper01): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(zookeeper02): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(zookeeper03): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(nimbus): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(supervisor01): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(supervisor02): &#39;123123&#39;,</span><br><span class="line">    &#39;&#123;&#125;:22&#39;.format(nimbus_noroot): &#39;123&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;zookeeper&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def put_zookeeper():</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;zookeeper-3.4.9.tar.gz&#39;.format(local_dir), &#39;&#x2F;usr&#x2F;local&#x2F;zookeeper-3.4.9.tar.gz&#39;)</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#39;):</span><br><span class="line">        run(&#39;tar -zxvf zookeeper-3.4.9.tar.gz&#39;)</span><br><span class="line">        run(&#39;mv zookeeper-3.4.9 zookeeper&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;zoo.cfg&#39;.format(local_dir), &#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;conf&#x2F;zoo.cfg&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 2181 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 2888 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 3888 -j ACCEPT&#39;)</span><br><span class="line">    # 讲开放端口保存到配置中</span><br><span class="line">    run(&#39;service iptables save&#39;)</span><br><span class="line">    run(&#39;service iptables restart&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三种不同的myid</span><br><span class="line">@roles(&#39;zookeeper01&#39;)</span><br><span class="line">def myid1():</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#39;):</span><br><span class="line">        run(&#39;mkdir -p -p data&#39;)</span><br><span class="line">        run(&#39;echo 0 &gt;&gt; data&#x2F;myid&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;zookeeper02&#39;)</span><br><span class="line">def myid2():</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#39;):</span><br><span class="line">        run(&#39;mkdir -p -p data&#39;)</span><br><span class="line">        run(&#39;echo 1 &gt;&gt; data&#x2F;myid&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;zookeeper03&#39;)</span><br><span class="line">def myid3():</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#39;):</span><br><span class="line">        run(&#39;mkdir -p -p data&#39;)</span><br><span class="line">        run(&#39;echo 2 &gt;&gt; data&#x2F;myid&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;zookeeper&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def start_zkp():</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#39;):</span><br><span class="line">        run(&#39;bin&#x2F;zkServer.sh start&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;zookeeper&#39;)</span><br><span class="line">def status_zkp():</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;local&#x2F;zookeeper&#39;):</span><br><span class="line">        run(&#39;bin&#x2F;zkServer.sh status&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task_zkp():</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;zkp start: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(put_zookeeper)</span><br><span class="line">    execute(myid1)</span><br><span class="line">    execute(myid2)</span><br><span class="line">    execute(myid3)</span><br><span class="line">    execute(start_zkp)</span><br><span class="line">    # execute(status_zkp)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;zkp end: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def put_storm():</span><br><span class="line">    run(&#39;mkdir -p &#123;&#125; &amp;&amp; chmod 777 &#123;&#125;&#39;.format(remote_dir, remote_dir))</span><br><span class="line">    # 偶尔系统会自动更新，所以先把yum进程杀掉</span><br><span class="line">    run(&#39;rm -rf &#x2F;var&#x2F;run&#x2F;yum.pid&#39;)</span><br><span class="line">    run(&#39;yum install java-1.8.0-openjdk -y&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;apache-storm-1.1.2.tar.gz&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;apache-storm-1.1.2.tar.gz&#39;.format(remote_dir))</span><br><span class="line">    with cd(remote_dir):</span><br><span class="line">        run(&#39;tar zxvf apache-storm-1.1.2.tar.gz&#39;)</span><br><span class="line">        run(&#39;mkdir -p storm_data&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;storm.yaml&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;conf&#x2F;storm.yaml&#39;.format(remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;nimbus&#39;)</span><br><span class="line">def put_hostname_n():</span><br><span class="line">    # 把 storm.local.hostname:192.168.1.111 添加到第6行</span><br><span class="line">    run(&#39;&#39;&#39;sed -i &quot;6i storm.local.hostname: &#39;&#123;&#125;&#39;&quot; &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;conf&#x2F;storm.yaml&#39;&#39;&#39;.format(</span><br><span class="line">        nimbus.replace(&#39;root@&#39;, &#39;&#39;), remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;supervisor01&#39;)</span><br><span class="line">def put_hostname_s1():</span><br><span class="line">    run(&#39;&#39;&#39;sed -i &quot;6i storm.local.hostname: &#39;&#123;&#125;&#39;&quot; &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;conf&#x2F;storm.yaml&#39;&#39;&#39;.format(</span><br><span class="line">        supervisor01.replace(&#39;root@&#39;, &#39;&#39;), remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;supervisor02&#39;)</span><br><span class="line">def put_hostname_s2():</span><br><span class="line">    run(&#39;&#39;&#39;sed -i &quot;6i storm.local.hostname: &#39;&#123;&#125;&#39;&quot; &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;conf&#x2F;storm.yaml&#39;&#39;&#39;.format(</span><br><span class="line">        supervisor02.replace(&#39;root@&#39;, &#39;&#39;), remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 放在一条命令中执行，且加上sleep，防止因为终端session关闭导致后台任务关闭</span><br><span class="line">@roles(&#39;nimbus&#39;)</span><br><span class="line">def start_n():</span><br><span class="line">    run(&quot;$(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm ui &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1 &quot;</span><br><span class="line">        &quot;&amp;&amp; $(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm nimbus &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1&quot;</span><br><span class="line">        &quot;&amp;&amp; $(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm logviewer &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1&quot;.format(remote_dir,</span><br><span class="line">                                                                                                    remote_dir,</span><br><span class="line">                                                                                                    remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;supervisor01&#39;)</span><br><span class="line">def start_s1():</span><br><span class="line">    run(&quot;$(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm supervisor &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1 &quot;</span><br><span class="line">        &quot;&amp;&amp; $(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm logviewer &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1&quot;.format(remote_dir,</span><br><span class="line">                                                                                                    remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;supervisor02&#39;)</span><br><span class="line">def start_s2():</span><br><span class="line">    run(&quot;$(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm supervisor &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1 &quot;</span><br><span class="line">        &quot;&amp;&amp; $(nohup &#123;&#125;&#x2F;apache-storm-1.1.2&#x2F;bin&#x2F;storm logviewer &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;) &amp;&amp; sleep 1&quot;.format(remote_dir,</span><br><span class="line">                                                                                                    remote_dir))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def ip_storm():</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 8000 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 8080 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 6627 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 6700 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 6701 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 6702 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;iptables -I INPUT -m state --state NEW -p tcp --dport 6703 -j ACCEPT&#39;)</span><br><span class="line">    run(&#39;service iptables save&#39;)</span><br><span class="line">    run(&#39;service iptables restart&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 杀掉storm任务</span><br><span class="line">@roles(&#39;supervisor02&#39;)</span><br><span class="line">def stop_storm():</span><br><span class="line">    # run(&quot;kill &#96;ps aux | egrep &#39;(daemon\.nimbus)|(storm\.ui\.core)&#39; | fgrep -v egrep | awk &#39;&#123;print $2&#125;&#39;&#96;&quot;)</span><br><span class="line">    run(&quot;kill &#96;ps aux | fgrep storm | fgrep -v &#39;fgrep&#39; | awk &#39;&#123;print $2&#125;&#39;&#96;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task_storm():</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;storm start: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(put_storm)</span><br><span class="line">    execute(put_hostname_n)</span><br><span class="line">    execute(put_hostname_s1)</span><br><span class="line">    execute(put_hostname_s2)</span><br><span class="line">    execute(ip_storm)</span><br><span class="line">    execute(start_n)</span><br><span class="line">    execute(start_s1)</span><br><span class="line">    execute(start_s2)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;storm end: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def put_python3():</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;Python-3.6.6.tgz&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;Python-3.6.6.tgz&#39;.format(remote_dir))</span><br><span class="line">    with cd(remote_dir):</span><br><span class="line">        run(&#39;rm -rf &#x2F;var&#x2F;run&#x2F;yum.pid&#39;)</span><br><span class="line">        run(&#39;yum install zlib-devel bzip2-devel openssl-devel ncurese-devel gcc zlib sqlite-devel -y&#39;)</span><br><span class="line">        run(&#39;tar zxvf Python-3.6.6.tgz&#39;)</span><br><span class="line">        with cd(&#39;Python-3.6.6&#39;):</span><br><span class="line">            run(&#39;.&#x2F;configure --enable-loadable-sqlite-extensions --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python3 &amp;&amp; make &amp;&amp; make install&#39;)</span><br><span class="line"></span><br><span class="line">    run(&#39;ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python3&#39;)</span><br><span class="line">    run(&#39;ln -s &#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip3&#39;)</span><br><span class="line">    with cd(&#39;~&#x2F;.config&#39;):</span><br><span class="line">        run(&#39;mkdir -p pip&#39;)</span><br><span class="line">        put(&#39;&#123;&#125;&#x2F;pip.conf&#39;.format(local_dir), &#39;~&#x2F;.config&#x2F;pip&#x2F;pip.conf&#39;)</span><br><span class="line">    run(&#39;pip3 install virtualenv&#39;)</span><br><span class="line">    run(&#39;&#39;&#39;echo &#39;export PATH&#x3D;&quot;$PATH:&#x2F;usr&#x2F;local&#x2F;python3&#x2F;bin&quot;&#39; &gt;&gt; &#x2F;etc&#x2F;profile&#39;&#39;&#39;)</span><br><span class="line">    run(&#39;source &#x2F;etc&#x2F;profile&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def update_glibc():</span><br><span class="line">    # 找到新的快速升级方法</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;glibc-2.17-55.el6.x86_64.rpm&#39;.format(local_dir),</span><br><span class="line">        &#39;&#123;&#125;&#x2F;glibc-2.17-55.el6.x86_64.rpm&#39;.format(remote_dir))</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;glibc-common-2.17-55.el6.x86_64.rpm&#39;.format(local_dir),</span><br><span class="line">        &#39;&#123;&#125;&#x2F;glibc-common-2.17-55.el6.x86_64.rpm&#39;.format(remote_dir))</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;glibc-devel-2.17-55.el6.x86_64.rpm&#39;.format(local_dir),</span><br><span class="line">        &#39;&#123;&#125;&#x2F;glibc-devel-2.17-55.el6.x86_64.rpm&#39;.format(remote_dir))</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;glibc-headers-2.17-55.el6.x86_64.rpm&#39;.format(local_dir),</span><br><span class="line">        &#39;&#123;&#125;&#x2F;glibc-headers-2.17-55.el6.x86_64.rpm&#39;.format(remote_dir))</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;update_glibc.sh&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;update_glibc.sh&#39;.format(remote_dir))</span><br><span class="line">    run(&#39;yum install kernel-headers -y&#39;)</span><br><span class="line">    with cd(remote_dir):</span><br><span class="line">        run(&#39;bash update_glibc.sh&#39;)</span><br><span class="line">    run(&#39;strings &#x2F;lib64&#x2F;libc.so.6 | grep GLIBC&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def update_gcc():</span><br><span class="line">    # 直接安装gcc-4.8.1会出现make error的情况， 所以我直接拿生成好的libstdc++so.6.18来替换</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;libstdc++.so.6.0.18&#39;.format(local_dir), &#39;&#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6.0.18&#39;)</span><br><span class="line">    with cd(&#39;&#x2F;usr&#x2F;lib64&#39;):</span><br><span class="line">        run(&#39;rm -rf libstdc++.so.6&#39;)</span><br><span class="line">        run(&#39;ln -s libstdc++.so.6.0.18 libstdc++.so.6&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task_env():</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;env start: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(put_python3)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;glibc start: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(update_glibc)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;glibc end: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(update_gcc)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;env end: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># lein和sparse submit只能在非root中执行</span><br><span class="line">@roles(&#39;nimbus_noroot&#39;)</span><br><span class="line">def start_project():</span><br><span class="line">    # 下载容易出问题，换成直接上传包</span><br><span class="line">    run(&#39;mkdir -p ~&#x2F;bin&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;lein&#39;.format(local_dir), &#39;~&#x2F;bin&#x2F;lein&#39;)</span><br><span class="line">    run(&#39;mkdir -p ~&#x2F;.lein&#x2F;self-installs&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;leiningen-2.8.1-standalone.jar&#39;.format(local_dir),</span><br><span class="line">        &#39;~&#x2F;.lein&#x2F;self-installs&#x2F;leiningen-2.8.1-standalone.jar&#39;)</span><br><span class="line">    run(&#39;chmod a+x ~&#x2F;bin&#x2F;lein&#39;)</span><br><span class="line"></span><br><span class="line">    execute(pip)</span><br><span class="line">    execute(nimbus_pip)</span><br><span class="line"></span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;dpi_detection.zip&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;dpi_detection.zip&#39;.format(remote_dir))</span><br><span class="line">    with cd(remote_dir):</span><br><span class="line">        run(&#39;unzip dpi_detection.zip&#39;)</span><br><span class="line">        with cd(&#39;dpi_detection&#39;):</span><br><span class="line">            run(&#39;sparse submit&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;storm&#39;)</span><br><span class="line">@parallel</span><br><span class="line">def pip():</span><br><span class="line">    # 安装python3所需要的包</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;requirements.txt&#39;.format(local_dir), &#39;&#123;&#125;&#x2F;requirements.txt&#39;.format(remote_dir))</span><br><span class="line">    run(&#39;source &#x2F;etc&#x2F;profile &amp;&amp; virtualenv &#x2F;data&#x2F;virtualenvs&#x2F;dpi_detection&#39;)</span><br><span class="line">    put(&#39;&#123;&#125;&#x2F;torch-0.4.1-cp36-cp36m-linux_x86_64.whl&#39;.format(local_dir),</span><br><span class="line">        &#39;&#123;&#125;&#x2F;torch-0.4.1-cp36-cp36m-linux_x86_64.whl&#39;.format(remote_dir))</span><br><span class="line">    # 偶尔因为网络问题断开，所以三次重试</span><br><span class="line">    for i in range(0, 3):</span><br><span class="line">        try:</span><br><span class="line">            run(&#39;source &#x2F;data&#x2F;virtualenvs&#x2F;dpi_detection&#x2F;bin&#x2F;activate &#39;</span><br><span class="line">                &#39;&amp;&amp; pip3 install &#123;&#125;&#x2F;torch-0.4.1-cp36-cp36m-linux_x86_64.whl &#39;</span><br><span class="line">                &#39;&amp;&amp; pip3 install -r &#123;&#125;&#x2F;requirements.txt&#39;.format(remote_dir, remote_dir))</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    # root权限创建日志文件夹</span><br><span class="line">    run(&#39;mkdir -p &#x2F;var&#x2F;log&#x2F;storm&#x2F;streamparse&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@roles(&#39;nimbus&#39;)</span><br><span class="line">def nimbus_pip():</span><br><span class="line">    for i in range(0, 3):</span><br><span class="line">        try:</span><br><span class="line">            run(&#39;pip3 install --upgrade pip&#39;)</span><br><span class="line">            run(&#39;pip3 install &#123;&#125;&#x2F;torch-0.4.1-cp36-cp36m-linux_x86_64.whl&#39;.format(remote_dir))</span><br><span class="line">            run(&#39;pip3 install -r &#123;&#125;&#x2F;requirements.txt&#39;.format(remote_dir))</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task_project():</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;project start: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line">    execute(start_project)</span><br><span class="line">    with open(&#39;time.txt&#39;, &#39;a&#39;) as f:</span><br><span class="line">        f.write(&#39;project end: &#123;&#125; \n&#39;.format(str(datetime.now())))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def task():</span><br><span class="line">    execute(task_zkp)</span><br><span class="line">    execute(task_storm)</span><br><span class="line">    execute(task_env)</span><br><span class="line">    execute(task_project)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def glibc():</span><br><span class="line">    run(&#39;strings &#x2F;lib64&#x2F;libc.so.6 | grep GLIBC&#39;)</span><br><span class="line">    run(&#39;strings &#x2F;usr&#x2F;lib64&#x2F;libstdc++.so.6 | grep GLIBCXX&#39;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>artifact</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/posts/423abe9e/</url>
    <content><![CDATA[<h4 id="1、建立联系"><a href="#1、建立联系" class="headerlink" title="1、建立联系"></a>1、建立联系</h4><p>首先在git代码存储网站上(github,gitlab,coding等)配置SSH公钥</p>
<p>要添加一个 SSH 密钥, 需要生成一个或使用一个现有的 key:</p>
<ol>
<li><p>To generate a new SSH key pair, use the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; ssh-keygen -o -t rsa -C <span class="string">"v*****a@163.com"</span> -b 4096</span><br></pre></td></tr></table></figure>

<p>然后回车就完事了</p>
</li>
<li><p>查看并复制你的ssh key:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">ssh-rsa AAAA********* v*****a@163.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加到git管理网站即可</p>
</li>
</ol>
<h4 id="2、初始化git配置"><a href="#2、初始化git配置" class="headerlink" title="2、初始化git配置"></a>2、初始化git配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; git config --global user.email <span class="string">"v*****a@163.com"</span></span><br><span class="line">&gt;&gt; git config --global user.name <span class="string">"v*****a"</span></span><br></pre></td></tr></table></figure>



<h4 id="3、初始化本地项目"><a href="#3、初始化本地项目" class="headerlink" title="3、初始化本地项目"></a>3、初始化本地项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">cd</span> project</span><br><span class="line">&gt;&gt; git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /home/**/project/.git/</span><br><span class="line">&gt;&gt; git add .</span><br><span class="line">&gt;&gt; git commit -m <span class="string">"初始化"</span></span><br><span class="line">&gt;&gt; git remote add origin git@git.dev.tencent.com:v*****a/project.git</span><br><span class="line">&gt;&gt; git push -u originls</span><br></pre></td></tr></table></figure>



<h4 id="4、后续修改"><a href="#4、后续修改" class="headerlink" title="4、后续修改"></a>4、后续修改</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; vim .gitignore</span><br><span class="line">__pycache__/</span><br><span class="line"></span><br><span class="line">&gt;&gt; git add .gitignore</span><br><span class="line">&gt;&gt; git commit -m <span class="string">"add gitignore"</span></span><br><span class="line">&gt;&gt; git push</span><br></pre></td></tr></table></figure>



<h2 id="某些不能在IDE或者sourcetree上处理的需求"><a href="#某些不能在IDE或者sourcetree上处理的需求" class="headerlink" title="某些不能在IDE或者sourcetree上处理的需求"></a>某些不能在IDE或者sourcetree上处理的需求</h2><ol>
<li><p>强制从远端拉取代码覆盖本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; git fetch --all</span><br><span class="line">&gt;&gt; git reset --hard origin/master</span><br><span class="line">&gt;&gt; git pull</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fetch</code> + <code>merge</code> = <code>pull</code>，拉取远端仓库的commit历史，再与本地进行merge合并</p>
</li>
<li><p>删除本地以及远端的文件或文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt; git rm foo/settings.py</span><br><span class="line">&gt;&gt; git rm **/__pycache__</span><br><span class="line">&gt;&gt; git rm **/**/__pycache__</span><br><span class="line"></span><br><span class="line">&gt;&gt; git commit -m <span class="string">'删除'</span></span><br><span class="line">&gt;&gt; git push</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins+github+gitbook</title>
    <url>/posts/52ded20/</url>
    <content><![CDATA[<h2 id="一、下载Jenkins"><a href="#一、下载Jenkins" class="headerlink" title="一、下载Jenkins"></a>一、下载Jenkins</h2><h3 id="1-Ubuntu"><a href="#1-Ubuntu" class="headerlink" title="1.Ubuntu"></a>1.Ubuntu</h3><p>包含在默认Ubuntu软件包中的Jenkins版本往往落后于项目本身的最新版本。 为了利用最新的修复和功能，我们将使用项目维护的软件包来安装Jenkins。</p>
<p>首先，我们将存储库密钥添加到系统。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<p>添加密钥后，系统将返回<code>OK</code> 。 接下来，我们将Debian包存储库地址附加到服务器的<code>sources.list</code> ：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> deb http://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list</span><br></pre></td></tr></table></figure>

<p>当这两个都到位时，我们将运行<code>update</code> ，以便<code>apt-get</code>将使用新的存储库：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>最后，我们将安装Jenkins及其依赖项，包括Java：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install jenkins</span><br></pre></td></tr></table></figure>

<p>现在Jenkins及其依赖项已经到位，我们将启动Jenkins服务器。</p>
<h3 id="2-Centos7"><a href="#2-Centos7" class="headerlink" title="2.Centos7"></a>2.Centos7</h3><p>Add the repository key with the following command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span></span><br></pre></td></tr></table></figure>

<p> Now we will add the package repository address to our repository list with the command below:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</span></span><br></pre></td></tr></table></figure>

<p> Update your package manager list to get the latest packages:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum repolist</span></span><br></pre></td></tr></table></figure>

<p> Finally, install Jenkins and JAVA with the following command:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> yum install java-1.8.0-openjdk jenkins</span></span><br></pre></td></tr></table></figure>

<h2 id="二、安装Jenkins"><a href="#二、安装Jenkins" class="headerlink" title="二、安装Jenkins"></a>二、安装Jenkins</h2><p>使用<code>systemctl</code>我们将启动Jenkins：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用systemctl我们将启动Jenkins：</span></span><br><span class="line">$ systemctl start jenkins</span><br></pre></td></tr></table></figure>

<p>If you want to make it run at startup execute the command below as well:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl <span class="built_in">enable</span> jenkins</span></span><br></pre></td></tr></table></figure>

<p>由于<code>systemctl</code>不显示输出，我们将使用其<code>status</code>命令来验证它是否成功启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl status jenkins</span><br></pre></td></tr></table></figure>

<p>如果一切顺利，输出的开始应显示服务处于活动状态，并配置为启动时启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">● jenkins.service - LSB: Start Jenkins at boot time</span><br><span class="line">   Loaded: loaded (/etc/init.d/jenkins; bad; vendor preset: enabled)</span><br><span class="line">   Active: active (exited) since Thu 2018-08-16 17:24:05 CST; 3 days ago</span><br><span class="line">     Docs: man:systemd-sysv-generator(8)</span><br><span class="line">  Process: 9790 ExecStart=/etc/init.d/jenkins start (code=exited, status=0/SUCCESS)</span><br><span class="line">    Tasks: 0</span><br><span class="line">   Memory: 0B</span><br><span class="line">      CPU: 0</span><br></pre></td></tr></table></figure>

<p>现在Jenkins正在运行，我们将调整防火墙规则，以便我们可以从网络浏览器到达Jenkins以完成初始设置。</p>
<p><strong>接着安装</strong></p>
<p>我们打开 <a href="http://localhost:8080" target="_blank" rel="external nofollow noopener noreferrer">http://localhost:8080</a> 按照流程安装即可。</p>
<h2 id="三、安装部署Gitbook"><a href="#三、安装部署Gitbook" class="headerlink" title="三、安装部署Gitbook"></a>三、安装部署Gitbook</h2><p>安装Gitbook的前提条件是需要有NodeJS和npm，这个在<a href="Ubuntu和centos安装NodeJS.md">Ubuntu和centos安装NodeJS</a>记录，自行查阅。</p>
<p>这里就直接安装了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g gitbook-cli</span><br></pre></td></tr></table></figure>

<p>值得注意的是我们的book的格式需要严格遵循他的准则：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu@VM-19-176-ubuntu:~$ tree -L 1 gitbook/</span><br><span class="line">gitbook/</span><br><span class="line">├── notes</span><br><span class="line">├── pics</span><br><span class="line">├── README.md</span><br><span class="line">└── SUMMARY.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开SUMMARY.md可以看到我们的目录结构</span></span><br><span class="line"><span class="comment"># Summary</span></span><br><span class="line"></span><br><span class="line">* [没什么好说的](README.md)</span><br><span class="line">* [Python抱佛脚](notes/learn/README.md)</span><br><span class="line">   * [题目一](notes/learn/题目一.md)</span><br><span class="line">   * [题目二](notes/learn/题目二.md)</span><br><span class="line">* [Python原理的东西](notes/deep/README.md)</span><br><span class="line">   * [GIL是个什么东西](notes/deep/GIL.md)</span><br><span class="line">   * [没事多看看](notes/deep/文章资料.md)</span><br><span class="line">* [环境搭建](notes/env/README.md)</span><br><span class="line">   * [Storm集群搭建](notes/env/Storm集群搭建.md)</span><br><span class="line">   * [Storm集群与Python项目的实践](notes/env/Storm集群与Python项目的实践.md)</span><br><span class="line">   * [Ubuntu安装NodeJS](notes/env/Ubuntu安装NodeJS.md)</span><br><span class="line">* [Python神の器](notes/artifact/README.md)</span><br><span class="line">   * [Fabric](notes/artifact/fabric.md)</span><br><span class="line">   * [单元测试pytest](notes/artifact/pytest.md)</span><br><span class="line">* [网络](notes/network/README.md)</span><br><span class="line">   * [计算机网络](notes/network/计算机网络.md)</span><br><span class="line">   * [HTTP](notes/network/HTTP.md)</span><br></pre></td></tr></table></figure>

<p>在这个项目下进行gitbook的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化</span></span><br><span class="line">$ gitbook init</span><br><span class="line"><span class="comment"># 编译生成静态网页，到这步就结束了，后面是为了调试</span></span><br><span class="line">$ gitbook build</span><br><span class="line"><span class="comment"># 调试访问</span></span><br><span class="line">$ gitbook serve</span><br></pre></td></tr></table></figure>

<h2 id="四、配置Jenkins"><a href="#四、配置Jenkins" class="headerlink" title="四、配置Jenkins"></a>四、配置Jenkins</h2><p>第二部安装Jenkins时，我选择的是默认安装，所以不需要再独自安装github插件。</p>
<ul>
<li>第一步，获取github的开发者秘钥，后续我们jenkins中配置需要使用秘钥验证</li>
</ul>
<p><img alt="秘钥" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/github_developer_settings.png"></p>
<p>接着将秘钥配置到jenkins中，使得可以下载github中的代码</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/jenkins_github.png"></p>
<p>add中配置</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/jenkins_add_secret.png"></p>
<p>这里就是完成了jenkins的配置，接下来在github中配置钩子，当项目发生变化，就调用钩子，打通jenkins</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/github_webhook.png"></p>
<p>最后就是在jenkins中新建一个job来自动化我们的项目：</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/jenkins_gitbook_config.png"></p>
<p>最后一个我们这里填的是项目的地址，因为我这个项目包含大量图片，从github下载慢，所以现在本地已经做好了准备，中间的github需要账号密码，不是秘钥，切记。</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/jenkins_gitbook_config2.png"></p>
<p>这里就完成了我们这个Jenkins+Github+Gitbook的自动化版本控制以及部署的过程</p>
<h2 id="五、需要注意"><a href="#五、需要注意" class="headerlink" title="五、需要注意"></a>五、需要注意</h2><p>因为首先我已经在nginx中配置好了gitbook的路径，所以只需要在项目中编译完成静态网页即可，<del>另外，项目的权限需要开启为所有用户均可rwx，因为jenkins是linux下新建了一个jenkins用户来运行的，对于没有权限的文件，他是无权处理的。</del></p>
<p>超级坑的jenkins，各种权限以及命令无法找到，经过各种尝试后发现以下可以</p>
<ol>
<li><p>修改/etc/sysconfig/jenkins 的用户和组为root</p>
</li>
<li><p>修改gitbook目录为777(有可能不需要，并未尝试了)</p>
</li>
<li><p>更改jenkins 的配置中的shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/zhangyu/gitbook</span><br><span class="line">source ~/.bash_profile</span><br><span class="line">/root/.nvm/versions/node/v10.10.0/bin/gitbook build</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>真的太无语了，垃圾</p>
<p>多天以后我发现磁盘空间满了，经过</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find / -size +1024M</span></span><br></pre></td></tr></table></figure>

<p>发现是jenkins的日志文件高达37G，删除之后，系统正常，<del>查看资料在jenkins配置中配置相关</del>，<del>怀疑是关于dns的报错信息，这里等待一段时日再来观察是否有效</del></p>
<p>重启消失，所以只能计划任务，每周删除一次</p>
<p><img alt="jenkins_log_setting" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/jenkins_log_setting.png"></p>
]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>github</tag>
        <tag>gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s权威指南demo</title>
    <url>/posts/88ebdabd/</url>
    <content><![CDATA[<ol>
<li><p>创建一个虚拟linux环境，本次是centos7</p>
</li>
<li><p>关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line">$ systemctl stop firewalld</span><br><span class="line">$ service iptables stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装etcd和k8s，docker会自动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum install -y etcd kubernetes</span><br></pre></td></tr></table></figure>
</li>
<li><p>加上认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ openssl genrsa -out /tmp/service_account.key 2048</span><br><span class="line"></span><br><span class="line">$ vim /etc/kubernetes/apiserver</span><br><span class="line">KUBE_API_ARGS=<span class="string">"--secure-port=0 --service-account-key-file=/etc/kubernetes/service_account.key"</span></span><br><span class="line"></span><br><span class="line">$ vim /etc/kubernetes/controller-manager</span><br><span class="line">KUBE_CONTROLLER_MANAGER_ARGS=<span class="string">"--service_account_private_key_file=/etc/kubernetes/service_account.key"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改pod镜像的地址，因为原地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error syncing pod, skipping: failed to &quot;StartContainer&quot; for &quot;POD&quot; with ErrImagePull: &quot;image pull failed for registry.access.redhat.com&#x2F;rhel7&#x2F;pod-infrastructure:latest, this may be because there are no credentials on this request.  details: (open &#x2F;etc&#x2F;docker&#x2F;certs.d&#x2F;registry.access.redhat.com&#x2F;redhat-ca.crt: no such file or directory)&quot;</span><br><span class="line"># 需要ca验证 但是本地安装rhsm并没有用</span><br></pre></td></tr></table></figure>

<p>所以更换为<code>docker search pod-infrastructure</code>，并修改k8s配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/kubernetes/kubelet</span><br><span class="line">KUBELET_POD_INFRA_CONTAINER=<span class="string">"--pod-infra-container-image=docker.io/tianyebj/pod-infrastructure:latest"</span></span><br><span class="line">$ systemctl restart kubelet</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写k8s的service和rc文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim mysql-rc.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController  <span class="comment"># 副本控制器 RC，kubectl生成的是rc</span></span><br><span class="line">metadata:</span><br><span class="line">  name: mysql	<span class="comment"># rc的名称，全局唯一</span></span><br><span class="line">spec:</span><br><span class="line">  replicas: 1   <span class="comment"># pod的副本数量</span></span><br><span class="line">  selector:</span><br><span class="line">    app: mysql	<span class="comment"># 符合目标的Pod拥有此标签</span></span><br><span class="line">  template:		<span class="comment"># 根据此模板创建Pod的副本(实例)</span></span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: mysql	<span class="comment"># Pod副本拥有的标签，对应RC的selector</span></span><br><span class="line">    spec:</span><br><span class="line">      containers:	<span class="comment"># Pod内容器的定义部分</span></span><br><span class="line">      - name: mysql	<span class="comment"># 容器名称</span></span><br><span class="line">        image: docker.io/mysql:5.7    <span class="comment">#!!mysql必须老版本最好5.7，新版本问题很大需要额外的环境配置</span></span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 3306	<span class="comment"># 容器应用监听的端口号</span></span><br><span class="line">        env:					<span class="comment"># 注入容器内的环境变量</span></span><br><span class="line">        - name: MYSQL_ROOT_PASSWORD</span><br><span class="line">          value: <span class="string">"123456"</span></span><br><span class="line"></span><br><span class="line">$ vim mysql-svc.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service	<span class="comment"># k8s的 Service</span></span><br><span class="line">metadata:</span><br><span class="line">  name: mysql	<span class="comment"># Service的全局唯一名称</span></span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 3306</span><br><span class="line">  selector:</span><br><span class="line">    app: mysql</span><br><span class="line"></span><br><span class="line">$ vim myweb-rc.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    app: myweb</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: myweb</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: myweb</span><br><span class="line">        image: kubeguide/tomcat-app:v1</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 8080</span><br><span class="line"></span><br><span class="line">$ vim myweb-svc.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: myweb</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">    - port: 8080</span><br><span class="line">      nodePort: 30001	<span class="comment"># 对外暴露的端口</span></span><br><span class="line">  selector:</span><br><span class="line">    app: myweb</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写k8s的启动脚本和domo的启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim k8s.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">systemctl <span class="variable">$1</span> etcd</span><br><span class="line">systemctl <span class="variable">$1</span> docker</span><br><span class="line">systemctl <span class="variable">$1</span> kube-apiserver</span><br><span class="line">systemctl <span class="variable">$1</span> kube-controller-manager</span><br><span class="line">systemctl <span class="variable">$1</span> kube-scheduler</span><br><span class="line">systemctl <span class="variable">$1</span> kubelet</span><br><span class="line">systemctl <span class="variable">$1</span> kube-proxy</span><br><span class="line"></span><br><span class="line">$ vim demo.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">kubectl <span class="variable">$1</span> -f /root/kube-demo/mysql-rc.yaml</span><br><span class="line">kubectl <span class="variable">$1</span> -f /root/kube-demo/mysql-svc.yaml</span><br><span class="line">kubectl <span class="variable">$1</span> -f /root/kube-demo/myweb-rc.yaml</span><br><span class="line">kubectl <span class="variable">$1</span> -f /root/kube-demo/myweb-svc.yaml</span><br><span class="line"></span><br><span class="line">$ chmod 755 k8s.sh</span><br><span class="line">$ chmod 755 demo.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动demo项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./k8s.sh start/stop</span><br><span class="line">$ ./demo.sh create/delete</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开localhost:30001可看到tomcat的页面，/demo的页面以下：</p>
</li>
</ol>
<p><img alt="k8sDemo" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/k8sDemo%E5%AE%8C%E6%88%90%E9%A1%B5%E9%9D%A2.png"></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>microsoft_openpai部署记录</title>
    <url>/posts/69ae0990/</url>
    <content><![CDATA[<p>2018 年 5 月 22 日，在微软举办的 “新一代人工智能开放科研教育平台暨中国高校人工智能科研教育高峰论坛” 上，微软亚洲研究院宣布，携手北京大学、中国科学技术大学、西安交通大学和浙江大学四所国内顶尖高校共建新一代人工智能开放科研教育平台，以推动中国人工智能领域科研与教育事业的发展。作为由微软亚洲研究院为该平台提供的三大关键技术之一，Open Platform for AI（OpenPAI）也备受瞩目。</p>
<p>事实上，随着人工智能技术的快速发展，各种深度学习框架层出不穷，为了提高效率，更好地让人工智能快速落地，很多企业都很关注深度学习训练的平台化问题。例如，如何提升 GPU 等硬件资源的利用率？如何节省硬件投入成本？如何支持算法工程师更方便的应用各类深度学习技术，从繁杂的环境运维等工作中解脱出来？等等。</p>
<p>为了解决这些问题，微软亚洲研究院和微软（亚洲）互联网工程院基于各自的特长，联合研发、创建了 OpenPAI，希望为深度学习提供一个深度定制和优化的人工智能集群管理平台，让人工智能堆栈变得简单、快速、可扩展。</p>
<h2 id="为什么要使用-OpenPAI"><a href="#为什么要使用-OpenPAI" class="headerlink" title="为什么要使用 OpenPAI?"></a>为什么要使用 OpenPAI?</h2><p>● 为深度学习量身定做，可扩展支撑更多 AI 和大数据框架</p>
<p>通过创新的 PAI 运行环境支持，几乎所有深度学习框架如 CNTK、TensorFlow、PyTorch 等无需修改即可运行；其基于 Docker 的架构则让用户可以方便地扩展更多 AI 与大数据框架。</p>
<p>● 容器与微服务化，让 AI 流水线实现 DevOps</p>
<p>OpenPAI 100% 基于微服务架构，让 AI 平台以及开发便于实现 DevOps 的开发运维模式。</p>
<p>● 支持 GPU 多租，可统筹集群资源调度与服务管理能力</p>
<p>在深度学习负载下，GPU 逐渐成为资源调度的一等公民，OpenPAI 提供了针对 GPU 优化的调度算法，丰富的端口管理，支持 Virtual Cluster 多租机制，可通过 Launcher Server 为服务作业的运行保驾护航。</p>
<p>● 提供丰富的运营、监控、调试功能，降低运维复杂度</p>
<p>PAI 为运营人员提供了硬件、服务、作业的多级监控，同时开发者还可以通过日志、SSH 等方便调试作业。</p>
<p>● 兼容 AI 开发工具生态</p>
<p>平台实现了与 Visual Studio Tools for AI 等开发工具的深度集成，用户可以一站式进行 AI 开发。</p>
<h2 id="部署OpenPAI"><a href="#部署OpenPAI" class="headerlink" title="部署OpenPAI"></a>部署OpenPAI</h2><h3 id="1、前提准备"><a href="#1、前提准备" class="headerlink" title="1、前提准备"></a>1、前提准备</h3><p>我准备了四台机器，三台用于集群，一台用于部署集群。</p>
<ul>
<li>Ubuntu 18.04 。</li>
<li>每台服务器都有静态 IP 地址，并确保服务器可以相互通信。</li>
<li>确保服务器可以访问互联网，特别是 Docker Hub 或其镜像服务器。 在部署过程中需要拉取 OpenPAI 的 Docker 映像。</li>
<li>确保 SSH 服务已启用，所有服务器使用相同的用户名、密码，并启用 sudo 权限。</li>
<li>确保 NTP 服务已启用。</li>
<li>建议不提前安装 Docker 组件，如果已安装，确保 Docker 版本高于 1.26。</li>
<li>OpenPAI 会保留部分内存和 CPU 资源来运行服务，须确保服务器有足够的资源来运行机器学习作业。 详情参考<a href="https://github.com/Microsoft/pai/wiki/Resource-Requirement" target="_blank" rel="external nofollow noopener noreferrer">cpu&amp;memory requirement</a>（根据实际部署来看，worker节点至少32G内存，否则在部署到hadoop run时会出现不符合最小配置的`ERROR）。</li>
<li>OpenPAI 的服务器不能提供其它服务。 OpenPAI 会管理服务器的所有 CPU、内存和 GPU 资源。 如果服务器上有其它的服务负载，可能导致资源不足而产生各种问题。</li>
</ul>
<p><strong>ps</strong>:节点上尽可能的纯净，它会帮你安装docker等相关服务，甚至显卡驱动是通过container来挂载给集群使用，当然也可以自己安装最佳显卡驱动，在配置的时候更改默认配置，详情见后续配置修改。</p>
<p><strong>错误排查</strong>：部署driver-one-shot时，如果是在安装过显卡驱动的节点上可能会出现启动不起来，日志显示nvidia错误，一种方法是加入黑名单：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/modprobe.d/blacklist-nouveau.conf</span><br><span class="line"></span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br><span class="line"></span><br><span class="line">&gt; sudo update-initramfs -u</span><br><span class="line">&gt; sudo reboot</span><br></pre></td></tr></table></figure>



<h3 id="2、部署"><a href="#2、部署" class="headerlink" title="2、部署"></a>2、部署</h3><table>
<thead>
<tr>
<th align="center">nodes</th>
<th align="center">ip/allocation</th>
<th align="center">roles</th>
</tr>
</thead>
<tbody><tr>
<td align="center">node-dev</td>
<td align="center">192.168.1.100</td>
<td align="center">dev-box</td>
</tr>
<tr>
<td align="center">node00</td>
<td align="center">192.168.1.200<br>core: 8<br>memory: 64G<br>gpu: Titan XP *2</td>
<td align="center">master<br>worker</td>
</tr>
<tr>
<td align="center">node01</td>
<td align="center">192.168.1.201<br>core: 8<br>memory: 32G<br>gpu: 1080Ti *2</td>
<td align="center">worker</td>
</tr>
<tr>
<td align="center">node02</td>
<td align="center">192.168.1.202<br>core: 8<br>memory: 32G<br>gpu: 1080Ti *1</td>
<td align="center">worker</td>
</tr>
</tbody></table>
<p><code>node-dev</code>用于运行官方提供的<code>dev-box</code>镜像部署集群，由于可能会涉及到docker和系统环境的影响，所以官方不推荐在集群中运行dev-box</p>
<h4 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; sudo docker run -itd \</span><br><span class="line">        -e COLUMNS=<span class="variable">$COLUMNS</span> -e LINES=<span class="variable">$LINES</span> -e TERM=<span class="variable">$TERM</span> \</span><br><span class="line">        -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">        -v /pathConfiguration:/cluster-configuration  \</span><br><span class="line">        -v /hadoop-binary:/hadoop-binary  \</span><br><span class="line">        --pid=host \</span><br><span class="line">        --privileged=<span class="literal">true</span> \</span><br><span class="line">        --net=host \</span><br><span class="line">        --name=dev-box \</span><br><span class="line">        docker.io/openpai/dev-box:v0.12.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># tag自己选择最新版本，我这里是0.12.0，对应后续openpai全部容器的版本</span></span><br><span class="line"></span><br><span class="line">&gt; sudo docker <span class="built_in">exec</span> -it dev-box bash</span><br><span class="line">&gt; <span class="built_in">cd</span> /pai</span><br></pre></td></tr></table></figure>

<p>进入容器后到达<code>/pai</code>目录，拷贝并修改模板配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cp deployment/quick-start/quick-start-example.yaml deployment/quick-start/quick-start.yaml</span><br><span class="line"></span><br><span class="line">machines:</span><br><span class="line">  - 192.168.1.200</span><br><span class="line">  - 192.168.1.201</span><br><span class="line">  - 192.168.1.202</span><br><span class="line"></span><br><span class="line">ssh-username: chixing</span><br><span class="line">ssh-password: 123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一行ip默认是master，此处有个待验证，重复输入200节点是否会把200设置为master和worker,</span></span><br><span class="line"><span class="comment"># 因为后面搭建完成后显示可用gpu为两个，可能不把master的gpu以及所有资源利用起来</span></span><br></pre></td></tr></table></figure>

<p>然后生成配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; python paictl.py config generate -i /pai/deployment/quick-start/quick-start.yaml -o ~/pai-config -f</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">cd</span> ~/pai-config</span><br><span class="line">&gt; ls</span><br><span class="line">k8s-role-definition.yaml  kubernetes-configuration.yaml  layout.yaml  services-configuration.yaml</span><br></pre></td></tr></table></figure>

<p>此处我们可以修改后面三个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim services-configuration.yaml</span><br><span class="line"></span><br><span class="line">cluster:</span><br><span class="line">  <span class="comment">#common:</span></span><br><span class="line">  <span class="comment">#  cluster-id: pai-example</span></span><br><span class="line">  <span class="comment"># 可以设置cluster-id，否则后续会让你手动设置</span></span><br><span class="line"></span><br><span class="line">  docker-registry:</span><br><span class="line">    namespace: openpai</span><br><span class="line">    domain: docker.io</span><br><span class="line">    <span class="comment"># 私人仓库账号密码</span></span><br><span class="line">    <span class="comment">#username: &lt;username&gt;</span></span><br><span class="line">    <span class="comment">#password: &lt;password&gt;</span></span><br><span class="line">    tag: v0.12.0</span><br><span class="line">    secret-name: pai-secret</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 设置选用的显卡驱动，默认是镜像，也可以设置为宿主机的驱动(还是建议默认配置)</span></span><br><span class="line">  <span class="comment">#drivers:</span></span><br><span class="line"><span class="comment">#  set-nvidia-runtime: false</span></span><br><span class="line"><span class="comment">#  pre-installed-nvidia-path: /usr/local/nvidia</span></span><br><span class="line"><span class="comment">#  # You can set drivers version here. If this value is miss, default value will be 384.111</span></span><br><span class="line"><span class="comment">#  # Current supported version list</span></span><br><span class="line"><span class="comment">#  # 384.111</span></span><br><span class="line"><span class="comment">#  # 390.25</span></span><br><span class="line"><span class="comment">#  # 410.73</span></span><br><span class="line"><span class="comment">#  version: "384.111"</span></span><br><span class="line">......</span><br><span class="line"><span class="comment"># 其它还有配置一些端口以及openpai的登录账号密码等，一般默认即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim layout.yaml</span><br><span class="line"></span><br><span class="line">machine-sku:</span><br><span class="line">  NODE00:</span><br><span class="line">    mem: 50</span><br><span class="line">    gpu:</span><br><span class="line">      <span class="built_in">type</span>: generic</span><br><span class="line">      count: 2</span><br><span class="line">    cpu:</span><br><span class="line">      vcore: 8</span><br><span class="line">    os: ubuntu18.04</span><br><span class="line"></span><br><span class="line">  NODE01:</span><br><span class="line">    mem: 32</span><br><span class="line">    gpu:</span><br><span class="line">      <span class="built_in">type</span>: generic</span><br><span class="line">      count: 2</span><br><span class="line">    cpu:</span><br><span class="line">      vcore: 8</span><br><span class="line">    os: ubuntu18.04</span><br><span class="line"></span><br><span class="line">  NODE02:</span><br><span class="line">    mem: 32</span><br><span class="line">    gpu:</span><br><span class="line">      <span class="built_in">type</span>: generic</span><br><span class="line">      count: 1</span><br><span class="line">    cpu:</span><br><span class="line">      vcore: 8</span><br><span class="line">    os: ubuntu18.04</span><br><span class="line"></span><br><span class="line">machine-list:</span><br><span class="line">  - dashboard: <span class="string">"true"</span></span><br><span class="line">    docker-data: <span class="string">"/var/lib/docker"</span></span><br><span class="line">    etcdid: <span class="string">"etcdid1"</span></span><br><span class="line">    hostip: <span class="string">"192.168.1.200"</span></span><br><span class="line">    hostname: <span class="string">"node00"</span></span><br><span class="line">    k8s-role: <span class="string">"master"</span></span><br><span class="line">    machine-type: <span class="string">"NODE00"</span></span><br><span class="line">    nodename: <span class="string">"192.168.1.200"</span></span><br><span class="line">    pai-master: <span class="string">"true"</span></span><br><span class="line">    password: <span class="string">"123"</span></span><br><span class="line">    ssh-port: <span class="string">"22"</span></span><br><span class="line">    username: <span class="string">"chixing"</span></span><br><span class="line">    zkid: <span class="string">"1"</span></span><br><span class="line"></span><br><span class="line">  - docker-data: <span class="string">"/var/lib/docker"</span></span><br><span class="line">    hostip: <span class="string">"192.168.1.201"</span></span><br><span class="line">    hostname: <span class="string">"node01"</span></span><br><span class="line">    k8s-role: <span class="string">"worker"</span></span><br><span class="line">    machine-type: <span class="string">"NODE01"</span></span><br><span class="line">    nodename: <span class="string">"192.168.1.201"</span></span><br><span class="line">    pai-worker: <span class="string">"true"</span></span><br><span class="line">    password: <span class="string">"123"</span></span><br><span class="line">    ssh-port: <span class="string">"22"</span></span><br><span class="line">    username: <span class="string">"chixing"</span></span><br><span class="line"></span><br><span class="line">  - docker-data: <span class="string">"/var/lib/docker"</span></span><br><span class="line">    hostip: <span class="string">"192.168.1.202"</span></span><br><span class="line">    hostname: <span class="string">"node02"</span></span><br><span class="line">    k8s-role: <span class="string">"worker"</span></span><br><span class="line">    machine-type: <span class="string">"NODE02"</span></span><br><span class="line">    nodename: <span class="string">"192.168.1.202"</span></span><br><span class="line">    pai-worker: <span class="string">"true"</span></span><br><span class="line">    password: <span class="string">"123"</span></span><br><span class="line">    ssh-port: <span class="string">"22"</span></span><br><span class="line">    username: <span class="string">"chixing"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置三个节点资源分配情况，只需输入machine-sku然后更改节点的machine-type即可</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim kubernetes-configuration.yaml</span><br><span class="line"></span><br><span class="line">kubernetes:</span><br><span class="line">  <span class="comment"># 默认是从宿主机的/etc/resolv.conf nameserver字段获取，如果没有可能需要手动填</span></span><br><span class="line">  cluster-dns: 127.0.0.53</span><br><span class="line">  load-balance-ip: 192.168.1.200</span><br><span class="line">  service-cluster-ip-range: 10.254.0.0/16</span><br><span class="line">  storage-backend: etcd3</span><br><span class="line">  <span class="comment"># 修改下载k8s必备组件的仓库地址，默认是404网站的，这里openpai提供了自己的仓库</span></span><br><span class="line">  docker-registry: docker.io/openpai</span><br></pre></td></tr></table></figure>



<h4 id="2、开始部署"><a href="#2、开始部署" class="headerlink" title="2、开始部署"></a>2、开始部署</h4><p>启动k8s环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> /pai</span><br><span class="line">&gt; python paictl.py cluster k8s-bootup -p ~/pai-config</span><br><span class="line"></span><br><span class="line"><span class="comment"># k8s-clean可以删除集群</span></span><br></pre></td></tr></table></figure>

<p>等待下载镜像，全部通过后可以在<code>http://master_ip:9090</code>查看k8s_dashboard</p>
<p>一切安好后上传pai的配置到k8s集群中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; python paictl.py config push -p ~/pai-config</span><br></pre></td></tr></table></figure>

<p>如果在之前配置文件没有设置cluster_id的话，此时会让你设置一个id。</p>
<p>后续可以通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; python paictl.py config get-id</span><br></pre></td></tr></table></figure>

<p>来获取你设置的cluster_id</p>
<p>配置上传完毕，即可正式开始部署开启pai</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python paictl.py service start(stop、delete)</span><br></pre></td></tr></table></figure>

<p>接下来就是漫长的下载镜像–&gt;部署镜像–&gt;报错–&gt;修复–&gt;重启–&gt;成功</p>
<p>需要注意的是，排查报错后重启服务时，可能需要删除openpai和k8s生成的本地文件，比较重要的有<code>/var/etcd</code>存储k8s配置和集群内信息(pods、daemonset等)、<code>/etc/kubernetes/</code>存储k8s在各个节点上的配置文件(.yml)、<code>/datastorage</code>某些时候重启容器会出现这里面目录创建不了的问题，可能是权限，删除目录重启服务即可。</p>
<p>部署完成后即可在dashboard上查看健康情况。</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/k8s_dashboard.png"></p>
<h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p><code>http://master_ip:9286/virtual-clusters.html</code>会打开openpai的dashboard，输入配置文件中的账号密码即可打开本次项目</p>
<p><img alt data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/pai_dashboard.png"></p>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>deploy</tag>
        <tag>ai</tag>
        <tag>cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest</title>
    <url>/posts/b7198fcc/</url>
    <content><![CDATA[<p>国际惯例，先上官方文档: <a href="https://docs.pytest.org/en/stable/contents.html" target="_blank" rel="external nofollow noopener noreferrer">pytest</a></p>
<p>经常使用的单元测试一般是自带的unittest或者是文档测试，下面是他们简单的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of unittest_demo.py</span><br><span class="line">import unittest</span><br><span class="line"></span><br><span class="line">def fun(x):</span><br><span class="line">    return x + 1</span><br><span class="line"></span><br><span class="line">class MyTest(unittest.TestCase):</span><br><span class="line">    def test(self):</span><br><span class="line">        self.assertEqual(fun(3), 4)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    unittest.main()</span><br><span class="line"></span><br><span class="line">$ python3 unittest_demo.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of doctest_demo.py</span><br><span class="line">def square(x):</span><br><span class="line">    &quot;&quot;&quot;返回x的平方</span><br><span class="line"></span><br><span class="line">    &gt;&gt;&gt; square(2)</span><br><span class="line">    4</span><br><span class="line">    &gt;&gt;&gt; square(-1)</span><br><span class="line">    4</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    return x * x</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    import doctest</span><br><span class="line">    doctest.testmod()</span><br><span class="line"></span><br><span class="line">$ python3 doctest_demo.py</span><br></pre></td></tr></table></figure>

<p>可见这两个都比较繁琐或者配置比较复杂，所以我选择使用pytest这个第三方库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U pytest</span><br></pre></td></tr></table></figure>
<p>好了可以使用了</p>
<p>需要注意的是：”pytest(py.test)”会执行所有test_<em>.py或者</em>_test.py文件，或者pytest -q test_xx.py来指定，-q == quiet，结果不显示不相关的东西</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of test_sample.py</span><br><span class="line">def func(x):</span><br><span class="line">    return x + 1</span><br><span class="line"></span><br><span class="line">def test_answer1():</span><br><span class="line">    assert func(3) &#x3D;&#x3D; 4</span><br><span class="line"></span><br><span class="line">def test_answer2():</span><br><span class="line">    assert func(4) &#x3D;&#x3D; 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of test_class.py</span><br><span class="line">class TestClass(object):</span><br><span class="line">    def test_one(self):</span><br><span class="line">        x &#x3D; &#39;this&#39;</span><br><span class="line">        assert &#39;h&#39; in x</span><br><span class="line"></span><br><span class="line">    def test_two(self):</span><br><span class="line">        x &#x3D; &#39;hello&#39;</span><br><span class="line">        assert hasattr(x, &#39;format&#39;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># content of test_sysexit.py</span><br><span class="line">import pytest</span><br><span class="line"></span><br><span class="line">def f():</span><br><span class="line">    raise SystemExit(1)</span><br><span class="line"></span><br><span class="line">def test_mytest():</span><br><span class="line">    with pytest.raises(SystemExit):</span><br><span class="line">        f()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>artifact</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>py3 in one pic</title>
    <url>/posts/292e4d6e/</url>
    <content><![CDATA[<p><img alt="py3 in one pic" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/py3%20in%20one%20pic.png"></p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>update glibc to 2.17 for CentOS 6</title>
    <url>/posts/e5d88922/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># update glibc to 2.17 for CentOS 6</span></span><br><span class="line"></span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm</span><br><span class="line"></span><br><span class="line">sudo rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \</span><br><span class="line">glibc-common-2.17-55.el6.x86_64.rpm \</span><br><span class="line">glibc-devel-2.17-55.el6.x86_64.rpm \</span><br><span class="line">glibc-headers-2.17-55.el6.x86_64.rpm</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>env</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>glibc</tag>
      </tags>
  </entry>
  <entry>
    <title>指定版本安装Docker</title>
    <url>/posts/819760e9/</url>
    <content><![CDATA[<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><blockquote>
<p>需求来自于安装rancher2只支持1.12.6、1.13.1、17.03.2版本</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目前在Linux系统上安装Docker，对系统版本有以下要求：</p>
<ul>
<li>CentOS：7</li>
<li>Debian：7.7(Wheezy LTS)、8.0(Jessie LTS)、9(Stretch)</li>
<li>Fedora：24、25</li>
<li>Ubuntu：16.04(Xenial LTS)、14.04(Trusty LTS)、17.04(Zesty)</li>
</ul>
<p>可以通过阿里云的<code>Docker CE 镜像源站</code>进行安装。</p>
<h2 id="安装帮助"><a href="#安装帮助" class="headerlink" title="安装帮助"></a>安装帮助</h2><h2 id="Ubuntu-14-04-16-04-使用apt-get进行安装"><a href="#Ubuntu-14-04-16-04-使用apt-get进行安装" class="headerlink" title="Ubuntu 14.04/16.04 (使用apt-get进行安装)"></a>Ubuntu 14.04/16.04 (使用apt-get进行安装)</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装GPG证书</span></span><br><span class="line">$ curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg |  sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">$ sudo add-apt-repository <span class="string">"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="variable">$(lsb_release -cs)</span> stable"</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装Docker-CE</span></span><br><span class="line">$ sudo apt-get -y update</span><br><span class="line">$ sudo apt-get -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line">$ apt-cache madison docker-ce</span><br><span class="line">docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="line">docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span><br><span class="line"><span class="comment"># Step 2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.1~ce-0~ubuntu-xenial)</span></span><br><span class="line">$ sudo apt-get -y install docker-ce=[VERSION]</span><br></pre></td></tr></table></figure>

<h3 id="CentOS-7-使用yum进行安装"><a href="#CentOS-7-使用yum进行安装" class="headerlink" title="CentOS 7 (使用yum进行安装)"></a>CentOS 7 (使用yum进行安装)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># Step 4: 开启Docker服务</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，您可以通过以下方式开启。同理可以开启各种测试版本等。</span></span><br><span class="line"><span class="comment"># vim /etc/yum.repos.d/docker-ee.repo</span></span><br><span class="line"><span class="comment">#   将[docker-ce-test]下方的enabled=0修改为enabled=1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 安装指定版本的Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找Docker-CE的版本:</span></span><br><span class="line"><span class="comment"># yum list docker-ce.x86_64 --showduplicates | sort -r</span></span><br><span class="line"><span class="comment">#   Loading mirror speeds from cached hostfile</span></span><br><span class="line"><span class="comment">#   Loaded plugins: branch, fastestmirror, langpacks</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   Available Packages</span></span><br><span class="line"><span class="comment"># Step2: 安装指定版本的Docker-CE: (VERSION例如上面的17.03.0.ce.1-1.el7.centos)</span></span><br><span class="line"><span class="comment"># sudo yum -y install docker-ce-[VERSION]</span></span><br></pre></td></tr></table></figure>

<h2 id="安装校验"><a href="#安装校验" class="headerlink" title="安装校验"></a>安装校验</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@iZbp12adskpuoxodbkqzjfZ:$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line">Server:</span><br><span class="line"> Version:      17.03.0-ce</span><br><span class="line"> API version:  1.26 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   3a232c8</span><br><span class="line"> Built:        Tue Feb 28 07:52:04 2017</span><br><span class="line"> OS&#x2F;Arch:      linux&#x2F;amd64</span><br><span class="line"> Experimental: false</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cloud</category>
      </categories>
      <tags>
        <tag>deploy</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>文章资料</title>
    <url>/posts/44711817/</url>
    <content><![CDATA[<p>算法刷题 LeetCode <a href="http://leetcode-cn.com" target="_blank" rel="external nofollow noopener noreferrer">http://leetcode-cn.com</a></p>
<p>爬虫技术：静觅|崔庆才 <a href="https://cuiqingcai.com/" target="_blank" rel="external nofollow noopener noreferrer">https://cuiqingcai.com/</a></p>
<p>一篇文章搞懂Python中的进程和线程：<a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html" target="_blank" rel="external nofollow noopener noreferrer">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-process-thread.html</a></p>
<p>python异步爬虫：<a href="http://whuhan2013.github.io/blog/2016/09/13/python-ansyc-crawler/" target="_blank" rel="external nofollow noopener noreferrer">http://whuhan2013.github.io/blog/2016/09/13/python-ansyc-crawler/</a></p>
<p>理解 Python asyncio：<a href="http://lotabout.me/2017/understand-python-asyncio/" target="_blank" rel="external nofollow noopener noreferrer">http://lotabout.me/2017/understand-python-asyncio/</a></p>
<p>浅谈coroutine和gevent：<a href="https://www.xncoding.com/2016/01/02/python/gevent.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.xncoding.com/2016/01/02/python/gevent.html</a></p>
<p>基于协程的Python网络库gevent介绍：<a href="http://www.bjhee.com/gevent.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.bjhee.com/gevent.html</a></p>
<p>爬虫代理服务：<a href="http://kaito-kidd.com/2015/11/02/proxies-service/" target="_blank" rel="external nofollow noopener noreferrer">http://kaito-kidd.com/2015/11/02/proxies-service/</a></p>
<p>爬虫总结(二)– scrapy：<a href="http://www.shuang0420.com/2016/06/12/%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93-%E4%BA%8C-scrapy/" target="_blank" rel="external nofollow noopener noreferrer">http://www.shuang0420.com/2016/06/12/%E7%88%AC%E8%99%AB%E6%80%BB%E7%BB%93-%E4%BA%8C-scrapy/</a></p>
<p>Python使用multiprocessing实现一个最简单的分布式作业调度系统：<a href="https://blog.csdn.net/kongxx/article/details/50883804" target="_blank" rel="external nofollow noopener noreferrer">https://blog.csdn.net/kongxx/article/details/50883804</a></p>
<p>爬虫搜索策略：<a href="https://piaosanlang.gitbooks.io/spiders/content/06day/section6.6.html" target="_blank" rel="external nofollow noopener noreferrer">https://piaosanlang.gitbooks.io/spiders/content/06day/section6.6.html</a></p>
<p><del>使用conda管理python环境</del>：<a href="https://zhuanlan.zhihu.com/p/22678445" target="_blank" rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/22678445</a></p>
<p>实际上使用pyenv会更好些，可以管理python版本以及与virtualenv协同管理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source activate env_name    source deactivate env_name</span><br></pre></td></tr></table></figure>


<p>利用Python进行数据分析·第2版：<a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="external nofollow noopener noreferrer">https://www.jianshu.com/p/04d180d90a3f</a></p>
<p>调试前后端交互(get/post)以及爬虫模拟登录等：<a href="chrome://apps/" rel="external nofollow noopener noreferrer" target="_blank">chrome://apps/</a> 打开Postman，较好的工具，也有单独的软件</p>
<p>关于async的视频，来自不存在的网站：<a href="https://www.youtube.com/watch?v=E-1Y4kSsAFc" target="_blank" rel="external nofollow noopener noreferrer">Fear and Awaiting in Async: A Savage Journey to the Heart of the Coroutine Dream</a>，文章：<a href="https://zhuanlan.zhihu.com/p/27258289" target="_blank" rel="external nofollow noopener noreferrer">Python Async/Await入门指南</a></p>
]]></content>
      <categories>
        <category>deep</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/posts/e255a10a/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="网络的网络"><a href="#网络的网络" class="headerlink" title="网络的网络"></a>网络的网络</h2><p>网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/network-of-networks.gif"> </div><br>

<h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/46cec213-3048-4a80-aded-fdd577542801.jpg"> </div><br>

<p>目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。</p>
<p>互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/168e893c-e4a0-4ba4-b81f-9d993483abd0.jpg"> </div><br>

<h2 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h2><ul>
<li><p>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</p>
</li>
<li><p>对等（P2P）：不区分客户和服务器。</p>
</li>
</ul>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/2ad244f5-939c-49fa-9385-69bc688677ab.jpg"> </div><br>

<h2 id="电路交换与分组交换"><a href="#电路交换与分组交换" class="headerlink" title="电路交换与分组交换"></a>电路交换与分组交换</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1. 电路交换"></a>1. 电路交换</h3><p>电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。</p>
<h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2. 分组交换"></a>2. 分组交换</h3><p>每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p>
<p>在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。</p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>总时延 = 传输时延 + 传播时延 + 处理时延 + 排队时延</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/3939369b-3a4a-48a0-b9eb-3efae26dd400.png"> </div><br>

<h3 id="1-传输时延"><a href="#1-传输时延" class="headerlink" title="1. 传输时延"></a>1. 传输时延</h3><p>主机或路由器传输数据帧所需要的时间。</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?delay=\frac{l(bit)}{v(bit/s)}"></div> <br>

<p>其中 l 表示数据帧的长度，v 表示传输速率。</p>
<h3 id="2-传播时延"><a href="#2-传播时延" class="headerlink" title="2. 传播时延"></a>2. 传播时延</h3><p>电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?delay=\frac{l(m)}{v(m/s)}"></div> <br>

<p>其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。</p>
<h3 id="3-处理时延"><a href="#3-处理时延" class="headerlink" title="3. 处理时延"></a>3. 处理时延</h3><p>主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</p>
<h3 id="4-排队时延"><a href="#4-排队时延" class="headerlink" title="4. 排队时延"></a>4. 排队时延</h3><p>分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</p>
<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构*"></a>计算机网络体系结构*</h2><div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/426df589-6f97-4622-b74d-4a81fcb1da8e.png"> </div><br>

<h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h3><ul>
<li><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</p>
</li>
<li><p><strong>运输层</strong> ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p>
</li>
<li><p><strong>网络层</strong> ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</p>
</li>
<li><p><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。</p>
</li>
<li><p><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p>
</li>
</ul>
<h3 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2. OSI"></a>2. OSI</h3><p>其中表示层和会话层用途如下：</p>
<ul>
<li><p><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必担心在各台主机中数据内部格式不同的问题。</p>
</li>
<li><p><strong>会话层</strong> ：建立及管理会话。</p>
</li>
</ul>
<p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p>
<h3 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3. TCP/IP"></a>3. TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p>
<p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p>
<div align="center"> <img width="400" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/45e0e0bf-386d-4280-a341-a0b9496c7674.png"> </div><br>

<p>TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/d4eef1e2-5703-4ca4-82ab-8dda93d6b81f.png"> </div><br>

<h3 id="4-数据在各层之间的传递过程"><a href="#4-数据在各层之间的传递过程" class="headerlink" title="4. 数据在各层之间的传递过程"></a>4. 数据在各层之间的传递过程</h3><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p>
<p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/ac106e7e-489a-4082-abd9-dabebe48394c.jpg"> </div><br>

<h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h2 id="带通调制"><a href="#带通调制" class="headerlink" title="带通调制"></a>带通调制</h2><p>模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。</p>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/f0a31c04-6e26-408c-8395-88f4e2ae928b.jpg"> </div><br>

<h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h2><h3 id="1-封装成帧"><a href="#1-封装成帧" class="headerlink" title="1. 封装成帧"></a>1. 封装成帧</h3><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/ea5f3efe-d5e6-499b-b278-9e898af61257.jpg"> </div><br>

<h3 id="2-透明传输"><a href="#2-透明传输" class="headerlink" title="2. 透明传输"></a>2. 透明传输</h3><p>透明表示一个实际存在的事物看起来好像不存在一样。</p>
<p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/c5022dd3-be22-4250-b9f6-38ae984a04d7.jpg"> </div><br>

<h3 id="3-差错检测"><a href="#3-差错检测" class="headerlink" title="3. 差错检测"></a>3. 差错检测</h3><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p>
<h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="1-广播信道"><a href="#1-广播信道" class="headerlink" title="1. 广播信道"></a>1. 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p>
<p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p>
<p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p>
<h3 id="2-点对点信道"><a href="#2-点对点信道" class="headerlink" title="2. 点对点信道"></a>2. 点对点信道</h3><p>一对一通信。</p>
<p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p>
<h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="1-频分复用"><a href="#1-频分复用" class="headerlink" title="1. 频分复用"></a>1. 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/c4c14368-519c-4a0e-8331-0a553715e3e7.jpg"> </div><br>

<h3 id="2-时分复用"><a href="#2-时分复用" class="headerlink" title="2. 时分复用"></a>2. 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/fa2273c3-1b5f-48ce-8e8b-441a4116c1c4.jpg"> </div><br>

<p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。</p>
<h3 id="3-统计时分复用"><a href="#3-统计时分复用" class="headerlink" title="3. 统计时分复用"></a>3. 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/5999e5de-7c16-4b52-b3aa-6dc7b58c7894.png"> </div><br>

<h3 id="4-波分复用"><a href="#4-波分复用" class="headerlink" title="4. 波分复用"></a>4. 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/21041ec2-babb-483f-bf47-8b8148eec162.png"> </div><br>

<h3 id="5-码分复用"><a href="#5-码分复用" class="headerlink" title="5. 码分复用"></a>5. 码分复用</h3><p>为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 <img data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 和 <img data-src="https://latex.codecogs.com/gif.latex?\vec{T}"> 有</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{T}=0"></div> <br>

<p>为了讨论方便，取 m=8，设码片 <img data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。</p>
<p>在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S}=1"></div> <br>

<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?\frac{1}{m}\vec{S}\cdot\vec{S'}=-1"></div> <br>

<p>其中 <img data-src="https://latex.codecogs.com/gif.latex?\vec{S'}"> 为 <img data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 的反码。</p>
<p>利用上面的式子我们知道，当接收端使用码片 <img data-src="https://latex.codecogs.com/gif.latex?\vec{S}"> 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。</p>
<p>码分复用需要发送的数据量为原先的 m 倍。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/92ad9bae-7d02-43ba-8115-a9d6f530ca28.png"> </div><br>

<h2 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议*"></a>CSMA/CD 协议*</h2><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p>
<ul>
<li><strong>多点接入</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li>
<li><strong>载波监听</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li>
<li><strong>碰撞检测</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。</li>
</ul>
<p>记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为  <strong>争用期</strong> 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p>
<p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用  <strong>截断二进制指数退避算法</strong>  来确定。从离散的整数集合 {0, 1, .., (2<sup>k</sup>-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/5aa82b89-f266-44da-887d-18f31f01d8ef.png"> </div><br>

<h2 id="PPP-协议"><a href="#PPP-协议" class="headerlink" title="PPP 协议"></a>PPP 协议</h2><p>互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/ddcf2327-8d84-425d-8535-121a94bcb88d.jpg"> </div><br>

<p>PPP 的帧格式：</p>
<ul>
<li>F 字段为帧的定界符</li>
<li>A 和 C 字段暂时没有意义</li>
<li>FCS 字段是使用 CRC 的检验序列</li>
<li>信息部分的长度不超过 1500</li>
</ul>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/69f16984-a66f-4288-82e4-79b4aa43e835.jpg"> </div><br>

<h2 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h2><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。</p>
<p>一台主机拥有多少个适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。</p>
<p>主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。</p>
<p>可以按照网络拓扑结构对局域网进行分类：</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/a6026bb4-3daf-439f-b1ec-a5a24e19d2fb.jpg"> </div><br>

<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网*"></a>以太网*</h2><p>以太网是一种星型拓扑结构局域网。</p>
<p>早期使用集线器进行连接，集线器是一种物理层设备，作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到同时从两个不同接口的帧，那么就发生了碰撞。</p>
<p>目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。</p>
<p>以太网帧格式：</p>
<ul>
<li><strong>类型</strong> ：标记上层使用的协议；</li>
<li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li>
<li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li>
<li><strong>前同步码</strong> ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。</li>
</ul>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/50d38e84-238f-4081-8876-14ef6d7938b5.jpg"> </div><br>

<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机*"></a>交换机*</h2><p>交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。</p>
<p>正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p>
<p>下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/c9cfcd20-c901-435f-9a07-3e46830c359f.jpg"> </div><br>

<h2 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h2><p>虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。</p>
<p>例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。</p>
<p>使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/a74b70ac-323a-4b31-b4d5-90569b8a944b.png"> </div><br>

<h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层*"></a>四、网络层*</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p>
<p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/7b038838-c75b-4538-ae84-6299386704e5.jpg"> </div><br>

<p>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<div align="center"> <img width="350" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/0a9f4125-b6ab-4e94-a807-fd7070ae726a.png"> </div><br>

<h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg"> </div><br>

<ul>
<li><p><strong>版本</strong>  : 有 4（IPv4）和 6（IPv6）两个值；</p>
</li>
<li><p><strong>首部长度</strong>  : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>
</li>
<li><p><strong>区分服务</strong>  : 用来获得更好的服务，一般情况下不使用。</p>
</li>
<li><p><strong>总长度</strong>  : 包括首部长度和数据部分长度。</p>
</li>
<li><p><strong>生存时间</strong>  ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>
</li>
<li><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p>
</li>
<li><p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>
</li>
<li><p><strong>标识</strong>  : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>
</li>
<li><p><strong>片偏移</strong>  : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>
</li>
</ul>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/23ba890e-e11c-45e2-a20c-64d217f83430.png"> </div><br>

<h2 id="IP-地址编址方式"><a href="#IP-地址编址方式" class="headerlink" title="IP 地址编址方式"></a>IP 地址编址方式</h2><p>IP 地址的编址方式经历了三个历史阶段：</p>
<ul>
<li>分类</li>
<li>子网划分</li>
<li>无分类</li>
</ul>
<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/cbf50eb8-22b4-4528-a2e7-d187143d57f7.png"> </div><br>

<h3 id="2-子网划分"><a href="#2-子网划分" class="headerlink" title="2. 子网划分"></a>2. 子网划分</h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p>
<p>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</p>
<p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p>
<p>注意，外部网络看不到子网的存在。</p>
<h3 id="3-无分类"><a href="#3-无分类" class="headerlink" title="3. 无分类"></a>3. 无分类</h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p>
<p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</p>
<p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p>
<p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p>
<p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为  <strong>构成超网</strong> 。</p>
<p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p>
<h2 id="地址解析协议-ARP"><a href="#地址解析协议-ARP" class="headerlink" title="地址解析协议 ARP"></a>地址解析协议 ARP</h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/66192382-558b-4b05-a35d-ac4a2b1a9811.jpg"> </div><br>

<p>ARP 实现由 IP 地址得到 MAC 地址。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/b9d79a5a-e7af-499b-b989-f10483e71b8b.jpg"> </div><br>

<p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p>
<p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/8006a450-6c2f-498c-a928-c927f758b1d0.png"> </div><br>

<h2 id="网际控制报文协议-ICMP"><a href="#网际控制报文协议-ICMP" class="headerlink" title="网际控制报文协议 ICMP"></a>网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/e3124763-f75e-46c3-ba82-341e6c98d862.jpg"> </div><br>

<p>ICMP 报文分为差错报告报文和询问报文。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/aa29cc88-7256-4399-8c7f-3cf4a6489559.png"> </div><br>

<h3 id="1-Ping"><a href="#1-Ping" class="headerlink" title="1. Ping"></a>1. Ping</h3><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。</p>
<p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p>
<h3 id="2-Traceroute"><a href="#2-Traceroute" class="headerlink" title="2. Traceroute"></a>2. Traceroute</h3><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。</p>
<p>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h2 id="虚拟专用网-VPN"><a href="#虚拟专用网-VPN" class="headerlink" title="虚拟专用网 VPN"></a>虚拟专用网 VPN</h2><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p>
<p>有三个专用地址块：</p>
<ul>
<li>10.0.0.0 ~ 10.255.255.255</li>
<li>172.16.0.0 ~ 172.31.255.255</li>
<li>192.168.0.0 ~ 192.168.255.255</li>
</ul>
<p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。</p>
<p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/1556770b-8c01-4681-af10-46f1df69202c.jpg"> </div><br>

<h2 id="网络地址转换-NAT"><a href="#网络地址转换-NAT" class="headerlink" title="网络地址转换 NAT"></a>网络地址转换 NAT</h2><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p>
<p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/2719067e-b299-4639-9065-bed6729dbf0b.png"> </div><br>

<h2 id="路由器的结构"><a href="#路由器的结构" class="headerlink" title="路由器的结构"></a>路由器的结构</h2><p>路由器从功能上可以划分为：路由选择和分组转发。</p>
<p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/c3369072-c740-43b0-b276-202bd1d3960d.jpg"> </div><br>

<h2 id="路由器分组转发流程"><a href="#路由器分组转发流程" class="headerlink" title="路由器分组转发流程"></a>路由器分组转发流程</h2><ul>
<li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li>
<li>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</li>
<li>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</li>
<li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</li>
<li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</li>
<li>报告转发分组出错。</li>
</ul>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/1ab49e39-012b-4383-8284-26570987e3c4.jpg"> </div><br>

<h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p>
<p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p>
<p>可以把路由选择协议划分为两大类：</p>
<ul>
<li>自治系统内部的路由选择：RIP 和 OSPF</li>
<li>自治系统间的路由选择：BGP</li>
</ul>
<h3 id="1-内部网关协议-RIP"><a href="#1-内部网关协议-RIP" class="headerlink" title="1. 内部网关协议 RIP"></a>1. 内部网关协议 RIP</h3><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p>
<p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p>
<p>距离向量算法：</p>
<ul>
<li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li>
<li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：<ul>
<li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li>
<li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li>
</ul>
</li>
<li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li>
</ul>
<p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p>
<h3 id="2-内部网关协议-OSPF"><a href="#2-内部网关协议-OSPF" class="headerlink" title="2. 内部网关协议 OSPF"></a>2. 内部网关协议 OSPF</h3><p>开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。</p>
<p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p>
<p>OSPF 具有以下特点：</p>
<ul>
<li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li>
<li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li>
<li>只有当链路状态发生变化时，路由器才会发送信息。</li>
</ul>
<p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p>
<h3 id="3-外部网关协议-BGP"><a href="#3-外部网关协议-BGP" class="headerlink" title="3. 外部网关协议 BGP"></a>3. 外部网关协议 BGP</h3><p>BGP（Border Gateway Protocol，边界网关协议）</p>
<p>AS 之间的路由选择很困难，主要是由于：</p>
<ul>
<li>互联网规模很大；</li>
<li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li>
<li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li>
</ul>
<p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p>
<p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/9cd0ae20-4fb5-4017-a000-f7d3a0eb3529.png"> </div><br>

<h1 id="五、运输层"><a href="#五、运输层" class="headerlink" title="五、运输层*"></a>五、运输层*</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul>
<li><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
</li>
<li><p>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p>
</li>
</ul>
<h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg"> </div><br>

<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>
<h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png"> </div><br>

<ul>
<li><p><strong>序号</strong>  ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li><p><strong>确认号</strong>  ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li><p><strong>数据偏移</strong>  ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li><p><strong>确认 ACK</strong>  ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li><p><strong>同步 SYN</strong>  ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li><p><strong>终止 FIN</strong>  ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li><p><strong>窗口</strong>  ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png"> </div><br>

<p>假设 A 为客户端，B 为服务器端。</p>
<ul>
<li><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</p>
</li>
<li><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p>
</li>
<li><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</p>
</li>
<li><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</p>
</li>
<li><p>B 收到 A 的确认后，连接建立。</p>
</li>
</ul>
<p><strong>三次握手的原因</strong></p>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg"> </div><br>

<p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p>
<ul>
<li><p>A 发送连接释放报文，FIN=1。</p>
</li>
<li><p>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</p>
</li>
<li><p>当 B 不再需要连接时，发送连接释放报文，FIN=1。</p>
</li>
<li><p>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</p>
</li>
<li><p>B 收到 A 的确认后释放连接。</p>
</li>
</ul>
<p><strong>四次挥手的原因</strong></p>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li><p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li><p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p>
<p>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?RTTs=(1-a)*(RTTs)+a*RTT"></div> <br>

<p>超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：</p>
<div align="center"><img data-src="https://latex.codecogs.com/gif.latex?RTO=RTTs+4*RTT_d"></div> <br>

<p>其中 RTT<sub>d</sub> 为偏差。</p>
<h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg"> </div><br>

<h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。</p>
<div align="center"> <img width="500" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg"> </div><br>

<p>TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p>
<p>为了便于讨论，做如下假设：</p>
<ul>
<li>接收方有足够大的接收缓存，因此不会发生流量控制；</li>
<li>虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。</li>
</ul>
<div align="center"> <img width="800" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/910f613f-514f-4534-87dd-9b4699d59d31.png"> </div><br>

<h3 id="1-慢开始与拥塞避免"><a href="#1-慢开始与拥塞避免" class="headerlink" title="1. 慢开始与拥塞避免"></a>1. 慢开始与拥塞避免</h3><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p>
<p>如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。</p>
<h3 id="2-快重传与快恢复"><a href="#2-快重传与快恢复" class="headerlink" title="2. 快重传与快恢复"></a>2. 快重传与快恢复</h3><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p>
<div align="center"> <img width="600" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png"> </div><br>

<h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1><h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。</p>
<p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/b54eeb16-0b0e-484c-be62-306f57c40d77.jpg"> </div><br>

<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<ul>
<li>如果返回的响应超过的 512 字节就改用 TCP 进行传输（UDP 最大只支持 512 字节的数据）。</li>
<li>区域传送需要使用 TCP 进行传输（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</li>
</ul>
<h2 id="文件传送协议"><a href="#文件传送协议" class="headerlink" title="文件传送协议"></a>文件传送协议</h2><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p>
<ul>
<li>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。</li>
<li>数据连接：用来传送一个文件数据。</li>
</ul>
<p>根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：</p>
<ul>
<li>主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。</li>
</ul>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/03f47940-3843-4b51-9e42-5dcaff44858b.jpg"> </div><br>

<ul>
<li>被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。</li>
</ul>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/be5c2c61-86d2-4dba-a289-b48ea23219de.jpg"> </div><br>

<p>主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。</p>
<h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。</p>
<p>DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。</p>
<p>DHCP 工作过程如下：</p>
<ol>
<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。</li>
<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。</li>
<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。</li>
<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。</li>
</ol>
<div align="center"> <img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/bf16c541-0717-473b-b75d-4115864f4fbf.jpg"> </div><br>

<h2 id="远程登录协议"><a href="#远程登录协议" class="headerlink" title="远程登录协议"></a>远程登录协议</h2><p>TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。</p>
<p>TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。</p>
<h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。</p>
<p>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。</p>
<div align="center"> <img width="700" data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/7b3efa99-d306-4982-8cfb-e7153c33aab4.png"> </div><br>

<h3 id="1-SMTP"><a href="#1-SMTP" class="headerlink" title="1. SMTP"></a>1. SMTP</h3><p>SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。</p>
<div align="center"> <img width data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/ed5522bb-3a60-481c-8654-43e7195a48fe.png"> </div><br>

<h3 id="2-POP3"><a href="#2-POP3" class="headerlink" title="2. POP3"></a>2. POP3</h3><p>POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。</p>
<h3 id="3-IMAP"><a href="#3-IMAP" class="headerlink" title="3. IMAP"></a>3. IMAP</h3><p>IMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。</p>
<h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">端口号</th>
<th align="center">运输层协议</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">域名解析</td>
<td align="center">DNS</td>
<td align="center">53</td>
<td align="center">UDP/TCP</td>
<td align="center">长度超过 512 字节时使用 TCP</td>
</tr>
<tr>
<td align="center">动态主机配置协议</td>
<td align="center">DHCP</td>
<td align="center">67/68</td>
<td align="center">UDP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">简单网络管理协议</td>
<td align="center">SNMP</td>
<td align="center">161/162</td>
<td align="center">UDP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">文件传送协议</td>
<td align="center">FTP</td>
<td align="center">20/21</td>
<td align="center">TCP</td>
<td align="center">控制连接 21，数据连接 20</td>
</tr>
<tr>
<td align="center">远程终端协议</td>
<td align="center">TELNET</td>
<td align="center">23</td>
<td align="center">TCP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">超文本传送协议</td>
<td align="center">HTTP</td>
<td align="center">80</td>
<td align="center">TCP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">简单邮件传送协议</td>
<td align="center">SMTP</td>
<td align="center">25</td>
<td align="center">TCP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">邮件读取协议</td>
<td align="center">POP3</td>
<td align="center">110</td>
<td align="center">TCP</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">网际报文存取协议</td>
<td align="center">IMAP</td>
<td align="center">143</td>
<td align="center">TCP</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="Web-页面请求过程"><a href="#Web-页面请求过程" class="headerlink" title="Web 页面请求过程"></a>Web 页面请求过程</h2><h3 id="1-DHCP-配置主机信息"><a href="#1-DHCP-配置主机信息" class="headerlink" title="1. DHCP 配置主机信息"></a>1. DHCP 配置主机信息</h3><ul>
<li><p>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</p>
</li>
<li><p>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</p>
</li>
<li><p>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</p>
</li>
<li><p>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</p>
</li>
<li><p>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</p>
</li>
<li><p>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</p>
</li>
<li><p>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</p>
</li>
</ul>
<h3 id="2-ARP-解析-MAC-地址"><a href="#2-ARP-解析-MAC-地址" class="headerlink" title="2. ARP 解析 MAC 地址"></a>2. ARP 解析 MAC 地址</h3><ul>
<li><p>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</p>
</li>
<li><p>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</p>
</li>
<li><p>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</p>
</li>
<li><p>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</p>
</li>
<li><p>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</p>
</li>
<li><p>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</p>
</li>
<li><p>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</p>
</li>
</ul>
<h3 id="3-DNS-解析域名"><a href="#3-DNS-解析域名" class="headerlink" title="3. DNS 解析域名"></a>3. DNS 解析域名</h3><ul>
<li><p>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</p>
</li>
<li><p>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</p>
</li>
<li><p>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</p>
</li>
<li><p>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</p>
</li>
<li><p>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</p>
</li>
</ul>
<h3 id="4-HTTP-请求页面"><a href="#4-HTTP-请求页面" class="headerlink" title="4. HTTP 请求页面"></a>4. HTTP 请求页面</h3><ul>
<li><p>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</p>
</li>
<li><p>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</p>
</li>
<li><p>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</p>
</li>
<li><p>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</p>
</li>
<li><p>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</p>
</li>
<li><p>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>计算机网络, 谢希仁</li>
<li>JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014.</li>
<li>W.RichardStevens. TCP/IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006.</li>
<li><a href="https://securitywing.com/active-vs-passive-ftp-mode/" target="_blank" rel="external nofollow noopener noreferrer">Active vs Passive FTP Mode: Which One is More Secure?</a></li>
<li><a href="http://www.serv-u.com/kb/1138/active-and-passive-ftp-transfers-defined" target="_blank" rel="external nofollow noopener noreferrer">Active and Passive FTP Transfers Defined - KB Article #1138</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Traceroute" target="_blank" rel="external nofollow noopener noreferrer">Traceroute</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Ping" target="_blank" rel="external nofollow noopener noreferrer">ping</a></li>
<li><a href="http://webcache.googleusercontent.com/search?q=cache:http://anandgiria.blogspot.com/2013/09/windows-dhcp-interview-questions-and.html" target="_blank" rel="external nofollow noopener noreferrer">How DHCP works and DHCP Interview Questions and Answers</a></li>
<li><a href="https://www.quora.com/What-is-process-of-DORA-in-DHCP" target="_blank" rel="external nofollow noopener noreferrer">What is process of DORA in DHCP?</a></li>
<li><a href="https://tecadmin.net/what-is-dhcp-server/" target="_blank" rel="external nofollow noopener noreferrer">What is DHCP Server ?</a></li>
<li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="external nofollow noopener noreferrer">Tackling emissions targets in Tokyo</a></li>
<li><a href="http://www.climatechangenews.com/2011/html/university-tokyo.html" target="_blank" rel="external nofollow noopener noreferrer">What does my ISP know when I use Tor?</a></li>
<li><a href="http://www.linyibin.cn/2017/02/12/technology-ComputerNetworking-Internet/" target="_blank" rel="external nofollow noopener noreferrer">Technology-Computer Networking[1]-Computer Networks and the Internet</a></li>
<li><a href="http://slidesplayer.com/slide/11616167/" target="_blank" rel="external nofollow noopener noreferrer">P2P 网络概述.</a></li>
<li><a href="http://slideplayer.com/slide/5115386/" target="_blank" rel="external nofollow noopener noreferrer">Circuit Switching (a) Circuit switching. (b) Packet switching.</a></li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>interview</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>题目一</title>
    <url>/posts/2bbf7755/</url>
    <content><![CDATA[<p> 【题目:001】| 说说你对zen of python的理解，你有什么办法看到它?</p>
<p>Python之禅,Python秉承一种独特的简洁和可读行高的语法，以及高度一致的编程模式，符合“大脑思维习惯”，使Python易于学习、理解和记忆。Python同时采用了一条极简主义的设计理念，了解完整的Python哲学理念，可以在任何一个Python交互解释器中键入import this命令，这是Python隐藏的一个彩蛋:描绘了一系列Python设计原则。如今已是Python社区内流行的行话”EIBTI”，明了胜于晦涩这条规则的简称. 在Python的思维方式中，明了胜于晦涩，简洁胜于复杂。</p>
<pre><code>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&apos;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&apos;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&apos;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&apos;s do more of those!</code></pre><p>【题目:002】| 说说你对pythonic的看法，尝试解决下面的小问题</p>
<p>#简洁，明了，严谨，灵活</p>
<pre><code>#交换两个变量值
a,b = b,a

#去掉list中的重复元素
old_list = [1,1,1,3,4]
new_list = list(set(old_list))

#翻转一个字符串
s = &apos;abcde&apos;
ss = s[::-1]

#用两个元素之间有对应关系的list构造一个dict
names = [&apos;jianpx&apos;, &apos;yue&apos;]
ages = [23, 40]
m = dict(zip(names,ages))

#将数量较多的字符串相连，如何效率较高，为什么
fruits = [&apos;apple&apos;, &apos;banana&apos;]
result = &apos;&apos;.join(fruits)

#python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 s = ‘s1’ + ‘s2’ + ‘s3’ + ...+’sN’，总共将N个字符串连接起来， 但是使用+号的话，python需要申请N-1次内存空间， 然后进行字符串拷贝。原因是字符串对象PyStringObject在python当中是不可变 对象，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间 （大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。 所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法 join（list），这个方法能提高效率，原因是它只是申请了一次内存空间， 因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。</code></pre><p>【题目:003】| 你调试python代码的方法有哪些?</p>
<pre><code>具体IDE都有调试，比如:IDLE, Eclipse+Pydev都可以设置断点调试。
pdb模块也可以做调试。
还有PyChecker和Pylint
PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告
Pylint   是另外一个工具可以进行coding standard检查。</code></pre><p>【题目:004】|  你在github上都fork过哪些python库，列举一下你经常使用的，每个库用一句话描述下其功能</p>
<pre><code>http://rogerdudler.github.io/git-guide/index.zh.html    #关于git简明指南
http://www.zhihu.com/question/20070065                  #关于git的BBS
http://www.techug.com/githug-for-designer               #关于github的</code></pre><p>【题目:005】|  什么是GIL?</p>
<pre><code>什么是GIL(Global Interpreter Lock)全局解释器锁? 简单地说就是:
每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.
那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行,
多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.
从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能.</code></pre><p>【题目:006】|  什么是元类(meta_class)?</p>
<pre><code>元类就是用来创建类的“东西”
详情操作: http://blog.jobbole.com/21351/</code></pre><p>【题目:007】|  对比一下dict中items与iteritems?</p>
<pre><code>&gt;&gt;&gt; D = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4}
&gt;&gt;&gt; D.items()                       #一次性取出所有
[(&apos;a&apos;, 1), (&apos;c&apos;, 3), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]
&gt;&gt;&gt; D.iteritems()                   #迭代对象，每次取出一个。用for循环遍历出来；
&lt;dictionary-itemiterator object at 0x00000000026243B8&gt;
&gt;&gt;&gt; for i in D.iteritems():
...   print i,
...
(&apos;a&apos;, 1) (&apos;c&apos;, 3) (&apos;b&apos;, 2) (&apos;d&apos;, 4)
&gt;&gt;&gt; for k,v in D.iteritems():
...   print k,
...
a c b d
总结:
1. 一般iteritems()迭代的办法比items()要快，特别是数据库比较大时。
2. 在Python3中一般取消前者函数</code></pre><p>【题目:008】|  是否遇到过python的模块间循环引用的问题，如何避免它?</p>
<pre><code>这是代码结构设计的问题，模块依赖和类依赖
如果老是觉得碰到循环引用，很可能是模块的分界线划错地方了。可能是把应该在一起的东西硬拆开了，可能是某些职责放错地方了，可能是应该抽象的东西没抽象
总之微观代码规范可能并不能帮到太多，重要的是更宏观的划分模块的经验技巧，推荐uml，脑图，白板等等图形化的工具先梳理清楚整个系统的总体结构和职责分工

采取办法，从设计模式上来规避这个问题，比如:
1. 使用 “__all__” 白名单开放接口
2. 尽量避免 import</code></pre><p>【题目:009】|  有用过with statement吗？它的好处是什么？</p>
<pre><code>&gt;&gt;&gt; with open(&apos;text.txt&apos;) as myfile:
...   while True:
...     line = myfile.readline()
...     if not line:
...       break
...     print line,

# with语句使用所谓的上下文管理器对代码块进行包装，允许上下文管理器实现一些设置和清理操作。
# 例如：文件可以作为上下文管理器使用，它们可以关闭自身作为清理的一部分。
# NOTE：在PYTHON2.5中，需要使用from __future__ import with_statement进行with语句的导入</code></pre><p>【题目:010】|用Python生成指定长度的斐波那契数列</p>
<pre><code>def fibs(x):
    result = [0, 1]
    for index in range(x-2):
        result.append(result[-2]+result[-1])
    return result

if __name__==&apos;__main__&apos;:
    num = input(&apos;Enter one number: &apos;)
    print fibs(num)</code></pre><p>【题目:011】|  Python里如何生产随机数</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.random()
0.29495314937268713
&gt;&gt;&gt; random.randint(1,11)
8
&gt;&gt;&gt; random.choice(range(11))
3</code></pre><p>【题目:012】|  Python里如何反序的迭代一个序列</p>
<pre><code>如果是一个list, 最快的解决方案是：

list.reverse()
try:
    for x in list:
        “do something with x”
finally:
    list.reverse()

如果不是list, 最通用但是稍慢的解决方案是：
for i in range(len(sequence)-1, -1, -1):
x = sequence[i]</code></pre><p>【题目:013】|  Python中如何定义一个函数</p>
<pre><code>def func(arg, *args, **kwagrs):   #普通函数
    func_body
    return

lambda x: x **2                   #匿名函数</code></pre><p>【题目:014】|  Python匹配HTML tag的时候，&lt;.<em>&gt;和&lt;.</em>?&gt;有什么区别</p>
<pre><code>import re
s = ‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’
print(re.match(‘&lt;.*&gt;’, s).group())

会返回一个匹配&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;而不是&lt;html&gt;

而

import re
s = ‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’
print(re.match(‘&lt;.*?&gt;’, s).group())

则会返回&lt;html&gt;

&lt;.*&gt;这种匹配称作贪心匹配 &lt;.*?&gt;称作非贪心匹配</code></pre><p>【题目:015】|  Python里面search()和match()的区别</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;)
&gt;&gt;&gt; obj1 = re.match(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;)  #返回None
&gt;&gt;&gt; obj2 = re.search(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;) #找到pythonic
&gt;&gt;&gt; obj2.group()
&apos;python&apos;
#re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
#re.search匹配整个字符串，直到找到一个匹配。</code></pre><p>【题目:016】|  Python程序中文输出问题怎么解决</p>
<pre><code>在Python3中，对中文进行了全面的支持，但在Python2.x中需要进行相关的设置才能使用中文。否则会出现乱码。
Python默认采取的ASCII编码，字母、标点和其他字符只使用一个字节来表示，但对于中文字符来说，一个字节满足不了需求。
为了能在计算机中表示所有的中文字符，中文编码采用两个字节表示。如果中文编码和ASCII混合使用的话，就会导致解码错误，从而才生乱码。
解决办法:
交互式命令中：一般不会出现乱码，无需做处理
py脚本文件中：跨字符集必须做设置，否则乱码
1. 首先在开头一句添加:
# coding = utf-8
# 或
# coding = UTF-8
# 或
# -*- coding: utf-8 -*-
2. 其次需将文件保存为UTF-8的格式！
3. 最后: s.decode(&apos;utf-8&apos;).encode(&apos;gbk&apos;)</code></pre><p>【题目:017】|  什么是lambda函数</p>
<pre><code>函数使用:
1. 代码块重复，这时候必须考虑到函数，降低程序的冗余度
2. 代码块复杂，这时候必须考虑到函数，降低程序的复杂度
Python有两种函数,一种是def定义，一种是lambda函数()
当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数这个概念
&gt;&gt;&gt; nums = range(2,20)
&gt;&gt;&gt; for i in nums:
        nums = filter(lambda x:x==i or x % i,nums)
&gt;&gt;&gt; nums
[2, 3, 5, 7, 11, 13, 17, 19]</code></pre><p>【题目:018】|  Python里面如何实现tuple和list的转换</p>
<pre><code>#From list to Tuple
tuple(a_list)

#From Tuple to List
def to_list(t):
    return [i if not isinstance(i,tuple) else to_list(i) for i in t]</code></pre><p>【题目:019】|  请写出一段Python代码实现删除一个list里面的重复元素</p>
<pre><code>&gt;&gt;&gt; L1 = [4,1,3,2,3,5,1]
&gt;&gt;&gt; L2 = []
&gt;&gt;&gt; [L2.append(i) for i in L1 if i not in L2]
&gt;&gt;&gt; print L2
[4, 1, 3, 2, 5]</code></pre><p>【题目:020】|  Python是如何进行类型转换的</p>
<pre><code>&gt;&gt;&gt; int(&apos;1234&apos;)                   # 将数字型字符串转为整形
1234
&gt;&gt;&gt; float(12)                     # 将整形或数字字符转为浮点型
12.0
&gt;&gt;&gt; str(98)                       # 将其他类型转为字符串型
&apos;98&apos;
&gt;&gt;&gt; list(&apos;abcd&apos;)                  # 将其他类型转为列表类型
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;]) # 将其他类型转为字典类型
{&apos;age&apos;: None, &apos;name&apos;: None}
&gt;&gt;&gt; tuple([1, 2, 3, 4])           # 将其他类型转为元祖类型
(1, 2, 3, 4)</code></pre><p>详细转换总结如下:</p>
<pre><code>函数                      描述
int(x [,base])              将x转换为一个整数
long(x [,base] )            将x转换为一个长整数
float(x)                    将x转换到一个浮点数
complex(real [,imag])       创建一个复数
str(x)                      将对象 x 转换为字符串
repr(x)                     将对象 x 转换为表达式字符串
eval(str)                   用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s)                    将序列 s 转换为一个元组
list(s)                     将序列 s 转换为一个列表
set(s)                      转换为可变集合
dict(d)                     创建一个字典。d 必须是一个序列 (key,value)元组。
frozenset(s)                转换为不可变集合
chr(x)                      将一个整数转换为一个字符
unichr(x)                   将一个整数转换为Unicode字符
ord(x)                      将一个字符转换为它的整数值
hex(x)                      将一个整数转换为一个十六进制字符串
oct(x)                      将一个整数转换为一个八进制字符串</code></pre><p>【题目:021】|  如何知道一个Python对象的类型</p>
<pre><code>&gt;&gt;&gt; type([]);type(&apos;&apos;);type(0);type({});type(0.0);type((1,))
&lt;type &apos;list&apos;&gt;
&lt;type &apos;str&apos;&gt;
&lt;type &apos;int&apos;&gt;
&lt;type &apos;dict&apos;&gt;
&lt;type &apos;float&apos;&gt;
&lt;type &apos;tuple&apos;&gt;</code></pre><p>【题目:022】|  Python里面如何拷贝一个对象</p>
<pre><code>切片S[:]  # 注不能应用于字典
深浅宝贝  # 能应用于所有序列和字典
1. 浅拷贝D.copy()方法
2. 深拷贝deepcopy(D)方法</code></pre><p>【题目:023】|  Python中pass语句的作用是什么</p>
<pre><code>pass语句什么也不做,一般作为占位符或者创建占位程序</code></pre><p>【题目:024】|  写一段程序逐行读入一个文本文件，并在屏幕上打印出来</p>
<pre><code>f = open(filename)
while True:
    line = f.readline()
    if not line: break
    print(line)
f.close()</code></pre><p>【题目:025】|  如何用Python删除一个文件</p>
<pre><code>import os
os.remove(filename)</code></pre><p>【题目:026】|  Python代码得到列表list的交集与差集</p>
<pre><code>&gt;&gt;&gt; list1 = [1, 3, 4, 6]
&gt;&gt;&gt; list2 = [1, 2, 3, 4]
&gt;&gt;&gt; [i for i in list1 if i not in list2]
[6]
&gt;&gt;&gt; [i for i in list1 if i in list2]
[1, 3, 4]</code></pre><p>【题目:027】|  Python是如何进行内存管理的</p>
<pre><code>python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。</code></pre><p>【题目:028】|  介绍一下Python下range()函数的用法</p>
<pre><code>&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(0, 9, 2)
[0, 2, 4, 6, 8]
&gt;&gt;&gt; range(99,0,-10)
[99, 89, 79, 69, 59, 49, 39, 29, 19, 9]
相区别的是xrange(),每次只取出一个迭代对象，如果是数据量比较大时，效率较高
在Python3中，没有xrange()函数，其功能放在了range()函数上</code></pre><p>【题目:029】|  Python异常处理介绍一下</p>
<pre><code>程序中出现异常情况时就需要异常处理。比如当你打开一个不存在的文件时。当你的程序中有
一些无效的语句时，Python会提示你有错误存在。下面是一个拼写错误的例子，print写成了Print
下面是异常最常见的几种角色
1. 错误处理
&gt;&gt;&gt;可以在程序代码中捕捉和相应错误，或者忽略已发生的异常。
&gt;&gt;&gt;如果忽略错误，PYTHON默认的异常处理行为将启动:停止程序，打印错误信息。
&gt;&gt;&gt;如果不想启动这种默认行为，就用try语句来捕捉异常并从异常中恢复。
2. 事件通知
&gt;&gt;&gt;异常也可用于发出有效状态的信号，而不需在程序间传递结果标志位。或者刻意对其进行测试
3. 特殊情况处理
&gt;&gt;&gt;有时，发生了某种很罕见的情况，很难调整代码区处理。通常会在异常处理中处理，从而省去应对特殊情况的代码
4. 终止行为
&gt;&gt;&gt;try/finally语句可确保一定会进行需要的结束运算，无论程序是否有异常
5. 非常规控制流程</code></pre><p>【题目:030】|  介绍一下Python中的filter方法</p>
<pre><code>filter就像map,reduce,apply,zip等都是内置函数，用C语言实现，具有速度快，功能强大等

优点。
用于过滤与函数func()不匹配的值, 类似于SQL中select value != &apos;a&apos;
相当于一个迭代器，调用一个布尔函数func来迭代seq中的每个元素，返回一个是bool_seq返

回为True的序列
&gt;&gt;&gt;第一个参数: function or None, 函数或None
&gt;&gt;&gt;第二个参数: sequence,序列</code></pre><p>【题目:031】|  介绍一下except的用法和作用</p>
<pre><code>try/except:          捕捉由PYTHON自身或写程序过程中引发的异常并恢复
except:              捕捉所有其他异常
except name:         只捕捉特定的异常
except name, value:  捕捉异常及格外的数据(实例)
except (name1,name2) 捕捉列出来的异常
except (name1,name2),value: 捕捉任何列出的异常，并取得额外数据
else:                如果没有引发异常就运行
finally:             总是会运行此处代码</code></pre><p>【题目:032】|  如何用Python来进行查询和替换一个文本字符串</p>
<pre><code>&gt;&gt;&gt; words = &apos;Python is a very funny language!&apos;
&gt;&gt;&gt; words.find(&apos;Python&apos;)             # 返回的为0或正数时，为其索引号
0
&gt;&gt;&gt; words.find(&apos;is&apos;)
7
&gt;&gt;&gt; words.find(&apos;dafa&apos;)               # 返回-1表示查找失败
-1
&gt;&gt;&gt; words.replace(&apos;Python&apos;, &apos;Perl&apos;)  # replace()替换
&apos;Perl is a very funny language!&apos;</code></pre><p>【题目:033】|  Python如何copy一个文件</p>
<pre><code>import shutil
shutil.copyfile(&apos;a.py&apos;, &apos;copy_a.py&apos;)</code></pre><p>【题目:034】|  Python判断当前用户是否是root</p>
<pre><code>import os
if os.getuid() != 0:    # root账号的uid=0
    print os.getuid()
    print &apos;Should run as root account&apos;
else:
    print &apos;Hello, Root!&apos;</code></pre><p>【题目:035】|  用Python写一个for循环的例子</p>
<pre><code>for循环可以遍历序列(列表，字符串，元祖),range()及迭代对象，如xrange()
names = [&apos;Alice&apos;, &apos;Betty&apos;, &apos;Fred&apos;, &apos;Tom&apos;]
for index, name in enumerate(names):
    print &apos;index:&apos;,index,&apos;=&gt;&apos;, name

# 输出结果
index: 0 =&gt; Alice
index: 1 =&gt; Betty
index: 2 =&gt; Fred
index: 3 =&gt; Tom</code></pre><p>【题目:036】|  介绍一下Python中webbrowser的用法</p>
<pre><code>webbrowser模块提供了一个高级接口来显示基于Web的文档，大部分情况下只需要简单的调用open()方法。

webbrowser定义了如下的异常：exception webbrowser.Error, 当浏览器控件发生错误是会抛出这个异常

webbrowser有以下方法：

webbrowser.open(url[, new=0[, autoraise=1]])

这个方法是在默认的浏览器中显示url, 如果new = 0, 那么url会在同一个浏览器窗口下打开，如果new = 1, 会打开一个新的窗口，如果new = 2, 会打开一个新的tab, 如果autoraise ＝ true, 窗口会自动增长。

webbrowser.open_new(url)
在默认浏览器中打开一个新的窗口来显示url, 否则，在仅有的浏览器窗口中打开url

webbrowser.open_new_tab(url)
在默认浏览器中当开一个新的tab来显示url, 否则跟open_new()一样

webbrowser.get([name]) 根据name返回一个浏览器对象，如果name为空，则返回默认的浏览器

webbrowser.register(name, construtor[, instance])
注册一个名字为name的浏览器，如果这个浏览器类型被注册就可以用get()方法来获取。</code></pre><p>【题目:037】|  默写尽可能多的str对象的方法</p>
<pre><code>#方法                                   #描述
-------------------------------------------------------------------------------------------------
S.capitalize()                          #返回首字母大写的字符串的副本
S.center(width[,fillchar])              #返回一个长度为max(len(S),width),S居中，两侧fillchar填充
S.count(sub[,start[,end]])              #计算子字符串sub的出现次数，可将搜索范围限制为S[start:end]
S.decode([encoding[,error]])            #返回使用给定编码方式的字符串的解码版本，由error指定错误处理方式
S.endswith(suffix[start[,end]])         #检查S是否以suffix结尾，可给定[start:end]来选择匹配的范围
S.expandtabs([tabsize])                 #返回字符串的副本，其中tab字符会使用空格进行扩展，可选择tabsize
S.find(sun[,start[,end]])               #返回子字符串sub的第一个索引，不存在则为-1,可选择搜索范围
S.index(sub[,start[,end]])              #返回子字符串sub的第一个索引，不存在则引发ValueError异常.
S.isalnum()                             #检查字符串是否由字母或数字字符组成
S.isalpha()                             #检查字符串是否由字母字符组成
S.isdigit()                             #检查字符串是否由数字字符组成
S.islower()                             #检查字符串是否由小写字母组成
S.isspace()                             #检查字符串是否由空格组成
S.istitle()                             #检查字符串时候首字母大写
S.isupper()                             #检查字符串是否由大写字母组成
S.join(sequence)                        #返回其中sequence的字符串元素由S连接的字符串
S.ljust(width[,fillchar])               #返回S副本左对齐的字符串,长度max(len(S),W),右侧fillchar填充
S.lower()                               #返回所有字符串都为小写的副本
S.lstrip([char])                        #向左移除所有char，默认移除(空格,tab,\n)
S.partition(seq)                        #在字符串中搜索seq并返回
S.replace(old,new[,max])                #将new替换olad,最多可替换max次
S.rfind(sub[,start[,end]])              #返回sub所在的最后一个索引，不存在则为-1,可定搜索范围S[start:end]
S.rindex(sub[,start[,end]])             #返回sub所在的最后一个索引，不存在则会引发ValueError异常。
S.rjust(width[,fillchar])               #返回S副本右对齐的字符串,长度max(len(S),W),左侧fillchar填充
S.rpartition(seq)                       #同Partition,但从右侧开始查找
S.rstip([char])                         #向右移除所有char，默认移除(空格,tab,\n)
S.rsplit(sep[,maxsplit])                #同split,但是使用maxsplit时是从右往左进行计数
S.split(sep[,maxsplit])                 #使用sep做为分割符,可使用maxsplit指定最大切分数
S.zfill(width)                          #在S的左侧以0填充width个字符
S.upper()                               #返回S的副本，所有字符大写
S.splitlines([keepends])                #返回S中所有行的列表，可选择是否包括换行符
S.startswith(prefix[,start[,end]])      #检查S是否以prefix开始，可用[start,end]来定义范围
S.strip([chars])                        #移除所有字符串中含chars的字符，默认移除(空格，tab,\n)
S.swapcase()                            #返回S的副本，所有大小写交换
S.title()                               #返回S的副本，所有单词以大写字母开头
S.translate(table[,deletechars])        #返回S的副本，所有字符都使用table进行的转换，可选择删除出现在deletechars中的所有字符</code></pre><p>【题目:038】|  现在有一个dict对象adict,里面包含了一百万个元素,查找其中的某个元素的平均需要多少次比较</p>
<pre><code>O(1)  哈希字典，快速查找，键值映射，键唯一!</code></pre><p>【题目:039】|  有一个list对象alist，里面的所有元素都是字符串，编写一个函数对它实现一个大小写无关的排序</p>
<pre><code>words = [&apos;This&apos;,&apos;is&apos;,&apos;a&apos;,&apos;dog&apos;,&apos;!&apos;]
words.sort(key=lambda x:x.lower())
print words
#输出结果
&gt;&gt;&gt;
[&apos;!&apos;, &apos;a&apos;, &apos;dog&apos;, &apos;is&apos;, &apos;This&apos;]</code></pre><p>【题目:040】|  有一个排好序地list对象alist，查找其中是否有某元素a</p>
<pre><code>alist = [&apos;a&apos;,&apos;s&apos;,&apos;d&apos;,&apos;f&apos;]

try:
    alist.index(&apos;a&apos;)
    print &apos;Find it.&apos;
except ValueError:
    print &apos;Not Found.&apos;</code></pre><p>【题目:041】|  请用Python写一个获取用户输入数字，并根据数字大小输出不同信息的脚本</p>
<pre><code>num = input(&apos;Enter number: &apos;)

if num &gt; 100:
    print &apos;The number is over 100&apos;
elif 0 &lt; num &lt;= 100:
    print &apos;The number is between 0~100&apos;
elif num &lt; 0:
    print &apos;The number is negative.&apos;
else:
    print &apos;Not a number&apos;</code></pre><p>【题目:042】|  打乱一个排好序的list对象alist</p>
<pre><code># random模块中的shuffle(洗牌函数)
import random
alist = [1, 2, 3, 4]
random.shuffle(alist)
print alist</code></pre><p>【题目:043】|  有二维的list对象alist，假定其中的所有元素都具有相同的长度，写一段程序根据元素的第二个元素排序</p>
<pre><code>def sort_lists(lists, sord, idx):
    if sord == &apos;desc&apos;:
        lists.sort(key=lambda x:x[idx], reverse=True)
    else:
        lists.sort(key=lambda x:x[idx])
    return lists
lists = [[&apos;cd&apos;,&apos;ab&apos;],[&apos;ef&apos;,&apos;ac&apos;]]
sort_lists(lists,&apos;desc&apos;,1)
print lists

# 输出结果
&gt;&gt;&gt;
[[&apos;ef&apos;, &apos;ac&apos;], [&apos;cd&apos;, &apos;ab&apos;]]</code></pre><p>【题目:044】|  inspect模块有什么用</p>
<pre><code>inspect模块提供了一系列函数用于帮助使用自省。

检查对象类型
is{module|class|function|method|builtin}(obj): 检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj): 用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。

获取对象信息
getmembers(object[, predicate]): 这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回。
getmodule(object): 它返回object的定义所在的模块对象。
get{file|sourcefile}(object): 获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。
get{source|sourcelines}(object): 获取object的定义的源代码，以字符串|字符串列表返回。
getargspec(func): 仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。</code></pre><p>【题目:045】|  Python处理命令行参数示例代码</p>
<pre><code># 最简单、最原始的方法就是手动解析了
import sys
for arg in sys.argv[1:]:
    print(arg)</code></pre><p>【题目:046】|  介绍一下Python getopt模块</p>
<pre><code># getopt模块是原来的命令行选项解析器，支持UNIX函数getopt()建立的约定。
# 它会解析一个参数序列，如sys.argv，并返回一个元祖序列和一个非选项参数序列。
# 目前支持的选项语法包括短格式和长格式选项：-a, -bval, -b val, --noarg, --witharg=val, --witharg val。
# 如果只是简单的命令行解析，getopt还是不错的选择。一个例子如下

import sys
import getopt

try:
    options, remainder = getopt.getopt(sys.argv[1:], &apos;o:v&apos;, [&apos;output=&apos;, &apos;verbose&apos;, &apos;version=&apos;,])
except getopt.GetoptError as err:
    print &apos;ERROR:&apos;, err
    sys.exit(1)
总结下getopt的特点：1.  getopt是从前到后解析 2.  getopt不检查额外参数的合法性，需要自行检查           3.  短命令行和长命令行是分开解析的&lt;/span&gt;</code></pre><p>【题目:047】|  Python列表与元组的区别是什么？分别在什么情况下使用？</p>
<pre><code>Python中列表和元祖都是序列，因此都能进行添加，删除，更新，切片等操作。但列表是可变对象，元祖是不可变对象。
元祖主要用于函数赋值，字符串格式化等。但列表中的方法更多些，也是PYTHON中更常用的数据结构。</code></pre><p>【题目:048】|  有一个长度是101的数组，存在1~100的数字，有一个是重复的，拿重复的找出来</p>
<pre><code># Python中，主要是拿count(i) ==2的找出来即可，再利用列表推导式
&gt;&gt;&gt; l = [1, 2, 3, 4, 2]
&gt;&gt;&gt; tmp = []
&gt;&gt;&gt; [tmp.append(i) for i in l if l.count(i) == 2]
[None, None]
&gt;&gt;&gt; tmp
[2, 2]
&gt;&gt;&gt; set(tmp)
set([2])</code></pre><p>【题目:049】|  set是在哪个版本成为build-in types的？举例说明,并说明为什么当时选择了set这种数据结构</p>
<pre><code>python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.

sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。


下面来点简单的小例子说明。

&gt;&gt;&gt; x = set(&apos;spam&apos;)
&gt;&gt;&gt; y = set([&apos;h&apos;,&apos;a&apos;,&apos;m&apos;])
&gt;&gt;&gt; x, y
(set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;m&apos;]), set([&apos;a&apos;, &apos;h&apos;, &apos;m&apos;]))

再来些小应用。

&gt;&gt;&gt; x &amp; y # 交集
set([&apos;a&apos;, &apos;m&apos;])

&gt;&gt;&gt; x | y # 并集
set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;h&apos;, &apos;m&apos;])

&gt;&gt;&gt; x - y # 差集
set([&apos;p&apos;, &apos;s&apos;])

去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下：

&gt;&gt;&gt; a = [11,22,33,44,11,22]
&gt;&gt;&gt; b = set(a)
&gt;&gt;&gt; b
set([33, 11, 44, 22])
&gt;&gt;&gt; c = [i for i in b]
&gt;&gt;&gt; c
[33, 11, 44, 22]

很酷把，几行就可以搞定。

1.8　集合

集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项：
s = set([3,5,9,10])      #创建一个数值集合
t = set(&quot;Hello&quot;)         #创建一个唯一字符的集合

与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是：



&gt;&gt;&gt; t
set([&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;])
注意只出现了一个&apos;l&apos;。

集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：
a = t | s          # t 和 s的并集
b = t &amp; s          # t 和 s的交集
c = t – s         # 求差集（项在t中，但不在s中）
d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）



基本操作：

t.add(&apos;x&apos;)            # 添加一项
s.update([10,37,42])  # 在s中添加多项



使用remove()可以删除一项：
t.remove(&apos;H&apos;)

len(s)
set 的长度

x in s
测试 x 是否是 s 的成员

x not in s
测试 x 是否不是 s 的成员

s.issubset(t)
s &lt;= t
测试是否 s 中的每一个元素都在 t 中

s.issuperset(t)
s &gt;= t
测试是否 t 中的每一个元素都在 s 中

s.union(t)
s | t
返回一个新的 set 包含 s 和 t 中的每一个元素

s.intersection(t)
s &amp; t
返回一个新的 set 包含 s 和 t 中的公共元素

s.difference(t)
s - t
返回一个新的 set 包含 s 中有但是 t 中没有的元素

s.symmetric_difference(t)
s ^ t
返回一个新的 set 包含 s 和 t 中不重复的元素

s.copy()
返回 set “s”的一个浅复制


请注意：union(), intersection(), difference() 和 symmetric_difference() 的非运算符（non-operator，就是形如 s.union()这样的）版本将会接受任何 iterable 作为参数。相反，它们的运算符版本（operator based counterparts）要求参数必须是 sets。这样可以避免潜在的错误，如：为了更可读而使用 set(&apos;abc&apos;) &amp; &apos;cbs&apos; 来替代 set(&apos;abc&apos;).intersection(&apos;cbs&apos;)。从 2.3.1 版本中做的更改：以前所有参数都必须是 sets。

另外，Set 和 ImmutableSet 两者都支持 set 与 set 之间的比较。两个 sets 在也只有在这种情况下是相等的：每一个 set 中的元素都是另一个中的元素（二者互为subset）。一个 set 比另一个 set 小，只有在第一个 set 是第二个 set 的 subset 时（是一个 subset，但是并不相等）。一个 set 比另一个 set 打，只有在第一个 set 是第二个 set 的 superset 时（是一个 superset，但是并不相等）。

子 set 和相等比较并不产生完整的排序功能。例如：任意两个 sets 都不相等也不互为子 set，因此以下的运算都会返回 False：a&lt;b, a==b, 或者a&gt;b。因此，sets 不提供 __cmp__ 方法。

因为 sets 只定义了部分排序功能（subset 关系），list.sort() 方法的输出对于 sets 的列表没有定义。


运算符
   运算结果

hash(s)
   返回 s 的 hash 值


下面这个表列出了对于 Set 可用二对于 ImmutableSet 不可用的运算：

运算符（voperator）
等价于
运算结果

s.update(t)
s |= t
返回增加了 set “t”中元素后的 set “s”

s.intersection_update(t)
s &amp;= t
返回只保留含有 set “t”中元素的 set “s”

s.difference_update(t)
s -= t
返回删除了 set “t”中含有的元素后的 set “s”

s.symmetric_difference_update(t)
s ^= t
返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”

s.add(x)

向 set “s”中增加元素 x

s.remove(x)

从 set “s”中删除元素 x, 如果不存在则引发 KeyError

s.discard(x)

如果在 set “s”中存在元素 x, 则删除

s.pop()

删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError

s.clear()

删除 set “s”中的所有元素


请注意：非运算符版本的 update(), intersection_update(), difference_update()和symmetric_difference_update()将会接受任意 iterable 作为参数。从 2.3.1 版本做的更改：以前所有参数都必须是 sets。

还请注意：这个模块还包含一个 union_update() 方法，它是 update() 方法的一个别名。包含这个方法是为了向后兼容。程序员们应该多使用 update() 方法，因为这个方法也被内置的 set() 和 frozenset() 类型支持。</code></pre><p>【题目:050】| 说说decorator的用法和它的应用场景，如果可以的话，写一个decorator</p>
<pre><code>所谓装饰器就是把函数包装一下，为函数添加一些附加功能，装饰器就是一个函数，参数为被包装的函数，返回包装后的函数：

def d(fp):
    def _d(*arg, **karg):
        print &quot;do sth before fp..&quot;
        r= fp(*arg, **karg)
        print &quot;do sth after fp..&quot;
        return r
    return _d

@d
def f():
    print &quot;call f&quot;
#上面使用@d来表示装饰器和下面是一个意思
#f = d(f)


f()#调用f</code></pre><p>【题目:051】| 写一个类，并让它尽可能多的支持操作符</p>
<pre><code>class Array:
    __list = []

    def __init__(self):
        print &quot;constructor&quot;

    def __del__(self):
        print &quot;destructor&quot;

    def __str__(self):
        return &quot;this self-defined array class&quot;

    def __getitem__(self, key):
        return self.__list[key]

    def __len__(self):
        return len(self.__list)

    def Add(self, value):
        self.__list.append(value)

    def Remove(self, index):
        del self.__list[index]

    def DisplayItems(self):
        print &quot;show all items----&quot;
        for item in self.__list:
            print item

arr = Array()   #constructor
print arr    #this self-defined array class
print len(arr)   #0
arr.Add(1)
arr.Add(2)
arr.Add(3)
print len(arr)   #3
print arr[0]   #1
arr.DisplayItems()
#show all items----
#1
#2
#3
arr.Remove(1)
arr.DisplayItems()
#show all items----
#1
#3
#destructor</code></pre><p>【题目:052】| 说一说你见过比较cool的python实现</p>
<pre><code>cool的概念，角度不同，看法可能也就不同，个人觉得更Pythonic的代码就是最酷的代码。</code></pre><p>【题目:053】| Python如何实现单例模式</p>
<pre><code>#-*- encoding=utf-8 -*-
print &apos;----------------------方法1--------------------------&apos;
#方法1,实现__new__方法
#并在将一个类的实例绑定到类变量_instance上,
#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回
#如果cls._instance不为None,直接返回cls._instance
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &apos;_instance&apos;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1

one = MyClass()
two = MyClass()

two.a = 3
print one.a
#3
#one和two完全相同,可以用id(), ==, is检测
print id(one)
#29097904
print id(two)
#29097904
print one == two
#True
print one is two
#True

print &apos;----------------------方法2--------------------------&apos;
#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)
#同一个类的所有实例天然拥有相同的行为(方法),
#只需要保证同一个类的所有实例具有相同的状态(属性)即可
#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)
#可参看:http://code.activestate.com/recipes/66531/
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1

one = MyClass2()
two = MyClass2()

#one和two是两个不同的对象,id, ==, is对比结果可看出
two.a = 3
print one.a
#3
print id(one)
#28873680
print id(two)
#28873712
print one == two
#False
print one is two
#False
#但是one和two具有相同的（同一个__dict__属性）,见:
print id(one.__dict__)
#30104000
print id(two.__dict__)
#30104000

print &apos;----------------------方法3--------------------------&apos;
#方法3:本质上是方法1的升级（或者说高级）版
#使用__metaclass__（元类）的高级python用法
class Singleton2(type):
    def __init__(cls, name, bases, dict):
        super(Singleton2, cls).__init__(name, bases, dict)
        cls._instance = None
    def __call__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = super(Singleton2, cls).__call__(*args, **kw)
        return cls._instance

class MyClass3(object):
    __metaclass__ = Singleton2

one = MyClass3()
two = MyClass3()

two.a = 3
print one.a
#3
print id(one)
#31495472
print id(two)
#31495472
print one == two
#True
print one is two
#True

print &apos;----------------------方法4--------------------------&apos;
#方法4:也是方法1的升级（高级）版本,
#使用装饰器(decorator),
#这是一种更pythonic,更elegant的方法,
#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的
def singleton(cls, *args, **kw):
    instances = {}
    def _singleton():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return _singleton

@singleton
class MyClass4(object):
    a = 1
    def __init__(self, x=0):
        self.x = x

one = MyClass4()
two = MyClass4()

two.a = 3
print one.a
#3
print id(one)
#29660784
print id(two)
#29660784
print one == two
#True
print one is two
#True
one.x = 1
print one.x
#1
print two.x
#1</code></pre><p>【题目:054】| 如何用Python来发送邮件</p>
<pre><code># 可以使用smtplib标准库。
# 以下代码可以在支持SMTP监听器的服务器上执行。

import sys, smtplib

fromaddr = raw_input(&quot;From: &quot;)
toaddrs  = raw_input(&quot;To: &quot;).split(&apos;,&apos;)
print(&quot;Enter message, end with ^D:&quot;)
msg = &apos;&apos;
while 1:
    line = sys.stdin.readline()
    if not line:
        break
msg += line

# 发送邮件部分
server = smtplib.SMTP(&apos;localhost&apos;)
server.sendmail(fromaddr, toaddrs, msg)
server.quit()</code></pre><p>【题目:055】| Python自动连接ssh的代码</p>
<pre><code>#!/usr/bin/env python

#import the need library.
import pxssh

#machine details
hostname = &apos;&apos;
username = &apos;&apos;
password = &apos;&apos;

#command we want to send
command = &apos;ls -lart&apos;

#function to connect
def connect(hostname, username, password, release):
    try:
        s = pxssh.pxssh()
        s.login(hostname, username, password, release)
        print s
        return s
    except Exception, e:
        print &quot;[-] Error Connecting: &quot; + str(e)

#func to send a command
def send_command(ssh_session, command):
    ssh_session.sendline(command)
    ssh_session.prompt()
    print ssh_session.before

#main()
if __name__ == &quot;__main__&quot;:
    session = connect(hostname, username, password)
    send_command(session, command)</code></pre><p>或者用pexpect模块</p>
<pre><code>#!/usr/bin/env python

import pexpect

def ssh_cmd(ip, passwd, cmd):
    ret = -1
    ssh = pexpect.spawn(&apos;ssh root@%s &quot;%s&quot;&apos; % (ip, cmd))
    try:
        i = ssh.expect([&apos;password:&apos;, &apos;continue connecting (yes/no)?&apos;], timeout=5)
        if i == 0 :
            ssh.sendline(passwd)
        elif i == 1:
            ssh.sendline(&apos;yes\n&apos;)
            ssh.expect(&apos;password: &apos;)
            ssh.sendline(passwd)
        ssh.sendline(cmd)
        res = ssh.read()
        print res
        ret = 0
    except pexpect.EOF:
        print &quot;EOF&quot;
        ssh.close()
        ret = -1
    except pexpect.TIMEOUT:
        print &quot;TIMEOUT&quot;
        ssh.close()
        ret = -2
    return ret

#main()
if __name__ == &quot;__main__&quot;:
    ssh_cmd(&apos;127.0.0.1&apos;, &apos;password&apos;, &apos;ls -lart&apos;)</code></pre><p>【题目:056】| 介绍一下Python Date Time方面的类</p>
<pre><code>一.time模块
time模块提供各种操作时间的函数
一般有两种表示时间的方式:
第一种: 是时间戳的方式(相对于1970.1.1 00:00:00以秒计算的偏移量),时间戳是惟一的
第二种: 以数组的形式表示即(struct_time),共有九个元素，分别表示，同一个时间戳的struct_time会因为时区不同而不同

二.datetime模块
Python提供了多个内置模块用于操作日期时间，像calendar，time，datetime。time模块。
相比于time模块，datetime模块的接口则更直观、更容易调用。
datetime模块定义了下面这几个类：
datetime.date：表示日期的类。常用的属性有year, month, day；
datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond；
datetime.datetime：表示日期时间。
datetime.timedelta：表示时间间隔，即两个时间点之间的长度。
datetime.tzinfo：与时区有关的相关信息。
datetime中，表示日期时间的是一个datetime对象
datetime中提供了strftime方法，可以将一个datetime型日期转换成字符串：</code></pre><p>【题目:057】| 写一个简单的Python socket编程</p>
<p>服务器端程序:</p>
<pre><code># FileName: server.py

import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((&apos;localhost&apos;, 8001))

sock.listen(5)
while True:
    conn, addr = sock.accept()
    try:
        conn.settimeout(5)
        buff = conn.recv(1024)
        if buff == &apos;1&apos;:
            conn.send(&apos;Hello, Client...&apos;)
        else:
            conn.send(&apos;Please, Go Out...&apos;)
    except socket.timeout:
        print &apos;Socket Time Out...&apos;
    finally:
        conn.close()</code></pre><p>客户端程序:</p>
<pre><code># FileName: client.py
import socket
import time

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&apos;localhost&apos;, 8001))
time.sleep(2)
sock.send(&apos;1&apos;)
print sock.recv(1024)
sock.close()</code></pre><p>在终端运行server.py，然后运行clien.py，会在终端打印“Hello, Client…”。</p>
<p>如果更改client.py的sock.send(‘1’)为其它值在终端会打印“Please, Go Out…”。</p>
<p>更改time.sleep(2)为大于5的数值， 服务器将会超时。</p>
<p>【题目:058】| Tkinter的ToolTip控件</p>
<pre><code>Tooltip控件是一个简单，但非常有用的控件。它能够为我们的软件提供非常漂亮的提示信息，提高软件的可用性，给用户比较好的体验。
假设现在有两个按钮，一个用来预览吊线世系图，一个用来预览行转。为了保持按钮文本的简洁，以及为按钮尺寸所限。
我们不能可能把这个按钮的主要功能通过text属性表述清楚，这个时候我们就可以用到tooltip控件了.</code></pre><p>【题目:059】| 解释一下python的and-or语法</p>
<pre><code>0 and ＊ 不需要再考虑＊是0还是1，结果是0
1 and ＊ 需要考虑＊是0还是1来决定结果。

1 or ＊ 不需要考虑后面的＊，结果为1
0 or ＊ 需要考虑后面的＊来决定结果

这个语法看起来类似于 C 语言中的 bool ? a : b 表达式。整个表达式从左到右进行演算，所以先进行 and 表达式的演算。 1 and &apos;first&apos; 演算值为 &apos;first&apos;，然后 &apos;first&apos; or &apos;second&apos; 的演算值为 &apos;first&apos;。

0 and &apos;first&apos; 演算值为 False，然后 0 or &apos;second&apos; 演算值为 &apos;second&apos;。

and-or主要是用来模仿 三目运算符 bool?a:b的，即当表达式bool为真，则取a否则取b。

and-or 技巧，bool and a or b 表达式，当 a 在布尔上下文中的值为假时，不会像 C 语言表达式 bool ? a : b 那样工作。</code></pre><p>【题目:060】| Python里关于“堆”这种数据结构的模块是哪个？“堆”有什么优点和缺点</p>
<p>这个真没有！</p>
<p>【题目:061】| 实现一个stack</p>
<pre><code>class Stack :
    def __init__( self ):
        &apos;&apos;&apos;&apos;&apos; Creates an empty stack. &apos;&apos;&apos;
        self._items = list()

    def isEmpty(self):
        &apos;&apos;&apos;&apos;&apos; Returns True if the stack is empty or False otherwise. &apos;&apos;&apos;
        return len(self) == 0

    def __len__(self):
        &apos;&apos;&apos;&apos;&apos; Returns the number of items in the stack. &apos;&apos;&apos;
        return len(self._items)

    def peek(self):
       &apos;&apos;&apos;&apos;&apos; Returns the top item on the stack without removing it. &apos;&apos;&apos;
       assert not self.isEmpty(), &quot;Cannot peek at an empty stack&quot;
       return self._items[-1]

    def pop(self):
        &apos;&apos;&apos;&apos;&apos; Removes and returns the top item on the stack. &apos;&apos;&apos;
        assert not self.isEmpty(), &quot;Cannot pop from an empty stack&quot;
        return self._items.pop()

    def push(self,item):
        &apos;&apos;&apos;&apos;&apos; Push an item onto the top of the stack. &apos;&apos;&apos;
        self._items.append( item )</code></pre><p>【题目:062】| 编写一个简单的ini文件解释器</p>
<p>db_config.ini</p>
<p>[baseconf]<br>host=127.0.0.1<br>port=3306<br>user=root<br>password=root<br>db_name=evaluting_sys<br>[concurrent]<br>processor=20</p>
<p>示例代码</p>
<pre><code>import sys,os
import ConfigParser
def test(config_file_path):
    cf = ConfigParser.ConfigParser()
    cf.read(config_file_path)

s = cf.sections()
print &apos;section:&apos;, s

o = cf.options(&quot;baseconf&quot;)
print &apos;options:&apos;, o

v = cf.items(&quot;baseconf&quot;)
print &apos;db:&apos;, v

db_host = cf.get(&quot;baseconf&quot;, &quot;host&quot;)
db_port = cf.getint(&quot;baseconf&quot;, &quot;port&quot;)
db_user = cf.get(&quot;baseconf&quot;, &quot;user&quot;)
db_pwd = cf.get(&quot;baseconf&quot;, &quot;password&quot;)

print db_host, db_port, db_user, db_pwd

cf.set(&quot;baseconf&quot;, &quot;db_pass&quot;, &quot;123456&quot;)
cf.write(open(&quot;config_file_path&quot;, &quot;w&quot;))
if __name__ == &quot;__main__&quot;:
    test(&quot;../conf/db_config.ini&quot;)</code></pre><p>【题目:063】| 现有N个纯文本格式的英文文件，实现一种检索方案，即做一个小搜索引擎</p>
<p>【题目:064】| src = “security/afafsff/?ip=123.4.56.78&amp;id=45”，请写一段代码用正则匹配出IP</p>
<pre><code>import re

src = &quot;security/afafsff/?ip=123.4.56.78&amp;id=45&quot;
m = re.search(&apos;ip=(\d{1,3}\.\d{1,3}\.\d{1,3}.\d{1,3})&apos;, src, re.S)  # re.S 改变&apos;.&apos;的行为
print m.group(1)
# 输出结果
&gt;&gt;&gt;
123.4.56.78</code></pre><p>【题目:064】| 已知仓库中有若干商品，以及相应库存，类似：</p>
<p>袜子，10</p>
<p>鞋子，20</p>
<p>拖鞋，30</p>
<p>项链，40</p>
<p>要求随机返回一种商品，要求商品被返回的概率与其库存成正比。请描述实现的思路或者直接写一个实现的函数</p>
<pre><code># -*- coding: utf-8 -*-
import random

Wa_Zhi     = [&apos;WZ&apos;] * 100
Xie_Zi     = [&apos;XZ&apos;] * 200
Tuo_Xie    = [&apos;TX&apos;] * 300
Xiang_Lian = [&apos;XL&apos;] * 400

All_Before = Wa_Zhi + Xie_Zi + Tuo_Xie + Xiang_Lian
All_After  = random.sample(All_Before, 100)
print All_After.count(&apos;WZ&apos;)
print All_After.count(&apos;XZ&apos;)
print All_After.count(&apos;TX&apos;)
print All_After.count(&apos;XL&apos;)

#输出结果，大致满足需求1: 2: 3: 4的比例
&gt;&gt;&gt;
9
19
32
40</code></pre>]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>题目二</title>
    <url>/posts/103f59fc/</url>
    <content><![CDATA[<p>1.python参数传递是值传递还是引用传递<br>都是引用，对于不可改变的数据类型来说，不能改变，如果修改了，事实上是新建一个对象来对待。</p>
<p>2.lambda更简单，省去命名函数名的麻烦<br>f = lambda x,y:x+y<br>print(f(1, 2))</p>
<p>3.format可以接受参数不限个数，并且位置可以不按顺序<br>print(“{1}-{0}”.format(“good”, 123)) #123-good<br>print(“{name}-{age}”.format(age=23, name=”lius”))</p>
<p>4.编码/解码<br><a href="http://www.cnblogs.com/OldJack/p/6658779.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/OldJack/p/6658779.html</a><br>编码是指信息从一种形式或格式转换为另一种形式或格式的过程。<br>在计算机中，编码，简而言之，就是将人能够读懂的信息（通常称为明文）转换为计算机能够读懂的信息。众所周知，计算机能够读懂的是高低电平，也就是二进制位（0，1组合）。而解码，就是指将计算机的能够读懂的信息转换为人能够读懂的信息。</p>
<p>在Python2.x中，有两种字符串类型：str和unicode类型。str存bytes数据，unicode类型存unicode数据<br>在Python3.x中，也只有两种字符串类型：str和bytes类型。str类型存unicode数据，bytse类型存bytes数据，与python2.x比只是换了一下名字而已。<br>当我们在编辑文本的时候，字符在内存对应的是unicode编码的，这是因为unicode覆盖范围最广，几乎所有字符都可以显示。但是，当我们将文本等保存在磁盘时，数据是怎么变化的？<br>答案是通过某种编码方式编码的bytes字节串。比如utf-8，一种可变长编码，很好的节省了空间；当然还有历史产物的gbk编码等等。于是，在我们的文本编辑器软件都有默认的保存文件的编码方式，比如utf-8，比如gbk。当我们点击保存的时候，这些编辑软件已经”默默地”帮我们做了编码工作。<br>那当我们再打开这个文件时，软件又默默地给我们做了解码的工作，将数据再解码成unicode,然后就可以呈现明文给用户了！所以，unicode是离用户更近的数据，bytes是离计算机更近的数据。</p>
<p>5.反转<br>def reverse(text=”abc”):<br>    return text[::-1]<br>print(reverse(“12345”))</p>
<p>6.</p>
<p>7.<br>ll = [1,2,3,4,5,6,7]<br>print(ll[10:])    #输出[]</p>
<p>8.<br>keys = [“Name”, “Sex”, “Age”]<br>values = [“Jack”, “Male”, 19]<br>print(dict(zip(keys, values)))</p>
<p>9.<br>def extend(val, ll=[]):<br>    ll.append(val)<br>    return ll<br>l1 = extend(1)          #[1, 3]<br>l2 = extend(123, [])    #[123]<br>l3 = extend(3)          #[1, 3]<br>l4 = extend(456, [])    #[456]<br>print(l1, l2, l3, l4)</p>
<p>10.什么是GIL<br>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。<br>在多线程环境中，Python 虚拟机按以下方式执行：</p>
<ol>
<li>设置GIL</li>
<li>切换到一个线程去运行</li>
<li>运行：<br> a. 指定数量的字节码指令，或者<br> b. 线程主动让出控制（可以调用time.sleep(0)）</li>
<li>把线程设置为睡眠状态</li>
<li>解锁GIL</li>
<li>再次重复以上所有步骤<br><a href="http://m.blog.csdn.net/universe_ant/article/details/51243137" target="_blank" rel="external nofollow noopener noreferrer">http://m.blog.csdn.net/universe_ant/article/details/51243137</a></li>
</ol>
<p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p>
<p>可以用多进程避免GIL的问题。</p>
<p>11.python3取消iteritems<br>在Python2.x中，items( )用于 返回一个字典的拷贝列表【Returns a copy of the list of all items (key/value pairs) in D】，占额外的内存。<br>iteritems() 用于返回本身字典列表操作后的迭代【Returns an iterator on all items(key/value pairs) in D】，不占用额外的内存。<br>Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。</p>
<p>12.<br>try:<br>    with open(“text.txt”) as f:<br>        while True:<br>            line = f.readline()<br>            if not line:<br>                break<br>            print(line)<br>except FileNotFoundError:<br>    print(“No text.txt”)<br>#with语句使用上下文管理器对代码块进行包装，允许上下文管理器实现一些设置和清理操作<br>#with用在支持上下文管理协议的对象中，如file,thread.LockType<br>#当with语句执行时，便执行上下文表达式（context_expr）来获得一个上下文管理器，上下文管理器的职责是提供一个上下文对象，用于在with语句块中处理细节：<br>#一旦获得了上下文对象，就会调用它的<strong>enter</strong>()方法，将完成with语句块执行前的所有准备工作，如果with语句后面跟了as语句，则用<strong>enter</strong>()方法的返回值来赋值；<br>#当with语句块结束时，无论是正常结束，还是由于异常，都会调用上下文对象的<strong>exit</strong>()方法，<strong>exit</strong>()方法有3个参数，如果with语句正常结束，三个参数全部都是 None；如果发生异常，三个参数的值分别等于调用sys.exc_info()函数返回的三个值：类型（异常类）、值（异常实例）和跟踪记录（traceback），相应的跟踪记录对象。<br>#因为上下文管理器主要作用于共享资源，<strong>enter</strong>()和<strong>exit</strong>()方法干的基本是需要分配和释放资源的低层次工作，比如：数据库连接、锁分配、信号量加/减、状态管理、文件打开/关闭、异常处理等。</p>
<p>13.生成斐波那契数列<br>def fibs(x):<br>    result = [0, 1]<br>    for i in range(x-2):<br>        result.append(result[-2] + result[-1])<br>    return result<br>print(fibs(0))  #[0,1]</p>
<p>14.反序的迭代一个序列<br>x = [1,2,3,4,5]<br>for i in range(len(x)-1, -1, -1):<br>    print(x[i])</p>
<p>15.<br>L1 = [1,2,3,1,2,3,4,5]<br>L2 = []<br>[L2.append(i) for i in L1 if i not in L2]<br>print(L2)</p>
<p>16.<br>标准库线程安全的队列是哪一个，不安全是哪一个？logging是线程安全的吗？<br>线程安全即解决线程同步问题，Queue是线程安全队列，logging是线程安全的。</p>
<p>17.<br>import os<br>os.remove(filename)</p>
<p>18.得到list的交集，差集<br>l1 = [1,2,3,4,6]<br>l2 = [3,4,5,1,2]<br>l3 = [i for i in l1 if i not in l2]<br>l4 = [i for i in l1 if i in l2]<br>print(l3, l4)</p>
<p>19.<br>w = “Python is a very funny language”<br>w.find(“Python”)<br>w.replace(“Python”, “Ruby”)</p>
<p>20.<br>words = [“This”, “is”, “a”, “dog”]<br>words.sort(key=lambda x:x.lower())<br>print(words)</p>
<p>21.<br>lists = [“xyz”, “abc”, “opq”]<br>lists.sort(key=lambda x:x[1], reverse=True)<br>print(lists)</p>
<p>22.解析argv<br>import sys<br>for arg in sys.argv[1:]:<br>    print(arg)</p>
<p>23.<br>python高并发解决方案<br>twisted-&gt;tornado-&gt;gevent<br><a href="http://blog.csdn.net/screaming/article/details/51377870" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/screaming/article/details/51377870</a></p>
<p>24.<br>@staticmethod,@classmethod区别<br><a href="http://www.cnblogs.com/elie/p/5876210.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/elie/p/5876210.html</a><br>25.单例<br>class Singleton(object):<br>    <strong>instance = None<br>    def __new</strong>(cls, age, name):<br>        #如果类数字能够<strong>instance没有或者没有赋值<br>        #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时<br>        #能够知道之前已经创建过对象了，这样就保证了只有1个对象<br>        if not cls.</strong>instance:<br>            cls.<strong>instance = object.</strong>new__(cls)<br>        return cls.__instance</p>
<p>26.<br>python用递归判断字符串是否是回文<br>def isPlidromNonRecursive(inputStr):<br>    assert isinstance(inputStr, basestring)<br>    strLen = len(inputStr)<br>    currentStart = 0<br>    currentEnd = strLen - 1<br>    while currentStart &lt;= currentEnd:<br>        if inputStr[currentStart] != inputStr[currentEnd]:<br>            return False<br>        else:<br>            currentStart += 1<br>            currentEnd -= 1<br>    return True</p>
<p>def isPlidromRecursive(inputStr):<br>    assert isinstance(inputStr, basestring)<br>    if 0 &lt;= len(inputStr) &lt;= 1:<br>        return True<br>    if inputStr[0] != inputStr[-1]:<br>        return False<br>    else:<br>        return isPlidromRecursive(inputStr[1:-1])</p>
<p>def test_isPlidromNonRecursive():<br>    assert isPlidromNonRecursive(“level”)<br>    assert isPlidromNonRecursive(“noon”)<br>    assert isPlidromNonRecursive(“abcd”) == False</p>
<p>def test_isPlidromRecursive():<br>    assert isPlidromRecursive(“level”)<br>    assert isPlidromRecursive(“noon”)<br>    assert isPlidromRecursive(“abcd”) == False</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    test_isPlidromNonRecursive()<br>    test_isPlidromRecursive()</p>
<p>27.<br>def fib(times):<br>    n = 0<br>    a,b = 0,1<br>    while n &lt; times:<br>        yield b<br>        a,b = b,a+b<br>        n+=1<br>    return    ‘done’</p>
<p>迭代器，yield，装饰器</p>
<p>yield:<br><a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do" target="_blank" rel="external nofollow noopener noreferrer">https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do</a></p>
<p>迭代器：<br><a href="http://www.cnblogs.com/duwenxing/p/7397759.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/duwenxing/p/7397759.html</a><br>迭代，顾名思义就是重复做一些事很多次（就现在循环中做的那样）。迭代器是实现了<strong>next</strong>()方法的对象（这个方法在调用时不需要任何参数），它是访问可迭代序列的一种方式，通常其从序列的第一个元素开始访问，直到所有的元素都被访问才结束。 [注意]：迭代器只能前进不能后退<br>[迭代器的优点]:<br>使用迭代器不要求事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后元素可以不存在或者被销毁。因此迭代器适合遍历一些数量巨大甚至无限的序列。</p>
<p>生成器：<br>分类：生成器函数，生成器表达式</p>
<p><a href="http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html</a><br><a href="http://www.cnblogs.com/kaituorensheng/p/3826911.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/kaituorensheng/p/3826911.html</a><br><a href="http://python.jobbole.com/87805/" target="_blank" rel="external nofollow noopener noreferrer">http://python.jobbole.com/87805/</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000" target="_blank" rel="external nofollow noopener noreferrer">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="external nofollow noopener noreferrer">https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/</a><br><a href="http://blog.csdn.net/u013205877/article/details/70502508" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/u013205877/article/details/70502508</a><br><a href="http://python.jobbole.com/81692/" target="_blank" rel="external nofollow noopener noreferrer">http://python.jobbole.com/81692/</a><br><a href="http://www.cnblogs.com/gide/p/6187080.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/gide/p/6187080.html</a><br><a href="http://www.cnblogs.com/patrick0715/p/5957387.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/patrick0715/p/5957387.html</a><br><a href="http://blog.csdn.net/gvfdbdf/article/details/52116661" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/gvfdbdf/article/details/52116661</a><br><a href="http://python.jobbole.com/86632/" target="_blank" rel="external nofollow noopener noreferrer">http://python.jobbole.com/86632/</a></p>
<p>可以直接作用于for循环的对象统称为可迭代对象：Iterable。<br>生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p>
<p>import asyncio<br>@asyncio.coroutine<br>def countdown(number, n):<br>    while n &gt; 0:<br>        print(‘T-minus’, n, ‘({})’.format(number))<br>        yield from asyncio.sleep(1)<br>        n -= 1</p>
<p>loop = asyncio.get_event_loop()<br>tasks = [<br>    asyncio.ensure_future(countdown(“A”, 2)),<br>    asyncio.ensure_future(countdown(“B”, 3))]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()</p>
<p>#############<br>import asyncio<br>async def hello():<br>        print(“Hello World”)<br>        r = await asyncio.sleep(3)<br>        print(“Again”)</p>
<p>loop = asyncio.get_event_loop()<br>tasks = [hello(), hello()]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()</p>
<p>类装饰器<br>class Foo(object):<br>    def <strong>init</strong>(self, func):<br>        self.<em>func = func<br>    def <em>_call</em></em>(self):<br>        print (‘class decorator runing’)<br>        self._func()<br>        print (‘class decorator ending’)</p>
<p>@Foo<br>def bar():<br>    print (‘bar’)</p>
<p>装饰器其实也就是一个函数，一个用来包装函数的函数，返回一个修改之后的函数对象。经常被用于有切面需求的场景，较为经典的有插入日志、 性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。<br>    import functools<br>    def log(tag=None):<br>        def decorator(func):<br>            @functools.wraps(func)<br>            def wrapper(<em>args, *</em>kwarg):<br>                print(tag)<br>                return func(<em>args, *</em>kwarg)<br>            return wrapper<br>        return decorator</p>
<pre><code>@log(&quot;first tag&quot;)
def run(*args, **kwarg):
    print(&quot;run&quot;)

run()
print(run.__name__)</code></pre><p>28.猴子补丁<br>#在函数活对象定义之后再去改变他们的行为<br>在运行时替换方法、属性等<br>在不修改第三方代码的情况下增加原来不支持的功能<br>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</p>
<p>在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在代码运行时（内存中）发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。</p>
<p>29.<br>[1]*4 –&gt;[1,1,1,1,1]</p>
<p>li = [[]] * 5<br>li[0].append(19)<br>li[1].append(29)<br>li.append(39)<br>print(li)<br>[[19, 29], [19, 29], [19, 29], [19, 29], [19, 29], 39]</p>
<p>30.<br>协程的概念<br>协程是在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。他本身是一种特殊的子程序或者称作函数。</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A(可以自由切换)。但这一过程并不是函数调用(没有调用语句)，这一整个过程看似像多线程，然而协程只有一个线程执行。</p>
<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>31.<br>#如何设计deepcopy<br><a href="http://blog.csdn.net/kuaileboy1989/article/details/44151163" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/kuaileboy1989/article/details/44151163</a></p>
<p>#正则匹配邮箱</p>
<p>33.<br>class myClass(object):<br>    def <strong>init</strong>(self):<br>        self._some_property = “some property”<br>        self._some_another_property = “some another property”</p>
<pre><code>def normal_method(*args, **kwargs):
    print(&quot;calling normal method{0},{1}&quot;.format(args, kwargs))

@classmethod
def class_method(*args, **kwargs):
    print(&quot;calling class method{0},{1}&quot;.format(args, kwargs))

@staticmethod
def static_method(*args, **kwargs):
    print(&quot;calling static method{0},{1}&quot;.format(args, kwargs))

@property
def some_property(self, *args, **kwargs):
    print(&quot;calling some property getter{0},{1},{2}&quot;.format(self, args, kwargs))
    return self._some_property

@some_property.setter
def some_property(self, *args, **kwargs):
    print(&quot;calling some_property setter{0},{1},{2}&quot;.format(self, args, kwargs))
    self._some_property = args[0]

@property
def some_another_property(self, *args, **kwargs):
    print(&quot;calling some another property getter{0},{1},{2}&quot;.format(self, args, kwargs))
    return self._some_another_property</code></pre><p>o = myClass()<br>print(o.normal_method)#&lt;bound method myClass.normal_method of &lt;<strong>main</strong>.myClass object at 0x000000000267F160&gt;&gt;<br>o.normal_method()<br>print(o.class_method) #&lt;bound method myClass.class_method of &lt;class ‘<strong>main</strong>.myClass’&gt;&gt;<br>o.class_method()<br>print(o.static_method)#&lt;function myClass.static_method at 0x00000000026737B8&gt;<br>o.static_method()<br>o.some_property<br>o.some_another_property<br>o.some_property = [1,2,3]<br>print(o.some_property)</p>
<p>34<br>def print_content_name(path):<br>    import os<br>    for sChild in os.listdir(path):<br>        sChildPath = os.path.join(path, sChild)<br>        if os.path.isdir(sChildPath):<br>            print_content_name(sChildPath)<br>        else:<br>            print(sChildPath)</p>
<p>35.<br>from functools import reduce<br>print(reduce(lambda x,y:x+y, [1,2,3]))  #6</p>
<p>36.<br>tornado原理<br><a href="https://www.rapospectre.com/blog/understanding-tornado-ioloop" target="_blank" rel="external nofollow noopener noreferrer">https://www.rapospectre.com/blog/understanding-tornado-ioloop</a><br><a href="http://www.nowamagic.net/academy/detail/13321002" target="_blank" rel="external nofollow noopener noreferrer">http://www.nowamagic.net/academy/detail/13321002</a><br>39.<br>class P(object):<br>    n = []<br>    t = “test”<br>p1 = P()<br>p2 = P()<br>print(p1.t)<br>print(p2.t)<br>p1.t = “p1”<br>print(p1.t)   #p1<br>print(p2.t)   #test<br>p1.n.append(1)<br>p2.n.append(20)<br>print(p1.n)   #[1, 20]<br>print(p2.n)   #[1, 20]</p>
<p>40.字典推导式<br>dd = {“one”:1, “two”:2}<br>d = {k:v+1 for k,v in dd.items()}<br>print(d)</p>
<p>41.<em>args, *</em>kwargs<br>def print_everthing(<em>args):<br>    for count, thing in enumerate(args):<br>        print(“{0}-{1}”.format(count, thing))<br>def table_things(*</em>kwargs):<br>    for k, v in kwargs.items():<br>        print(“{0}-{1}”.format(k, v))<br>print_everthing(“one”, “two”, “three”)<br>table_things(first=1, second=2)</p>
<p>42.新式类和旧式类区别<br>为了统一type和class<br>在2.2之前，比如2.1版本中，类和类型是不同的，如a是ClassA的一个实例，那么a.<strong>class</strong>返回 ‘ class    <strong>main</strong>.ClassA‘ ，type(a)返回总是&lt;type ‘instance’&gt;。而引入新类后，比如ClassB是个新类，b是ClassB的实例，b.<strong>class</strong>和type(b)都是返回‘class ‘<strong>main</strong>.ClassB’ ，这样就统一了。<br>在多继承中，新式类采用广度优先搜索，而旧式类是采用深度优先搜索。</p>
<p>43.Python2和Python3区别<br>#统一了字符编码支持<br>#增加了新的语法，print，格式化字符串变量，nonlocal，yield<br>#修改了一些语法，map，filter，dict的items/keys/values由返回列表到返回迭代对象<br>#去掉了一些语法xrange，不再有经典类</p>
<p>44.<strong>new</strong>和<strong>init</strong>的区别<br><a href="http://www.jb51.net/article/52023.htm" target="_blank" rel="external nofollow noopener noreferrer">http://www.jb51.net/article/52023.htm</a><br>通过运行这段代码，我们可以看到，<strong>new</strong>方法的调用是发生在<strong>init</strong>之前的。其实当 你实例化一个类的时候，具体的执行逻辑是这样的：<br>1.p = Person(name, age)<br>2.首先执行使用name和age参数来执行Person类的<strong>new</strong>方法，这个<strong>new</strong>方法会 返回Person类的一个实例（通常情况下是使用 super(Persion, cls).<strong>new</strong>(cls, … …) 这样的方式）<br>3.然后利用这个实例来调用类的<strong>init</strong>方法，上一步里面<strong>new</strong>产生的实例也就是 <strong>init</strong>里面的的 self。<br>所以，<strong>init</strong> 和 <strong>new</strong> 最主要的区别在于：<br>1.<strong>init</strong> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。<br>2.<strong>new</strong> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p>
<p><strong>new</strong>是一个静态方法,而<strong>init</strong>是一个实例方法.<br><strong>new</strong>方法会返回一个创建的实例,而<strong>init</strong>什么都不返回.<br>只有在<strong>new</strong>返回一个cls的实例时后面的<strong>init</strong>才能被调用.<br>当创建一个新实例时调用<strong>new</strong>,初始化一个实例时用<strong>init</strong>.</p>
<p>45.<br>import copy<br>a = [1, 2, 3, 4, [‘a’, ‘b’]]<br>b = a<br>c = copy.copy(a)<br>d = copy.deepcopy(a)<br>a.append(5)<br>a[4].append(‘c’)<br>print(“a=”, a)     #[1,2,3,4,[‘a’, ‘b’, ‘c’], 5]<br>print(“b=”, b)       #[1,2,3,4,[‘a’, ‘b’, ‘c’], 5]<br>print(“c=”, c)       #[1,2,3,4,[‘a’, ‘b’, ‘c’]]<br>print(“d=”, d)       #[1,2,3,4,[‘a’, ‘b’]]</p>
<p>46.is和==<br>is比较id，==比较值<br>a = 1<br>b = 1<br>print(“a=1, b=1”, a is b) #True<br>x = 123456789<br>y = 123456789<br>print(“x=123456789, y=123456789”, x is y) #True<br>a = “abc”<br>b = “abc”<br>print(“a=abc, b=abc”, a is b)  #True<br>a = [1, 2]<br>b = [1, 2]<br>print(“a:[1,2], b:[1,2]”, a is b) #Flase</p>
<p>47.调度算法<br>先来先服务，最高优先权调度，时间片轮转，短作业优先</p>
<p>48.死锁<br><a href="http://blog.csdn.net/abigale1011/article/details/6450845/" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/abigale1011/article/details/6450845/</a><br>指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。<br>产生死锁的必要条件：<br>互斥，不可抢占，占有且申请，循环等待</p>
<p>处理死锁基本方法:<br>预防死锁(摒弃除1以外的条件)<br>避免死锁(银行家算法)<br>检测死锁(资源分配图)<br>解除死锁<br>    剥夺资源<br>    撤销进程<br>49.<br>li = [lambda :x for x in range(10)]<br>print(type(li))    #list<br>print(type(li[0])) #function<br>res = li<a href>0</a><br>print(res)  #9</p>
<p>50.<br>name = “peter”<br>def f1():<br>    print(name)<br>def f2():<br>    name = “bob”<br>    f1()<br>f2()  #peter</p>
<p>51.<br>def scope_test():<br>    def do_local():<br>        spam = “local spam”<br>    def do_nonlocal():<br>        nonlocal spam<br>        spam = “nonlocal spam” #要想修改父函数的变量，需使用nonlocal<br>    def do_global():<br>        global spam<br>        spam = “global spam”<br>    spam = “test spam”<br>    do_local()<br>    print(“After local assignment:”, spam)      #test spam<br>    do_nonlocal()<br>    print(“After nonlocal assignment:”, spam)   #nonlocal spam<br>    do_global()<br>    print(“After global assignment:”, spam)     #nonlocal spam</p>
<p>scope_test()<br>print(“In global scope:”, spam)                 #global spam</p>
<p>52.闭包   装饰器和闭包？？？<br>必须有一个内嵌函数<br>内嵌函数必须引用外部函数中的变量<br>外部函数的返回值必须是内嵌函数</p>
<p>Python中的闭包的概念， 就相当于在某个函数中又定义了一个或多个函数， 内层函数定义了具体的实现方式， 而外层返回的就是这个实现方式， 但并没有执行， 除非外层函数调用的内层的实现方法被执行了。<br>闭包函数必须含有内嵌函数，内嵌函数需要引用该嵌套函数上一级namespace中的变量，闭包函数必须返回内嵌函数。<br>def greeting_conf(prefix):<br>    def greeting(name):<br>        print(prefix, name)<br>    return greeting</p>
<p>mG = greeting_conf(“Good morning”)<br>print(“mG name is:”, mG.<strong>name</strong>)          #greeting<br>print(“id of mG is:”, id(mG))<br>mG(“Lius”)</p>
<p>aG = greeting_conf(“Good afternoon”)<br>print(“aG name is:”, aG.<strong>name</strong>)<br>print(“id of aG is:”, id(aG))<br>aG(“Lius”)</p>
<p>print(dir(aG))<br>print(aG.<strong>closure</strong>)<br>print(type(aG.<strong>closure</strong>[0]))<br>print(aG.<strong>closure</strong>[0].cell_contents)</p>
<p>mG name is: greeting<br>id of mG is: 51950456<br>Good morning Lius<br>aG name is: greeting<br>id of aG is: 51950592<br>Good afternoon Lius</p>
<p>53.<br>class A(object):<br>    def <strong>init</strong>(self):<br>        print(“Enter A”)<br>        print(“Leave A”)</p>
<p>class B(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter B”)<br>        super(B, self).<strong>init</strong>()<br>        print(“Leave B”)</p>
<p>class C(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter C”)<br>        super(C, self).<strong>init</strong>()<br>        print(“Leave C”)</p>
<p>class D(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter D”)<br>        super(D, self).<strong>init</strong>()<br>        print(“Leave D”)</p>
<p>class E(B, C, D):<br>    def <strong>init</strong>(self):<br>        print(“Enter E”)<br>        super(E, self).<strong>init</strong>()<br>        print(“Leave E”)</p>
<p>E()<br>Enter E<br>Enter B<br>Enter C<br>Enter D<br>Enter A<br>Leave A<br>Leave D<br>Leave C<br>Leave B<br>Leave E</p>
<p>54.<br>data = [‘1’, ‘2’, ‘3’]<br>print(sum(int(i) for i in data))<br>print(reduce(lambda x,y:int(x)+int(y), data))</p>
<ol start="55">
<li>and or<br>对python而言<br>其一, 在不加括号时候, and优先级大于or<br>其二, x or y 的值只可能是x或y.  x为真就是x, x为假就是y<br>第三, x and y 的值只可能是x或y.  x为真就是y, x为假就是x</li>
</ol>
<p>56.<br>import re<br>s= “123 and 222”<br>re.sub(“\d\d\d”, “hello”, s)   #”hello and hello”</p>
<p>57.<br>import random<br>random.random()#0~1<br>random.randint(1, 20)</p>
<p>58.python拷贝文件<br>shutil模块copyfile函数<br>shutil.copyfile( src, dst) 从源src复制到dst中去。</p>
<p>58.垃圾回收：<br>引用计数<br>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1，当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。<br>标记清除</p>
<ol>
<li>寻找跟对象（root object）的集合作为垃圾检测动作的起点，跟对象也就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的；2. 从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段；3. 当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的对象连接在一起）</li>
</ol>
<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p>分代回收<br>将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，Python默认定义了三代对象集合，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。<br><a href="http://www.cnblogs.com/George1994/p/7349871.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/George1994/p/7349871.html</a></p>
<p>59.map,reduce,filter</p>
<p>60.元类<br><a href="http://www.cnblogs.com/tkqasn/p/6524879.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/tkqasn/p/6524879.html</a><br><a href="http://developer.51cto.com/art/201108/281521.htm" target="_blank" rel="external nofollow noopener noreferrer">http://developer.51cto.com/art/201108/281521.htm</a></p>
<p>61.线程和协程区别<br><a href="http://www.cnblogs.com/guokaixin/p/6041237.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/guokaixin/p/6041237.html</a><br>1、进程<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。<br>2、线程<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<br>3、协程<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>1、进程多与线程比较<br>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>
<p>1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间<br>2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源<br>3) 线程是处理器调度的基本单位,但进程不是<br>4) 二者均可并发执行<br>5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>2、协程多与线程进行比较</p>
<p>1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。<br>2) 线程进程都是同步机制，而协程则是异步<br>3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
<p>数据库<br>1.mysql字符集，排序规则<br>字符集，即用于定义字符在数据库中的编码的集合。 常见的字符集：utf-8 gbk 等。</p>
<p>数据库中的排序规则用来定义字符在进行排序和比较的时候的一种规则。 常见的如下：<br>（1） utf8_general_cs 和 utf8_general_ci （后缀”_cs”或者”_ci”意思是区分大小写和不区分大小写（Case Sensitive &amp; Case Insensitve））<br>（2） utf8_bin 规定每个字符串用二进制编码存储，区分大小写，可以直接存储二进制的内容</p>
<p>说明：所为排序规则，就是指字符比较时是否区分大小写，以及是按照字符编码进行比较还是直接用二进制数据比较。</p>
<p>2.varchar/char区别，大小限制，utf8字符集下varchar最多能存多少字符<br>1)<br>char的长度是不可变的，而varchar的长度是可变的，也就是说，定义一个char[10]和varchar[10],如果存进去的是‘csdn’,那么char所占的长度依然为10， 除了字符‘csdn’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。<br>尽管如此，char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。<br>2)存储的容量不同<br>对 char 来说，最多能存放的字符个数 255，和编码无关。<br>而 varchar 呢，最多能存放 65532 个字符。VARCHAR 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节。</p>
<p><a href="http://blog.csdn.net/a347911/article/details/47280453" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/a347911/article/details/47280453</a><br><a href="http://www.cnblogs.com/webph/p/6679815.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/webph/p/6679815.html</a></p>
<p>4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）<br>5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节</p>
<p>3.外键有什么用，外键一定需要索引吗<br>外键：为某一表的一列，包含另一表的主键值<br>外键作用：保持数据完整性一致性。<br>需要<br>否则影响并发性，做很多无效操作<br><a href="http://blog.csdn.net/lv996074344/article/details/45866291" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/lv996074344/article/details/45866291</a><br><a href="http://blog.csdn.net/u012557538/article/details/44002789" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/u012557538/article/details/44002789</a></p>
<p>1。主键用于唯一标识表中的行数据，不能为空，一个主键值对应一行数据。另外，会自动在主键上创建索引，用于加快查询。<br>2。 外键用于两个表的联系。两个表必须具有相同类型的属性，在该属性上有相同的值。该属性应为其中一个表的主键，在另外一个表设置为外键。约束内表的数据的更新，从定义外键时可以发现 外键是和主键表联系，数据类型要统一，长度(存储大小)要统一。这样在更新数据的时候会保持一致性。<br>4.primary key和unique的区别？<br>定义了 UNIQUE 约束的字段中不能包含重复值，可以为一个或多个字段定义 UNIQUE 约束。因此，UNIQUE 即可以在字段级也可以在表级定义， 在 UNIQUED 约束的字段上可以包含空值。<br>UNIQUED 可空，可以在一个表里的一个或多个字段定义；PRIMARY KEY 不可空不可重复，在一个表里可以定义联合主键。primary key = unique +  not null</p>
<p><a href="http://blog.csdn.net/zm2714/article/details/8482625" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/zm2714/article/details/8482625</a></p>
<p>5.myisam和innodb区别，innodb的两阶段锁定协议是什么情况</p>
<p>两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。<br><a href="http://blog.csdn.net/endlu/article/details/51531391" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/endlu/article/details/51531391</a></p>
<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。<br>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。<br>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/0201zcr/p/5296843.html</a> MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000008227211</a></p>
<p>6.索引有什么用，大致原理是？<br>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br><a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/suifeng3051/article/details/52669644</a><br><a href="http://chriszeng87.iteye.com/blog/1180762" target="_blank" rel="external nofollow noopener noreferrer">http://chriszeng87.iteye.com/blog/1180762</a><br><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/kennyrose/article/details/7532032</a></p>
<p>7.什么场景用redis？为什么mysql不适合<br>缓存，消息队列(list)，排行榜(set)，计数器<br><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="external nofollow noopener noreferrer">http://www.scienjus.com/redis-use-case/</a><br>从效率来说：<br>Redis的数据存放在内存，所以速度快但是会受到内存空间限制。MySQL存放在硬盘，在速度上肯定没有Redis快，但是存放的数据量要多的多。<br>从功能来说：<br>Redis是一个K-V数据库，同时还支持List/Hash/Set/Sorted Set等几个简单数据结构。<br>持久化方面肯定不如MySQL可靠，内存价格。</p>
<p>8.redis事务？<br><a href="http://blog.csdn.net/hechurui/article/details/49508749" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/hechurui/article/details/49508749</a><br><a href="http://blog.csdn.net/why_2012_gogo/article/details/51274388" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/why_2012_gogo/article/details/51274388</a><br>redis的事务中，一次执行多条命令，本质是一组命令的集合，一个事务中所有的命令将被序列化，即按顺序执行而不会被其他命令插入。<br>在redis中，事务的作用就是在一个队列中一次性、顺序性、排他性的执行一系列的命令。<br>常用的关于事务的命令有：</p>
<ol>
<li><p>MULTI：使用该命令，标记一个事务块的开始，通常在执行之后会回复OK，（但不一定真的OK），这个时候用户可以输入多个操作来代替逐条操作，redis会将这些操作放入队列中。</p>
</li>
<li><p>EXEC：执行这个事务内的所有命令</p>
</li>
<li><p>DISCARD：放弃事务，即该事务内的所有命令都将取消</p>
</li>
<li><p>WATCH：监控一个或者多个key，如果这些key在提交事务（EXEC）之前被其他用户修改过，那么事务将执行失败，需要重新获取最新数据重头操作（类似于乐观锁）。</p>
</li>
<li><p>UNWATCH：取消WATCH命令对多有key的监控，所有监控锁将会被取消。</p>
</li>
<li><p>Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离</p>
</li>
<li><p>用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性</p>
</li>
<li><p>用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback</p>
</li>
<li><p>其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚</p>
</li>
</ol>
<p>9.redis内存满了怎么办<br>1.加内存<br>2.清理数据，设置 lru 过期机制 Least Recently Used<br>3.搭集群 或者 再弄个实例用twemproxy均衡数据<br><a href="http://blog.jobbole.com/107084/" target="_blank" rel="external nofollow noopener noreferrer">http://blog.jobbole.com/107084/</a></p>
<p>10.mysql锁种类，死锁如何产生的<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>所谓死锁<deadlock>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</deadlock></p>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。<br>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序<br><a href="http://blog.csdn.net/csdn265/article/details/51780852" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/csdn265/article/details/51780852</a><br><a href="http://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/zejin2008/p/5262751.html</a></p>
<p>11.join种类<br><a href="http://www.cnblogs.com/dynas/p/6908707.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/dynas/p/6908707.html</a><br>12.索引类型，BTree和hash索引区别<br><a href="http://www.cnblogs.com/hanybblog/p/6485419.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/hanybblog/p/6485419.html</a><br>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree索引。<br>（1）Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。<br>（2）Hash 索引无法被用来避免数据的排序操作。<br>（3）Hash索引不能利用部分索引键查询。</p>
<p>13.Redis面试题及分布式集群<br><a href="http://blog.csdn.net/jinfeiteng2008/article/details/53711752" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/jinfeiteng2008/article/details/53711752</a><br><a href="http://blog.csdn.net/yajlv/article/details/73467865" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/yajlv/article/details/73467865</a></p>
<p>14.事务<br>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br><a href="http://www.hollischuang.com/archives/898" target="_blank" rel="external nofollow noopener noreferrer">http://www.hollischuang.com/archives/898</a></p>
<p>15.悲观锁乐观锁<br>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<br>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p>
<p>redis和memcache比较</p>
<p>网络<br>1.<br>poll,epoll，select区别，边缘触发，水平触发区别<br><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/Anker/p/3265058.html</a><br>select，poll，epoll都是IO多路复用的机制。<br>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。<br>水平触发(level-triggered，也被称为条件触发)LT: 只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)。select属于条件触发。<br>边缘触发(edge-triggered)ET: 每当状态变化时，触发一个事件。</p>
<p>2.tcp粘包，如何处理<br><a href="http://www.cnblogs.com/kex1n/p/6502002.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/kex1n/p/6502002.html</a><br><a href="http://blog.csdn.net/zhangxinrun/article/details/6721495" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/zhangxinrun/article/details/6721495</a><br>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>粘包与拆包是由于TCP协议是字节流协议，没有记录边界所导致的。 所以如何确定一个完整的业务包就由应用层来处理了。 （这就是分包机制，本质上就是要在应用层维护消息与消息的边界。） 分包机制一般有两个通用的解决方法： 1,特殊字符控制，例如FTP协议。 2,在包头首都添加数据包的长度，例如HTTP协议。</p>
<p>3.time_wait是什么情况，出现过多的close_wait原因<br><a href="http://blog.csdn.net/yusiguyuan/article/details/21445883" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/yusiguyuan/article/details/21445883</a><br><a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/Jessy/p/3535612.html</a><br>CLOSE_WAIT<br>发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，<br>但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，<br>如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。<br>TIME_WAIT<br>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态。<br>TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟，即240秒。<br>TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,<br>如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket，<br>甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。</p>
<p>4.https过程<br>http 运行在TCP 之上，数据明文传输。HTTPS 运行在SSL/TLS之上，SSL/TLS运行在TCP之上，是加密协议，因此HTTPS传输的已经是加密的数据，加密采用对称加密。但对称加密的密钥用服务器方的证书进行了非对称加密。SSL/TLS中使用了非对称加密，对称加密以及HASH算法。<br><a href="http://www.cnblogs.com/binyue/p/4500578.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/binyue/p/4500578.html</a><br>HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256</p>
<p>5.TCP UDP的区别 滑动窗口</p>
<p>滑动窗口：滑动窗口是TCP传输时的一个缓冲区机制，用来解决传输控制和流量控制的问题，TCP在发送端和接收端都有一个滑动窗口，当接收端成功接收了某段数据并移动了接收窗口的时候，发送端的窗口也会随之移动到缓冲区后面的数据段中。</p>
<p>6.socket长连接<br>长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。<br>连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；<br>这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了。<br><a href="http://blog.csdn.net/zdwzzu2006/article/details/7723738" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/zdwzzu2006/article/details/7723738</a></p>
<p>对称加密与非对称加密区别？<br>对称加密是指加密和解密使用的密钥是同一个密钥，或者可以相互推算。<br>对称加密的优点是算法简单，加解密效率高，系统开销小，适合对大数据量加密。<br>缺点是解密加密使用同一个密钥，需要考虑远程通信的情况下如何安全的交换密钥，如果密钥丢失，所谓的加密解密就失效了。<br>非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称为公钥，另一个只有所有者知道称作私钥。<br>用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>7.get post区别<br><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html</a></p>
<ol>
<li>GET使用URL或Cookie传参。而POST将数据放在BODY中。</li>
<li>GET的URL会有长度上的限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。<br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html</a></li>
</ol>
<p>8.session，cookie区别，为什么说session是安全的<br><a href="http://blog.csdn.net/rongwenbin/article/details/51784620" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/rongwenbin/article/details/51784620</a><br>9.uwsgi，nginx作用</p>
<p>WSGI 是服务器程序与应用程序的一个约定，它规定了双方各自需要实现什么接口，提供什么功能，以便二者能够配合使用。<br><a href="http://www.cnblogs.com/Xjng/p/aa4dd23918359c6414d54e4b972e9081.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/Xjng/p/aa4dd23918359c6414d54e4b972e9081.html</a><br><a href="http://blog.csdn.net/u014761344/article/details/40146597" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/u014761344/article/details/40146597</a><br><a href="http://www.cnblogs.com/gdkl/p/6807667.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/gdkl/p/6807667.html</a><br><a href="http://www.cnblogs.com/luchuangao/p/Gunicorn.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/luchuangao/p/Gunicorn.html</a></p>
<p>gunicorn<br>gunicorn 会启动一组 worker进程，所有worker进程公用一组listener，在每个worker中为每个listener建立一个wsgi server。每当有HTTP链接到来时，wsgi server创建一个协程来处理该链接，协程处理该链接的时候，先初始化WSGI环境，然后调用用户提供的app对象去处理HTTP请求。</p>
<p>10.浏览器一个请求从发送到返回经历了什么<br><a href="http://www.cnblogs.com/xiexj/p/6439775.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/xiexj/p/6439775.html</a></p>
<p>11.短连接如何设计<br><a href="https://segmentfault.com/a/1190000011171643" target="_blank" rel="external nofollow noopener noreferrer">https://segmentfault.com/a/1190000011171643</a></p>
<p>12.微信红包设计<br><a href="http://www.open-open.com/lib/view/open1430729729960.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.open-open.com/lib/view/open1430729729960.html</a><br>设计一个类似QQ的工具</p>
<p>13.下图是最基本的web服务器的结构图。<br><a href="https://github.com/liukelin/canal_mysql_nosql_sync" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/liukelin/canal_mysql_nosql_sync</a></p>
<p>14.<br>15.tcp面试<br><a href="http://blog.csdn.net/u012658346/article/details/51192944" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/u012658346/article/details/51192944</a><br><a href="http://www.cnblogs.com/freebrid/p/4640748.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/freebrid/p/4640748.html</a><br><a href="http://blog.csdn.net/hyqwmxsh/article/details/52437499" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/hyqwmxsh/article/details/52437499</a></p>
<p>16.</p>
<p>CSRF:<br><a href="http://www.cnblogs.com/shytong/p/5308667.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/shytong/p/5308667.html</a><br>其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用POST方式提交参数的页面。</p>
<p>CSRF工具的防御手段</p>
<ol>
<li>尽量使用POST，限制GET<br>GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。<br>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。</li>
<li>浏览器Cookie策略<br>IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。<br>PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。<br>PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。</li>
<li>加验证码<br>验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。</li>
<li>Referer Check<br>Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。<br>但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</li>
<li>Anti CSRF Token<br>现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。<br>例子：</li>
<li>用户访问某个表单页面。</li>
<li>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</li>
<li>在页面表单附带上Token参数。</li>
<li>用户提交请求后， 服务端验证表单中                                                                                                                                                                                                                                                                                                                                                                                                                                                                Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。<br>这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。<br>注意：<br>CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。</li>
</ol>
<p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<p>HTTP 1.1与HTTP 1.0的比较<br><a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="external nofollow noopener noreferrer">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<p>理解RESTful架构<br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<p>浏览器缓存机制<br><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external nofollow noopener noreferrer">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>算法</p>
<p>leetcode:<a href="https://github.com/bluedazzle/leetcode_python" target="_blank" rel="external nofollow noopener noreferrer">https://github.com/bluedazzle/leetcode_python</a></p>
<p>其他<br>工作流<br>session共享，redis怎么存储session，session失效机制<br>session过期时间，过长怎么样<br>redis复制过程，redis插槽分配，redis主节点宕机了怎么办<br>python自省<br>tcp，udp区别，应用场景<br>io密集，cpu密集<br>多进程同时拥有同一个描述符的情况：惊群<br>面试官又问多线程情况下如何保证每个线程都能平均io，我问是不是负载均衡，他说是，我就说了用线程池加round robin。他就追问怎么实现线程池，我说条件变量加blocking</p>
<p>秒杀系统设计<br>tcp如何保证可靠传输</p>
<p>HTTP请求方式<br>GET/POST 幂等、安全性，长度限制<br>HTTP状态码</p>
<p>设计一个Timer类，要求里面的类方法sleep，10s内只能被调用一次<br>两个列表s1，s2，长度不定，用什么方法可以快速判断s1,s2有没有重复的元素？比较s1,s2差异？</p>
<p>数据库是如何设计的？<br>nginx原理<br>项目缓存设计</p>
<p>觉得自己沟通能力怎么样？<br>为什么从上一家离职？<br>遇到最难解决的是什么问题？如何解决的？<br>哪件事情最有成就感？<br>缺点？</p>
<p>get,<strong>getattr</strong>,getattribute区别<br>为什么使用tornado?<br>对事件驱动编程模型的看法？<br>讲下多进程，多线程，协程<br><a href="https://www.cnblogs.com/huangguifeng/p/7632799.html" target="_blank" rel="external nofollow noopener noreferrer">https://www.cnblogs.com/huangguifeng/p/7632799.html</a><br>介绍一下协程的任务调度<br>实现tail命令</p>
<p>快排<br>将句子反序i am abc –&gt;abc am i<br>服务器调用accept()之前，如果服务端sleep()，客户端connect()能否成功<br>服务器调用accept()之后，如果服务器sleep()，客户端connect()能否成功<br>客户端连接成功后，如果服务器sleep()，客户端发送send()，是否可以成功<br>如果服务器主动关闭连接，那么客户端关闭连接过程<br>二叉查找树</p>
<p>改善python的91个建议<br>http协议<br>职业规划</p>
<p>生成器概念，用途，能实现什么<br>使用生成器模拟线程并发<br>gevent咋实现的</p>
<p>flask架构<br>什么是闭包<br>字节和字符区别<br>nginx负载均衡的实现<br>抢票系统<br>高并发的服务器设计<br>集群中的session同步<br>集群间做缓存，一个节点挂了怎么办<br>集群间消息队列<br>索引实现机制</p>
<p><a href="http://www.jianshu.com/p/557afbccbed0" target="_blank" rel="external nofollow noopener noreferrer">http://www.jianshu.com/p/557afbccbed0</a></p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
</search>
